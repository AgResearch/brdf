
/*
* This script creates and initialises core tables , sequences, stored functions and database triggers 
* of a biological resource description framework (brdf).
*
* (See the create_sitedatabase.psql script for additional setup for a specific
* instance)
*
* 
*/
 
/* 
*
*********************************************************************
* Base ob tables
*********************************************************************
*
*/
/*
* Each object in the database has a type. This table lists all the
* types
*/
\echo creating obtype_obtypeidseq
create sequence obtype_obtypeidseq;

\echo creating obtype
/*
* see note below on virtual ops.
*
* dynamic ops are ops whose definition is stored in the 
* database, but that is instantiated dynamically via a query
*
*/
create table obtype (
   obtypeid integer  DEFAULT nextval('obtype_obtypeidseq') primary key,
   displayname varchar(2048),
   URI varchar(2048) , 
   displayURL varchar(2048) default 'ob.gif',
   tablename varchar(128),
   namedInstances boolean default TRUE,
   isop boolean default FALSE,
   isvirtual boolean default FALSE,
   isdynamic boolean default FALSE,
   owner varchar(128) default 'core',
   obtypedescription varchar(2048)
) without oids;
\echo intialiasing obtype
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription) 
values (0,'BRDF Object','ob','BRDF Object');

COMMENT on table obtype is 'Types of object and relation stored in the brdf schema ';


COMMENT on column obtype.isop is 'Database entities are either primary objects such as sequences,samples, genes (obs), or 
relations (operations, or ops) between primary objects - e.g. op1(ob1,ob2,ob3...). Obs and ops may also be interpreted 
as nodes and edges in a hypergraph. isop is TRUE for ops or FALSE for obs';

COMMENT on column obtype.tablename is 'Unary relations are called facts, stored in tables named *fact ; binary relations are called links, 
stored in tables named *link ; ternary and higher relations are called either functions or studies and are stored in tables called
*function, or *study ';

COMMENT on column obtype.namedinstances is 'Most objects and relations are stored in tables that inherit from the ob table, and hence 
each instance is assigned a unique numeric name (obid) - namedinstances is TRUE for these. Some relations are stored 
in tables that do not inherit from the ob table, and do not have obids - namedInstances is FALSE for these.';

COMMENT on column obtype.isvirtual is 'In most cases there is one database table for each type. Some types share a table - these are 
virtual types. is virtual is FALSE for most types, TRUE for types that share a table with another primary type';

COMMENT on column obtype.isdynamic is 'In most cases there is one database table for each type. However some types are not stored in a 
database table  but are constructed dynamically at run time';

\echo creating method for retrieving ob type from ob table name
CREATE or replace FUNCTION getObTypeid(varchar) RETURNS integer AS '
    DECLARE
        argtable ALIAS for $1;
        resultobtype integer;
    BEGIN
        select into resultobtype obtypeid from obtype where upper(tablename) = upper(argtable) and isvirtual = false;
        if not FOUND then
           return NULL;
        else
           return resultobtype;
        end if;
    END;
' LANGUAGE plpgsql;
COMMENT on function getObTypeid(varchar) is 'This function returns the numeric typeid, given the name of the type';


\echo creating method for retrieving ob type name from typeid
CREATE FUNCTION getObTypename(integer) RETURNS varchar AS '
    DECLARE
        argtypeid ALIAS for $1;
        resultobtype varchar;
    BEGIN
        select into resultobtype lower(tablename) from obtype where obtypeid = argtypeid;
        if not FOUND then
           return NULL;
        else
           return resultobtype;
        end if;
    END;
' LANGUAGE plpgsql;

	COMMENT on function getObTypename(integer) is 'This function returns the name of a type , given its numeric typeid';


/*
* a lookup table for obstatus codes
*/
\echo creating obstatus
create table obstatus (
   statuscode integer primary key,
   statusname varchar(128) not null,
   statusdescription varchar(2048)
)  without oids;
\echo initialising obstatus
insert into obstatus(statuscode,statusname,statusdescription)
values(1,'ACTIVE','Default object status - active ');
insert into obstatus(statuscode,statusname,statusdescription)
values(0,'INACTIVE','Object is inactive and should be inaccessible');

COMMENT on table obstatus is 'This table will be used to support object versioning, with previous versions having inactive 	status and 	linked to current versions via a link table';





/*
* every object and relation in the database 
* has an entry in the ob table
*/
\echo creating ob_obidseq
create sequence ob_obidseq;

create function getNewObid() returns integer as '
   declare 
      mycur refcursor;
      newob integer;
   begin
      open mycur for 
      select nextval(''ob_obidseq'');
      fetch mycur into newob;
      return newob;
   end;
' LANGUAGE plpgsql;

  


\echo creating ob
/*
* note that the default obtype is that of an op - since all inserts
* of obs specify their type in a trigger, while ops do not - hence
* the default will correctly assign the obtype for those obs that 
* are ops
*/
create table ob (
   obid integer  DEFAULT nextval('ob_obidseq') primary key,
   obtypeid integer not null DEFAULT 0, 
   xreflsid varchar(2048) not null, /* the external lsid for the object , where this db just contains a copy */
   createddate date DEFAULT now(),
   createdBy varchar(256),
   lastUpdatedDate date,
   lastUpdatedBy varchar(256),
   checkedOut boolean default FALSE,
   checkedOutBy varchar(256),
   checkOutDate date,
   obkeywords varchar(4096),
   statuscode integer default 1,
   FOREIGN KEY ( obtypeid ) REFERENCES obtype,
   FOREIGN KEY ( statuscode ) REFERENCES obstatus
) without oids;

COMMENT on table ob is 'Most objects and relations are stored in tables that inherit from the ob table, and hence 
each instance is assigned a unique numeric name (obid)';

COMMENT on column ob.obid is 'obid is the principal internal unique identifier for each object. Note that obid is not portable - e.g. on 
import of the data to a new instance, obid may be different. obid is distinct from the postgres OID';

COMMENT on column ob.xreflsid is 'This is a pseudo lsid (life sciences identifier), for each object - a human readable unique name. Note that
the xreflsid is not in fact guaranteed to be unique, and would need to be processed by an lsid filter before being published as a true lsid';

/*
* this function is attached to each derived ob , so that 
* inserts may be made without having to remember to include the 
* obtype
*/
\echo creating setObType function
CREATE FUNCTION setObType() RETURNS trigger AS '
    BEGIN
        NEW.obtypeid = TG_ARGV[0];
        NEW.createddate = now();
        RETURN NEW;
    END;
' LANGUAGE plpgsql;


/*
* this function is attached to child tables, to set lastupdated date to now()
* (note that it does not work if attached to the ob base table)
*/
/* 4/2012 not yet set up 
\echo creating setUpdatedDate function
CREATE FUNCTION setUpdatedDate() RETURNS trigger AS '
    BEGIN
        NEW.lastupdateddate = now();
        RETURN NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER setUpdatedDate BEFORE UPDATE ON biosamplingfunction
    FOR EACH ROW EXECUTE PROCEDURE setUpdatedDate();
*/









\echo creating filterKeywords stored function 
CREATE FUNCTION filterKeywords() RETURNS trigger AS '
    BEGIN
        select lower(NEW.obkeywords) into NEW.obkeywords;
        return NEW;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER filterKeywords BEFORE INSERT OR UPDATE ON ob
    FOR EACH ROW EXECUTE PROCEDURE filterKeywords(obkeywords);


CREATE or replace FUNCTION getlsid(int4) RETURNS varchar AS '
DECLARE
   argobid alias for $1;
   resultlsid varchar(2048);
BEGIN
   resultlsid = null;

   select xreflsid into resultlsid from ob 
   where obid = argobid;

   return resultlsid;
END;
' LANGUAGE plpgsql;





  
/*
*
*********************************************************************
* Base op tables
*********************************************************************
*/


/*
* this table specifies which relationships
* a given object type must be involved withThe relation 
* to the obtype table is many to 1
*/
\echo creating obtypesignature
create table obtypesignature (
   obtypeid integer not null references obtype,
   mandatoryoptype integer references obtype(obtypeid)
) without oids;


/*
* currently there are few attributes specific for op
* objects - however all ops inherit from the 
* op table 
*/
\echo creating op
create table op(
   voptypeid integer references obtype(obtypeid))
   inherits(ob)  without oids;


CREATE FUNCTION checkvoptypeid() RETURNS trigger AS '
    BEGIN
        if NEW.voptypeid is not null then
           select obtypeid into NEW.voptypeid from obtype where obtypeid = NEW.voptypeid and isop ;
           if not FOUND then
              RAISE EXCEPTION ''key error - voptypeid to insert is not a valid op type '';
           end if;
        end if;

        return NEW;
    END;
' LANGUAGE plpgsql;


/*
* The optypesignature table records which types 
* of object a relationship involves - it is like the signature
* of a method call , i.e. the types of its arguments
*
* the argoptional column records if the arg is optional or not.
*
* the argnum argument specifies which 
*
*/
\echo creating optypesignature
create table optypesignature (
   obtypeid integer not null references obtype,
   argobtypeid integer not null references obtype(obtypeid),
   optablecolumn varchar(128)
) without oids;


/*
*****************************************************************************
* brdf table. This table contains a single record describing this
* brdf instance 
*****************************************************************************
*/
\echo creating brdfOb
create table brdfOb (
   databaseName varchar(256) not null,
   databaseDescription varchar(1024) ,
   check (obtypeid = 630) ,
   unique (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription, displayurl) 
values (630,'BRDF','brdfOb','BRDF Database','brdf.jpg');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON brdfOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(630);


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(631,'BRDF Setting','BRDFFact',TRUE,'BRDF Instance Settings',TRUE,'brdf.jpg');
\echo creating BRDFFact
create table BRDFFact (
   brdfOb integer not null references brdfOb(obid),
   factNamespace varchar(2048),
   attributeName varchar(2048),
   attributeValue varchar(256),
   check(obtypeid = 631) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 631,   obtypeid,   'brdfob' from obtype where  upper(tablename) = 'BRDFOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON brdfFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(631);


/*
example

insert into brdfob(xreflsid, databasename) values ('Nutrigenomics','Nutrigenomics');
insert into brdffact (xreflsid, brdfob, factnamespace, attributename, attributevalue)
select 
   xreflsid || '.search cache',
   obid,
   'SEARCH CACHE',
   'TRIGGERS',
   'ENABLED'
from 
   brdfob 
where
   xreflsid = 'Nutrigenomics';
*/



/*
*****************************************************************************
* create basic ontology structure. A single pair of tables provides
* all controlled vocabularies for the database. An ontologyOb table lists
* all the ontologies, and and ontologyFact table lists all the terms in the 
* ontology. Each term is a full object in the system, since there is 
* often a requirement to set up relationships between terms, and make lists
* of terms
*****************************************************************************
*/
\echo creating ontologyOb
create table ontologyOb (
   ontologyName varchar(256) not null,
   ontologyDescription varchar(1024) ,
   ontologyComment varchar(1024),
   check (obtypeid = 5) ,
   unique (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription, displayurl) 
values (5,'Ontology','ontologyOb','Ontology','dictionary_icon.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON ontologyOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(5);


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(380,'Ontology Fact','OntologyFact',FALSE,'Ontology Fact',TRUE,'dictionary_icon.gif');
\echo creating ontologyFact
create table ontologyFact (
   ontologyob integer not null references ontologyOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 380,   obtypeid,   'ontologyob' from obtype where  upper(tablename) = 'ONTOLOGYOB';



\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(10,'Ontology Term','OntologyTermFact',TRUE,'Ontology Term',TRUE,'dictionary_icon.gif');
\echo creating ontologyTermFact
create table ontologyTermFact (
   ontologyob integer not null references ontologyOb(obid),
   termName varchar(2048),
   termDescription varchar(2048),
   unitName varchar(256),
   termcode varchar(16),
   check(obtypeid = 10) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 10,   obtypeid,   'ontologyob' from obtype where  upper(tablename) = 'ONTOLOGYOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON ontologyTermFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(10);


\echo attaching  check  on any unit name specified
CREATE FUNCTION checkUnitName() RETURNS trigger AS '
    DECLARE
        units RECORD;
    BEGIN
        if NEW.unitName is not null then
           select into units  * from ontologytermfact where termname = NEW.unitName and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''UNITS'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid unit name '', NEW.unitName;
           else
              return NEW;
           end if;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkOntologyUnitName BEFORE INSERT OR UPDATE ON ontologyTermFact
    FOR EACH ROW EXECUTE PROCEDURE checkUnitName();


\echo setting up ontology for unit names
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('UNITS','This ontology provides standard names and descriptions for physical units of measurement, counting or ratio','ontology.UNITS');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','string' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','date' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','integer' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','grams' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','celsius' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','number' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','millilitres' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','microlitres' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','milligrams' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.UNITS.kilograms','kilograms' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.UNITS.millimetres','millimetres' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.UNITS.milliseconds','milliseconds' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','ratio' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','ng/ul' from ontologyOb where ontologyName = 'UNITS';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','float' from ontologyOb where ontologyName = 'UNITS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','integer' from ontologyOb where ontologyName = 'UNITS';
commit;



\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(350,'Ontology Term Attribute','OntologyTermFact2',FALSE,'Ontology Term Attribute',TRUE,'dictionary_icon.gif');
\echo creating ontologyTermFact2
create table ontologyTermFact2 (
   ontologyTermid integer not null references ontologyTermFact(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 350,   obtypeid,   'ontologyTermid' from obtype where  upper(tablename) = 'ONTOLOGYTERMFACT2';




/*
*****************************************************************************
* create basic op types : first the basic predicate optype which can link 
* any two objects - such as is-a and versioning. These do not inherit from the 
* op table as they do not have named instances. Because they do not inherit from the 
* base ob and op tables they need their own update signature columns.
*
* Note how the ontology is used - we store the actual term rather than 
* the termid, but use the ontology to validate the term. Storing termids 
* in the table - i.e. strictly normalised - is very inconvenient when 
* working with the data, hence we use this denormalised approach, but 
* include a trigger to maintain referential integrity, and control the vocab 
*****************************************************************************
*/




\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(15,'Predicate Link','predicateLink',FALSE, 'Basic predicate link used to establish relationships such as is-a and versioning, between objects',TRUE);
\echo creating predicateLink
/*
* base table for specific preficate link tables - see Known bugs above, re foreign keys and 
* inheritance
*/
create table predicatelink (
   subjectob integer not null ,
   objectob integer not null , 
   predicate varchar(64),
   predicatecomment varchar(256),
   check(obtypeid = 15),
   unique(obid)  )
   inherits(op)
   without oids ;
CREATE TRIGGER setObType BEFORE INSERT ON predicateLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(15);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 15,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'OB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 15,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'OB';


\echo setting up ontology for predicate types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('PREDICATE_TYPES','This ontology provides standard predicate type names for the predicate column of the predicatelink table','ontology.PREDICATE_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','IS-A' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','PREVIOUS-VERSION' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','ASSOCIATED-WITH' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','PRODUCES' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.PREDICATE_TYPES.PROVIDES_NOMENCLATURE','PROVIDES_NOMENCLATURE' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.GO_ASSOCIATION','GO_ASSOCIATION' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.ARRAYSPOT-GENE','ARRAYSPOT-GENE' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.DEPRECATED_ARRAYSPOT-GENE','DEPRECATED_ARRAYSPOT-GENE' from ontologyOb where ontologyName = 'PREDICATE_TYPES';




insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.ARRAYSPOT-SEQUENCE','ARRAYSPOT-SEQUENCE' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'PREDICATE_TYPES.AFFYTARGET-SEQUENCE','AFFYTARGET-SEQUENCE','A link between a sequence and the subsequence selected as a target for Affymetrix probe design' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'PREDICATE_TYPES.OLIGO-SEQUENCE','OLIGO-SEQUENCE','A link between a sequence and an oligo subsequence' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'PREDICATE_TYPES.AFFYPROBE-AFFYTARGET','AFFYPROBE-AFFYTARGET','A link between the target of an affy probset , and one of the probes in the probeset' from ontologyOb where ontologyName = 'PREDICATE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'PREDICATE_TYPES.AFFYPROBESET-AFFYTARGET','AFFYPROBESET-AFFYTARGET','A link between the target of an affy probset , and the probeset itself' from ontologyOb where ontologyName = 'PREDICATE_TYPES';



insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'PREDICATE_TYPES.AFFYPROBE-SEQUENCE','AFFYPROBE-SEQUENCE','A direct link between the reference sequence (e.g. consensus) for an affy probset , and one of the probes in the probeset (skipping the intermediate target)' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'PREDICATE_TYPES.ALIQUOT-OF','ALIQUOT-OF','A link from a biosample record (subject), to the parent biosample (object) of which the subject is an aliquot from' from ontologyob where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.AFFYPROBE-ARRAYPROBESET','AFFYPROBE-ARRAYPROBESET' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.FORWARD-REVERSE READ PAIR','FORWARD-REVERSE READ PAIR' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.GENOMIC SEQUENCE-TRANSCRIPT SEQUENCE','GENOMIC SEQUENCE-TRANSCRIPT SEQUENCE' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.Foreign Key Reference To','Foreign Key Reference To' from ontologyOb where ontologyName = 'PREDICATE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PREDICATE_TYPES.Report Yields Output','Report Yields Output' from ontologyOb where ontologyName = 'PREDICATE_TYPES';



commit;


\echo attaching ontology check 
CREATE FUNCTION checkPredicateOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.predicate and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''PREDICATE_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid predicate type '', NEW.predicate;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkOntology BEFORE INSERT OR UPDATE ON predicateLink
    FOR EACH ROW EXECUTE PROCEDURE checkPredicateOntology();


\echo creating checkPredicateKeys (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkPredicateKeys() RETURNS trigger AS '
    BEGIN
        select a.obid , b.obid into NEW.subjectob,NEW.objectob from ob a, ob b  where a.obid = NEW.subjectob and b.obid = NEW.objectob;
        if not FOUND then
           RAISE EXCEPTION ''key error - subject or object obid not found'';
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkPredicateKeys BEFORE INSERT OR UPDATE ON predicatelink
    FOR EACH ROW EXECUTE PROCEDURE checkPredicateKeys();


/*
* this table provides storage for general additional attributes
* of a predicatelink
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(370,'Predicate Link Fact','predicateLinkFact',FALSE,'Predicate Link Fact',TRUE);
\echo creating predicateLinkFact
create table predicateLinkFact (
   predicateLink integer not null references predicateLink(obid),
   factNameSpace varchar(256),
   attributeDate date,
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 370,   obtypeid,   'predicateLink' from obtype where  upper(tablename) = 'PREDICATELINK';


CREATE OR REPLACE FUNCTION getpredicatelinktarget(int4, "varchar")
  RETURNS "int4" AS
'
DECLARE
    argsubject ALIAS for $1;
    argpredicate ALIAS for $2;
    resultobid int4;
BEGIN
    resultobid := null;

    select objectob into resultobid from 
    predicatelink where predicate = argpredicate and 
    subjectob = argsubject;

    return resultobid;

END;
'
  LANGUAGE 'plpgsql' VOLATILE;


CREATE OR REPLACE FUNCTION getpredicatelinksource(int4, "varchar")
  RETURNS "int4" AS
'
DECLARE
    argobject ALIAS for $1;
    argpredicate ALIAS for $2;
    resultobid int4;
BEGIN
    resultobid := null;

    select subjectob into resultobid from 
    predicatelink where predicate = argpredicate and 
    objectob = argobject;

    return resultobid;

END;
'
  LANGUAGE 'plpgsql' VOLATILE;







/*
*  this function returns (e.g.) a google scholar link , using gene aliases obtained from nomenclature links,
* or other links based on gene symbols
* Example : 
* http://scholar.google.com/scholar?btnG=Search+Scholar&as_occt=title&as_subj=bio&hl=en&safe=off&as_oq=%22DAG2%22+%2259kDa%22+%22Sgca%22+%22A2%22+%22LGMD2D%22+%22ADL%22+%22DMDA2%22
*/
CREATE OR REPLACE FUNCTION getGeneSymbolsLink(int4, "varchar") RETURNS "varchar" AS
'
   DECLARE
      symbolcursor refcursor;
      geneobid ALIAS for $1;
      linktype ALIAS for $2;
      genesymbol varchar;
      resultlink varchar;
      myquote varchar;
      myplus varchar;
   BEGIN   
      myquote := ''%22'';
      myplus := '''';
      open symbolcursor for
        select otf.termname
        from
        predicatelink p join ontologytermfact otf on
        p.subjectob = geneobid and p.predicate = ''PROVIDES_NOMENCLATURE'' and
        p.predicatecomment like ''Link to aliases%'' and
        otf.ontologyob = p.objectob;

      fetch symbolcursor into genesymbol;
      if linktype = ''google scholar'' then
         resultlink := ''http://scholar.google.com/scholar?btnG=Search+Scholar&as_occt=title&as_subj=bio&hl=en&safe=off&as_oq='';
         if not FOUND then
            resultlink = ''emptylink'';
         else
	    while FOUND loop
                resultlink := resultlink || myplus || myquote || genesymbol || myquote ;
                myplus := ''+'';
                fetch symbolcursor into genesymbol;
            end loop;
         end if;
      elsif linktype = ''or list'' then
         resultlink := '''';
         myquote := '''';
         if not FOUND then
            resultlink = '''';
         else
	    while FOUND loop
                resultlink := resultlink || myplus || myquote || genesymbol || myquote ;
                myplus := '' OR '';
                fetch symbolcursor into genesymbol;
            end loop;
         end if;
      end if;
    
      close symbolcursor;

      return resultlink;
    END;
'
LANGUAGE 'plpgsql' VOLATILE;

/*
* example code to set up links

- this code generates code, as the single bulk import is very slow
select 
'insert into uriob(xreflsid,uristring,uritype,uricomment) values ('||
'   getGeneSymbolsLink(' || obid || ',''google scholar''),' ||
'   ''scholar dummy'',' ||
'   ''URL'',' ||
'   ''google scholar link for '|| xreflsid || ''');'
from geneticob where xreflsid like 'geneticob.HGID%';

(run this then...)

delete from uriob where xreflsid = 'emptylink';
update uriob set uristring = xreflsid where uristring = 'scholar dummy';

--
--this too slow therefore we generate code as below
--
insert into urilink (
 uriob ,
 ob    ,
 displaystring  ,
 iconpath     ,
 uricomment   ,
 iconattributes  
)
select 
   u.obid,
   g.obid,
   getGeneSymbolsLink(g.obid, 'or list'),
   'newGoogleScholar_0206.gif',
   'link to google scholar for ' || g.xreflsid ,
   '{"height" : 28, "width" : 80}'
from 
   geneticob g join uriob u on 
   u.uricomment = 'google scholar link for ' || g.xreflsid;


select
'insert into urilink( uriob ,ob    , displaystring  ,iconpath     , uricomment   , iconattributes  )'||
'values('||u.obid||','||g.obid||',getGeneSymbolsLink('||g.obid||',''or list''),'||
'''newGoogleScholar_0206.gif'',''link to google scholar for '||g.xreflsid||
''',''{"height" : 28, "width" : 80}'');'
from 
   geneticob g join uriob u on 
   u.uricomment = 'google scholar link for ' || g.xreflsid;
   


update urilink set 
iconpath = 'entrez_gene.gif',
iconattributes = '{"height" : 30,"width" : 150}'
where
displaystring like 'Link to Entrez Gene%';

update urilink set 
iconpath = 'homologene_banner2.gif',
iconattributes = '{"height" : 30,"width" : 150}'
where
displaystring like 'Link to NCBI Homologene Record%';

update urilink set 
iconpath = 'entrez_gene.gif',
iconattributes = '{"height" : 30,"width" : 150}'
where
displaystring like 'Link to Entrez geneid%';


Link to NCBI Homologene Record

*/




   


/*
********************************************************************
* basic list and listMembershipLink - this can contain any object , including other lists  
********************************************************************
*/
\echo setting up ontology for list types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('LIST_TYPES','This ontology provides standard names for types of list','ontology.LIST_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','SEARCH_RESULT' from ontologyOb where ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','USER_PROJECT_LIST' from ontologyOb where ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.DATASOURCE_UPLOAD_LIST','DATASOURCE_UPLOAD_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.USER_ROLE_LIST','USER_ROLE_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.EXPERIMENT_RESOURCE_LIST','EXPERIMENT_RESOURCE_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.MICROARRAY_SERIES_LIST','MICROARRAY_SERIES_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.SNP_LIST','SNP_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.TEMP_LIST','TEMP_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.BIOSEQUENCE_LIST','BIOSEQUENCE_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.BIOSUBJECT_LIST','BIOSUBJECT_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.META LIST','META LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.DATASOURCE_LIST','DATASOURCE_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LIST_TYPES.GENE_LIST','GENE_LIST' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'LIST_TYPES.TEMPWEAKLIST','TEMPWEAKLIST' , 'A temporary list which may not necessarily have obid' from ontologyOb where  ontologyName = 'LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'LIST_TYPES.REPORT_QUEUE_LIST','REPORT_QUEUE_LIST' , 'a list that implements a report queue' from ontologyOb where  ontologyName = 'LIST_TYPES';


commit;


\echo creating obList
create table Oblist (
   listName varchar(256) not null,
   listType varchar(128),
   listDefinition text,
   bookMark integer,
   maxMembership integer,
   currentMembership integer default 0,
   listComment varchar(1024),
   displayURL varchar(2048) default 'ob.gif',
   membershipvisibility varchar(32) default 'public',
   check (obtypeid = 20) ,
   unique (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription, displayurl) 
values (20,'List','Oblist','List','search.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON ObList
    FOR EACH ROW EXECUTE PROCEDURE setObType(20);

\echo attaching ontology check 
CREATE FUNCTION checkListOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.listType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''LIST_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid list type '', NEW.listType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkOntology BEFORE INSERT OR UPDATE ON obList
    FOR EACH ROW EXECUTE PROCEDURE checkListOntology();

\echo creating listorderseq sequence
create sequence listorderseq;

\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(25,'listMembershipLink','listMembershipLink',FALSE, 'ListMembershipLink',TRUE);
\echo creating listMembershipLink
create table listMembershipLink (
   oblist integer not null references obList(obid),
   ob integer not null,  
   obxreflsid varchar(2048),
   listorder integer DEFAULT nextval('listorderseq') ,
   createddate date DEFAULT now(),
   createdBy varchar(256),
   membershipcomment text,
   voptypeid integer)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 25,   obtypeid,   'oblist' from obtype where  upper(tablename) = 'OBLIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 25,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';


\echo creating checkObListKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkObListKey() RETURNS trigger AS '
    BEGIN
        select obid into NEW.ob from ob where obid = NEW.ob;
        if not FOUND then
           RAISE EXCEPTION ''key error - obid not found'';
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkObListKey BEFORE INSERT OR UPDATE ON listMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE checkObListKey();

\echo creating trigger to validate voptypeid
create trigger checklmvoptypeid before insert or update on listmembershiplink
for each row execute procedure checkvoptypeid();



/*
* a named link function , for applications where we need
* to qualify the inclusion. 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(645,'Named List Membership','namedListMembershipLink',TRUE, 'NamedListMembershipLink',TRUE);
\echo creating namedListMembershipLink
create table namedListMembershipLink (
   oblist integer not null references obList(obid),
   ob integer not null,
   membershipComment text,  
   listorder integer,
   check(obtypeid = 645) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 645,   obtypeid,   'oblist' from obtype where  upper(tablename) = 'OBLIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 645,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';
CREATE TRIGGER setObType BEFORE INSERT ON namedListMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(645);
CREATE TRIGGER checkObNamedListKey BEFORE INSERT OR UPDATE ON namedListMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE checkObListKey();


/*
* this table provides storage for general additional attributes
* of a list 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(360,'List Fact','oblistfact',FALSE,'List Fact',TRUE,'ob.gif');
\echo creating oblistFact
create table oblistfact (
   listOb integer not null references obList(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 360,   obtypeid,   'listOb' from obtype where  upper(tablename) = 'OBLIST';


/*
* this table provides storage of weak listmembership - i.e. without an obid
*/
\echo initialising obtype
create sequence lmf_factidseq;
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(565,'listMembershipfact','listMembershipfact',FALSE, 'ListMembershipFact',TRUE);
\echo creating listMembershipFact
create table listMembershipFact (
   factid integer  DEFAULT nextval('lmf_factidseq') primary key,   
   oblist integer not null references obList(obid),
   memberid varchar(2048),
   listorder integer DEFAULT nextval('listorderseq') ,
   createddate date DEFAULT now(),
   createdBy varchar(256),
   membershipcomment text,
   voptypeid integer)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 565,   obtypeid,   'oblist' from obtype where  upper(tablename) = 'OBLIST';


\echo creating trigger to validate voptypeid
create trigger checklfvoptypeid before insert or update on listmembershipfact
for each row execute procedure checkvoptypeid();


/*
* find out whether an object is in a list whsoe definition includes
* a given term
*/
CREATE OR REPLACE FUNCTION inListWithTerm(integer, varchar)
  RETURNS integer  AS
$BODY$  

DECLARE
   mycur refcursor;
   myob alias for $1;
   myterm alias for $2;
   myresult integer;
BEGIN  
   myresult := 0;

   open mycur for 
      select 1 from oblist where upper(listdefinition) like '%' ||upper(myterm)||'%'
      and exists (select 1 from listmembershiplink where oblist = oblist.obid and ob = myob);

   fetch mycur into myresult;

   if not found then
      myresult := 0;
   else 
      myresult := 1;
   end if;
   
   close mycur;

   return myresult;
END
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;


/*
* this table supports extension to a list representing a gene expression series
* for experiment series type, see ontology.GENEEXPRESSIONEXPERIMENTTYPE_ONTOLOGY (only entry is Expression profiling by array)
*/
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(640,'Gene Expression Experiment Series Details','GeneExpressionExperimentSeriesFact',TRUE,'Gene Expression Experiment Series Details',TRUE,'ob.gif');


insert into ontologyob(ontologyName,   xreflsid, ontologyDescription )
values('Gene Expression Series Type','Ontology.Gene Expression Series Type','This ontology lists gene expression series types as supported by GEO');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'Ontology.Gene Expression Series Type.Expression profiling by array','Expression  profiling by array' from ontologyOb where ontologyName = 'Gene Expression Series Type';

create sequence geesf_factidseq;
\echo creating GeneExpressionExperimentSeriesFact
create table GeneExpressionExperimentSeriesFact (
   factid integer  DEFAULT nextval('geesf_factidseq') primary key, 
   listOb integer not null references obList(obid),
   experimentTitle varchar(4096),
   experimentSeriesType varchar(2048),
   experimentPlatforms varchar(4096),
   experimentSummary text,
   experimentDesign text,
   contributors text,
   check (obtypeid = 640) ,
   unique (obid) )
   inherits(op)
   without oids ;
\echo initialising obtype
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 640,   obtypeid,   'listOb' from obtype where  upper(tablename) = 'OBLIST';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON GeneExpressionExperimentSeriesFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(640);



/*
********************************************************************
* basic URIOb and URILink - a URI can be attached to any Ob   
********************************************************************
*/


\echo creating URIOb
create table URIOb (
   URIString varchar(2048) not null,
   URIType varchar(256),
   URIComment varchar(1024),
   visibility varchar(32) DEFAULT 'public',
   check (obtypeid = 30) ,
   unique (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription, displayurl) 
values (30,'URI','URIOb','URI','hyperlink.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON URIOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(30);


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(35,'URILink','URILink',FALSE, 'URILink',TRUE);
\echo creating URILink
create table URILink (
   uriob integer not null references uriOb(obid),
   ob integer not null,  
   displayString varchar(2048),
   displayorder integer,
   iconpath varchar(512),
   iconattributes varchar(2048),
   createddate date DEFAULT now(),
   createdBy varchar(256),
   lastUpdatedDate date,
   lastUpdatedBy varchar(256),   
   uriComment varchar(256),
   linktype varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 35,   obtypeid,   'uriob' from obtype where  upper(tablename) = 'URIOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 35,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';


\echo creating checkURILinkKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkURILinkKey() RETURNS trigger AS '
    BEGIN
        select obid into NEW.ob from ob where obid = NEW.ob;
        if not FOUND then
           RAISE EXCEPTION ''key error - obid not found'';
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkURILinkKey BEFORE INSERT OR UPDATE ON URILink
    FOR EACH ROW EXECUTE PROCEDURE checkURILinkKey();



create or replace function addURL(integer, text, text, text, boolean) returns integer as
'
   declare 
      urlon alias for $1;
      urltext alias for $2;
      urladdress alias for $3;
      author alias for $4;
      reuse alias for $5;
      mycur refcursor;
      existingurl integer;
      junk integer;
   begin


      if reuse then
         /* check if we can re-use a link */
         existingurl := null;
         open mycur for 
         select obid from uriob where uristring = urladdress;
         fetch mycur into existingurl;
         close mycur;
 
         if existingurl is null then
            existingurl := getNewObid();
            insert into uriob(obid, xreflsid, uristring, uritype)
            values (existingurl, urladdress, urladdress,''URL'');
         end if;

         /* check if this object already commented with this comment */
         select ob into junk from urilink where uriob = existingurl and ob = urlon;
         if not FOUND then
            insert into urilink(ob,uriob,displaystring,createdby) values(urlon, existingurl,urltext,author);
         end if;

         return existingurl;
      else
         existingurl := getNewObid();
         insert into uriob(obid, xreflsid, uristring, uritype)
         values (existingurl, urladdress, urladdress,''URL'');
         insert into urilink(ob,uriob,displaystring,createdby) values(urlon, existingurl,urltext,author);
      end if;

      return existingurl;
      
   end;
'
language 'plpgsql' volatile;




/*
***************************************************************
* set up GO ontologies
***************************************************************
*/
/*
set up GO , one for each of the three GO divisions
*/
insert into ontologyob(ontologyName,   xreflsid, ontologyDescription )
values('Gene Ontology (GO) : Molecular Function','Ontology.GO.Molecular Function','This ontology mirrors selected gene ontology terms related to molecular function');
insert into uriob(xreflsid,uristring,uritype,uricomment) 
values('Ontology.GO.Molecular Function.homeurl',
'http://www.geneontology.org/GO.doc.shtml#molecular_function','URL',
'Gene Ontology site - molecular function');
insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   o.obid,
   'GOthumbnail.gif',
   '(54,50)',
   'system'
from 
   uriob u join ontologyob o on 
   u.xreflsid = 'Ontology.GO.Molecular Function.homeurl' and
   o.xreflsid = 'Ontology.GO.Molecular Function';

insert into uriob(xreflsid,uristring,uritype,uricomment) 
values('Ontology.GO.Molecular Function.retrieveaccessionurl',
'http://www.godatabase.org/cgi-bin/amigo/go.cgi?view=assoc&search_constraint=terms&query=%s','URL',
'Gene Ontology site - URL for retrieving term and associations');
insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   o.obid,
   'system'
from 
   uriob u join ontologyob o on 
   u.xreflsid = 'Ontology.GO.Molecular Function.retrieveaccessionurl' and
   o.xreflsid = 'Ontology.GO.Molecular Function';





insert into ontologyob(ontologyName,   xreflsid, ontologyDescription )
values('Gene Ontology (GO) : Biological Process','Ontology.GO.Biological Process','This ontology mirrors selected gene ontology terms related to biological process');
insert into uriob(xreflsid,uristring,uritype,uricomment) 
values('Ontology.GO.Biological Process.homeurl',
'http://www.geneontology.org/GO.doc.shtml#biological_process','URL',
'Gene Ontology site - biological process');
insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   o.obid,
   'GOthumbnail.gif',
   '(54,50)',
   'system'
from 
   uriob u join ontologyob o on 
   u.xreflsid = 'Ontology.GO.Biological Process.homeurl' and
   o.xreflsid = 'Ontology.GO.Biological Process';

insert into uriob(xreflsid,uristring,uritype,uricomment) 
values('Ontology.GO.Biological Process.retrieveaccessionurl',
'http://www.godatabase.org/cgi-bin/amigo/go.cgi?view=assoc&search_constraint=terms&query=%s','URL',
'Gene Ontology site - URL for retrieving term and associations');
insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   o.obid,
   'system'
from 
   uriob u join ontologyob o on 
   u.xreflsid = 'Ontology.GO.Biological Process.retrieveaccessionurl' and
   o.xreflsid = 'Ontology.GO.Biological Process';




insert into ontologyob(ontologyName,   xreflsid, ontologyDescription )
values('Gene Ontology (GO) : Cellular Component','Ontology.GO.Cellular Component','This ontology mirrors selected gene ontology terms related to cellular component');
insert into uriob(xreflsid,uristring,uritype,uricomment) 
values('Ontology.GO.Cellular Component.homeurl',
'http://www.geneontology.org/GO.doc.shtml#cellular_component','URL',
'Gene Ontology site - cellular_component');
insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   o.obid,
   'GOthumbnail.gif',
   '(54,50)',
   'system'
from 
   uriob u join ontologyob o on 
   u.xreflsid = 'Ontology.GO.Cellular Component.homeurl' and
   o.xreflsid = 'Ontology.GO.Cellular Component';

insert into uriob(xreflsid,uristring,uritype,uricomment) 
values('Ontology.GO.Cellular Component.retrieveaccessionurl',
'http://www.godatabase.org/cgi-bin/amigo/go.cgi?view=assoc&search_constraint=terms&query=%s','URL',
'Gene Ontology site - URL for retrieving term and associations');
insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   o.obid,
   'system'
from 
   uriob u join ontologyob o on 
   u.xreflsid = 'Ontology.GO.Cellular Component.retrieveaccessionurl' and
   o.xreflsid = 'Ontology.GO.Cellular Component';





/*
********************************************************************
* basic CommentOb and CommentLink - a comment can be attached to any Ob   
********************************************************************
*/

\echo creating CommentOb
create table CommentOb (
   CommentString text not null,
   CommentType varchar(1024),
   visibility varchar(32) DEFAULT 'public',
   commentedOb integer,
   voptypeid integer,
   check (obtypeid = 40) ,
   primary key (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription, displayurl) 
values (40,'Comment','CommentOb','Comment','comment.jpg');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON CommentOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(40);


\echo creating checkCommentedObKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkCommentedObKey() RETURNS trigger AS '
    BEGIN
        if NEW.commentedOb is not null then
           select obid into NEW.commentedOb from ob where obid = NEW.commentedOb;
           if not FOUND then
              RAISE EXCEPTION ''key error - commentedOb not found'';
           end if;
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkCommentedObKey BEFORE INSERT OR UPDATE ON CommentOb
    FOR EACH ROW EXECUTE PROCEDURE checkCommentedObKey();


/* 
*  base table for comment links to specific types - see "Known bugs" above.
*  - specific comment links inherit from this table
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(45,'CommentLink','CommentLink',FALSE, 'CommentLink',TRUE);
\echo creating CommentLink
create table commentLink (
   commentob integer not null references commentOb(obid),
   ob integer not null,  
   commentDate date DEFAULT now(),
   commentBy varchar(256),
   style_bgcolour varchar(64) default '#99EE99')
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 45,   obtypeid,   'commentob' from obtype where  upper(tablename) = 'COMMENTOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 45,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';

\echo creating checkCommentLinkKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkCommentLinkKey() RETURNS trigger AS '
    BEGIN
        select obid into NEW.ob from ob where obid = NEW.ob;
        if not FOUND then
           RAISE EXCEPTION ''key error - obid not found'';
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkCommentLinkKey BEFORE INSERT OR UPDATE ON CommentLink
    FOR EACH ROW EXECUTE PROCEDURE checkCommentLinkKey();


/*
useful aggregate function for selecting all comments
relating to an object in a single line
*/
create function comment_concat (text, text) returns "text" as
'
   declare
      arg1 alias for $1;
      arg2 alias for $2;
   begin
      return arg1||''\n====================Begin Comment====================\n''||arg2 || ''\n====================End Comment====================\n'';
   end;
'
language 'plpgsql' volatile;



create or replace function comma_concat (text, text) returns "text" as
'
   declare
      arg1 alias for $1;
      arg2 alias for $2;
   begin
      if length(arg1) > 0 then
         return arg1||'',''||arg2 ;
      else
         return arg1||arg2 ;
      end if;
   end;
'
language 'plpgsql' volatile;


create or replace function newline_concat (text, text) returns "text" as
'
   declare
      arg1 alias for $1;
      arg2 alias for $2;
   begin
      if length(arg1) > 0 then
         return arg1||''\n''||arg2 ;
      else
         return arg1||arg2 ;
      end if;
   end;
'
language 'plpgsql' volatile;


create or replace function semicolon_concat (text, text) returns "text" as
'
   declare
      arg1 alias for $1;
      arg2 alias for $2;
   begin
      if length(arg1) > 0 then
         return arg1||'';''||arg2 ;
      else
         return arg1||arg2 ;
      end if;
   end;
'
language 'plpgsql' volatile;



create aggregate agg_comment_concat (
    sfunc = comment_concat,
    stype = text,
    basetype = text,
    stype = text,
    initcond = ''
);


create aggregate agg_commentstring_concat (
    sfunc = semicolon_concat,
    stype = text,
    basetype = text,
    stype = text,
    initcond = ''
);


create aggregate agg_comma_concat (
    sfunc = comma_concat,
    stype = text,
    basetype = text,
    stype = text,
    initcond = ''
);

create aggregate agg_newline_concat (
    sfunc = newline_concat,
    stype = text,
    basetype = text,
    stype = text,
    initcond = ''
);


/*
* this returns a formatted aggregate of comments
*/
create or replace function getComments(integer) returns "text" as
'
   declare 
      myob alias for $1;
      result text;
   begin
      select 
         agg_comment_concat(c.commentstring) into result 
      from
         commentlink cl join commentob c on
         c.obid = cl.commentob
      where
         cl.ob = myob;
      return result;
   end;
'
language 'plpgsql' volatile;


/* 
* this returns comments as a single string separated by 
* semicolons
*/
create or replace function getCommentString(integer) returns "text" as
'
   declare 
      myob alias for $1;
      result text;
   begin
      select 
         agg_commentstring_concat(c.commentstring) into result 
      from
         commentlink cl join commentob c on
         c.obid = cl.commentob
      where
         cl.ob = myob;
      return result;
   end;
'
language 'plpgsql' volatile;



create or replace function getDescriptiveListMembership(integer) returns "text" as
'
   declare 
      myob alias for $1;
      result text;
   begin
      select 
         --agg_comma_concat(split_part(l.listdefinition,'':'',1)) into result 
         agg_comma_concat(l.listdefinition) into result 
      from
         listmembershiplink lml join oblist l on
         l.obid = lml.oblist
      where
         lml.ob = myob;
      return result;
   end;
'
language 'plpgsql' volatile;

      

/*
* this function adds a comment to an 
* object , checking that there is no other comment in the 
* system with the same text that could be used.
* first arg : the obid of the object
* second arg : the comment text 
* third arg : the author
*/

create or replace function addComment(integer, text, text) returns integer as
'
   declare
      existingComment integer;   
   begin
      existingComment = addComment($1,$2,$3,true);
      return existingComment;
   end;
'
language 'plpgsql' volatile;





create or replace function addComment(integer, text, text, boolean) returns integer as
'
   declare 
      commenton alias for $1;
      commenttext alias for $2;
      author alias for $3;
      reuse alias for $4;
      mycur refcursor;
      existingcomment integer;
      commentonlsid varchar(2048);
      junk integer;
   begin

      /* get the lsid of the commented object */
      select xreflsid||'':comment'' into commentonlsid from ob where obid = commenton;

      if reuse then
         /* check if we can re-use a comment */
         existingcomment := null;
         open mycur for 
         select obid from commentob where commentstring = commenttext;
         fetch mycur into existingcomment;
         close mycur;
 
         if existingcomment is null then
            existingcomment := getNewObid();
            insert into commentob(obid, xreflsid, commentstring)
            values (existingcomment, commentonlsid, commenttext);
         end if;

         /* check if this object already commented with this comment */
         select ob into junk from commentlink where commentob = existingcomment and ob = commenton;
         if not FOUND then
            insert into commentlink(ob,commentob,commentby) values(commenton, existingcomment,author);
         end if;

         return existingcomment;
      else
         existingcomment := getNewObid();
         insert into commentob(obid, xreflsid, commentstring)
         values (existingcomment, commentonlsid, commenttext);
         insert into commentlink(ob,commentob,commentby) values(commenton, existingcomment,author);
      end if;

      return existingcomment;
      
   end;
'
language 'plpgsql' volatile;




create or replace function testComment(integer, text) returns varchar as
'
   declare 
      commenton alias for $1;
      commenttext alias for $2;
      mycur refcursor;
      existingcomment integer;
      commentonlsid varchar(2048);
   begin

      /* get the lsid of the commented object */
      select xreflsid||'':comment'' into commentonlsid from ob where obid = commenton;
      return commentonlsid ;
   end;
'
language 'plpgsql' volatile;
      
      




/*
*****************************************
* basic staff ob and links  
*****************************************
*/
\echo creating staffOb
create table staffOb (
   loginName varchar(64) not null,
   fullName  varchar(128),
   emailaddress  varchar(256),
   mobile varchar(64),
   phone varchar(64),
   title varchar(32),
   staffComment varchar(1024),
   check (obtypeid = 50) ,
   unique (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription) 
values (50,'Staff','staffOb','Staff');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON staffOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(50);


\echo setting up ontology for predicate types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('ACCESS_TYPES','This ontology provides standard names for the access types','ontology.ACCESS_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','READ' from ontologyOb where ontologyName = 'ACCESS_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','INSERT' from ontologyOb where ontologyName = 'ACCESS_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','UPDATE' from ontologyOb where ontologyName = 'ACCESS_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','DELETE' from ontologyOb where ontologyName = 'ACCESS_TYPES';

commit;



/*
* this table is intended to provide a means for storing an access policy of some sort for 
* a given object / record in the database, to support a fine grained access control 
* mechamism, by relating an object to be controlled , to an entry in the staff table
*
* see also accessFact which provides an alternative data structure with accessTypes and 
* policies attached to the object to be controlled, but not linked to the staff table.
*
* This table has not been used to date (2009).
*
 alter table accessfact add accessPolicy text;
* 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(55,'Access','accessLink',FALSE,'Access',TRUE);
\echo creating accessLink
create table accessLink (
   ob integer not null references ob(obid),  
   staffOb integer references staffOb(obid),
   oblist integer references oblist(obid),
   accessType varchar(64),
   accessComment text,
   accessPolicy text,
   createddate date DEFAULT now(),
   createdBy varchar(256),
   lastUpdatedDate date,
   lastUpdatedBy varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 55,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 55,   obtypeid,   'staffOb' from obtype where  upper(tablename) = 'STAFFOB';


\echo creating checkAccessLinkKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkAccessLinkKey() RETURNS trigger AS '
    BEGIN
        select obid into NEW.ob from ob where obid = NEW.ob;
        if not FOUND then
           RAISE EXCEPTION ''key error - obid not found'';
        end if;

        --the list should have type USR ROLE
        if oblist is not null then
        end if;



        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkAccessLinkKey BEFORE INSERT OR UPDATE ON AccessLink
    FOR EACH ROW EXECUTE PROCEDURE checkAccessLinkKey();


\echo attaching ontology check 
CREATE FUNCTION checkAccessOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologyTermFact where termname = NEW.accessType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''ACCESS_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid access type '', NEW.accessType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkAccessOntology BEFORE INSERT OR UPDATE ON accessLink
    FOR EACH ROW EXECUTE PROCEDURE checkAccessOntology();



\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(340,'Staff Details','staffFact',FALSE,'Staff Details',TRUE);
\echo creating staffFact
create table staffFact (
   staffOb integer not null references staffOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 340,   obtypeid,   'staffOb' from obtype where  upper(tablename) = 'STAFFOB';



/*
* this table is intended to provide a means for storing an access policy of some sort for 
* a given object / record in the database, to support a fine grained access control 
* mechamism. For example, one might store (in the accessPolicy field) , a dictionary 
* keyed by access type (read / write) etc, with values being an array of usernames or user roles
* assigned to that access type. This would allow fine-grained access control to individual records
* to be dfined.
*
* see also accessLink which provides an alternative data structure with accessTypes and 
* policies related directly to entries in the staff table
*
* This table has not been used to date (2009) 
* 
*/

\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(56,'Access Fact','AccessFact',FALSE,'Access Fact',TRUE);
\echo creating accessFact
create table accessFact (
   ob integer not null references ob(obid),
   accessType varchar(64),
   accessComment text,
   accessPolicy text,
   createddate date DEFAULT now(),
   createdBy varchar(256),
   lastUpdatedDate date,
   lastUpdatedBy varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 56,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';

CREATE TRIGGER checkAccessOntology BEFORE INSERT OR UPDATE ON accessFact
    FOR EACH ROW EXECUTE PROCEDURE checkAccessOntology();




/*
*****************************************
* basic literature reference ob and links  
*****************************************
*/
\echo creating literatureReferenceOb
create table literatureReferenceOb (
   journalname varchar(2048) not null,
   volumename varchar(16),
   volnumber integer,
   voldate date,
   papertitle varchar(2048),
   authors varchar(4096),
   abstract text,
   ourcomments text ,
   check (obtypeid = 60) ,
   unique (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription) 
values (60,'Literature Reference','literatureReferenceOb','Literature Reference');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON literatureReferenceOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(60);



\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(65,'Literature Reference Link','literatureReferenceLink',FALSE,'Literature Reference Link',TRUE);
\echo creating literatureReferenceLink
create table literatureReferenceLink (
   ob integer not null,
   literatureReferenceOb integer not null references literatureReferenceOb(obid),
   linkcomment text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 65,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 65,   obtypeid,   'literatureReferenceOb' from obtype where  upper(tablename) = 'LITERATUREREFERENCEOB';


\echo creating checkLiteratureReferenceLinkKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkLiteratureReferenceLinkKey() RETURNS trigger AS '
    BEGIN
        select obid into NEW.ob from ob where obid = NEW.ob;
        if not FOUND then
           RAISE EXCEPTION ''key error - obid not found'';
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkLiteratureReferenceLinkKey BEFORE INSERT OR UPDATE ON LiteratureReferenceLink
    FOR EACH ROW EXECUTE PROCEDURE checkLiteratureReferenceLinkKey();





/*
*******************************************************************************
* basic labResource, labResorceFact and labResourceList tables
* This table is used to store details of primers, vectors and other reagents
* The Fact table uses key-value columns to store arbitrary attributes of the resource
*******************************************************************************
*/


/*
* changes 7/2011 to support reference Gel labresource types : add new term to lab resource ontology. 
* add resourceSpecies -e.g. for microarrays, reference gels  - applicable to most (but not all)
* 'omics lab resources
*/

create table labResourceOb (
   resourceName varchar(1024),
   resourceType varchar(256) not null,
   resourceSequence text,
   resourceSpecies varchar(128),
   forwardPrimerSequence text,
   reversePrimerSequence text,
   resourceSeqLength int,
   resourceDate date,
   resourceDescription text,
   supplier varchar(1024),
   check (obtypeid = 70) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,   displayName,   tablename ,   obtypedescription, displayurl) 
values (70,'Lab Resource','labResourceOb','Lab Resource','labresource.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON labResourceOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(70);


\echo setting up ontology for labResource  types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('LABRESOURCE_TYPES','This ontology provides standard type names for the resource type column of the labResource table','ontology.LABRESOURCE_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Primer' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Forward Primer' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Reverse Primer' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Cloning Vector' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Sequencing Vector' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Genotype SNP' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LABRESOURCE_TYPES.Genotype SNP chip','Genotype SNP chip' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LABRESOURCE_TYPES.Functional Assay','Functional Assay' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LABRESOURCE_TYPES.Survey Form','Survey Form' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LABRESOURCE_TYPES.2D Reference Protein Gel','2D Reference Protein Gel' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LABRESOURCE_TYPES.1D Reference Protein Gel','1D Reference Protein Gel' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';


commit;


\echo attaching ontology check 
CREATE FUNCTION checkLabResourceOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.resourceType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''LABRESOURCE_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid lab resource type '', NEW.resourceType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER labResourceTypeCheck BEFORE INSERT OR UPDATE ON labResourceOb
    FOR EACH ROW EXECUTE PROCEDURE checkLabResourceOntology();





\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(71,'Lab Resource Fact','labResourceFact',FALSE,'Lab Resource Fact',TRUE,'labresource.gif');
\echo creating labResourceFact
create table labResourceFact (
   labResourceOb integer not null references labResourceOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 71,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';



CREATE OR REPLACE FUNCTION getlabresourcecharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        resourceobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from labresourcefact 
      where labresourceob = resourceobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;


CREATE OR REPLACE FUNCTION createLabResource_SNP("varchar", "varchar", "varchar", boolean) RETURNS "int4" AS
$BODY$
    DECLARE
        snpcursor refcursor;
        curresult varchar;
        locus ALIAS for $1;
        rsnumber ALIAS for $2;
        alleles ALIAS for $3;
        strict ALIAS for $4;
        snpname varchar;
        newob integer;
    BEGIN
/* 
* create a SNP and its details records
*/


      /*
      * check that the rsnumber does not have the rs prefix
      */ 
      if upper(rsnumber) like 'RS%' then
         raise exception 'rs number should not include rs prefix';
      end if;
  
      /*
      * check that a SNP with this name does not already exist.
      * names are like : snp.CCR6.2301436
      * lsid is like : gentoype.snp.CCR6.2301436
      */

      snpname = 'snp.'||locus||'.'||rsnumber;


      open snpcursor for
      select xreflsid from labresourceob where
      upper(resourcename) = upper(snpname);

      fetch snpcursor into curresult;

      if found then
         raise exception 'a SNP labresource record with this name (%) already exists' , snpname;
      end if;

      close snpcursor;


      /*
      * check that a SNP with this rsnumber does not already exist, if strict is set
      */
      if strict then 
         open snpcursor for
         select factnamespace from labresourcefact where 
         factnamespace = 'dbSNP' and 
         attributename = 'rs number' and 
         attributevalue = rsnumber;
  
         fetch snpcursor into curresult;

         if found then
            raise exception 'a SNP labresource record with this rsnumber (%) already exists' , rsnumber;
         end if;

         close snpcursor;

         open snpcursor for
         select xreflsid from labresourceob where
         upper(resourcename) like '%.%.'||rsnumber;

         fetch snpcursor into curresult;

         if found then
            raise exception 'a SNP labresource record with this rsnumber (%) already exists' , rsnumber;
         end if;

         close snpcursor;
      end if;


      /* create the new records */
      newob = getNewObid();
      insert into labresourceob(obid, xreflsid, resourcename, resourcetype)
      values(newob,'genotype.'||snpname,snpname,'Genotype SNP');

      insert into labresourcefact(labresourceob, factnamespace, attributename, attributevalue)
      values(newob, 'dbSNP', 'rs number', rsnumber);

      insert into labresourcefact(labresourceob, factnamespace, attributename, attributevalue)
      values(newob, 'dbSNP', 'alleles', upper(alleles));

      return newob;

    END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;

-- example select createLabResource_SNP('FGFR1OP','2301436','A/G', FALSE) ;



\echo creating labResourcelist
create table labResourceList (
   listName varchar(256) not null,
   maxMembership integer,
   listComment varchar(1024),
   check (obtypeid = 75) ,
   unique (obid) )
   inherits(ob) 
   without oids;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription,displayurl) 
values (75,'Lab Resource List','labResourcelist','Lab Resource List','labresource.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON labResourceList
    FOR EACH ROW EXECUTE PROCEDURE setObType(75);


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(80,'Lab Resource List','labResourceListMembershipLink',FALSE, 'labResourceListMembershipLink',TRUE);
\echo creating labResourcelistMembershipLink
create table labResourceListMembershipLink (
   labResourceList integer not null references labResourceList(obid),
   labResourceOb integer not null references labResourceOb(obid),
   inclusionComment varchar(64),  /* e.g. forward primer, reverse primer etc */
   addedDate date DEFAULT now(),
   addedBy varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 80,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 80,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';




/*
********************************************************
* basic bioSample , bioSubject and bioProtocol tables.
********************************************************
* These tables provide the basic entities and op relations to 
* enter samples into the database.
*
* Each sample entered requires a mandatory samplingFunction relation to 
* be set up , involving at least a bioSubjectOb and bioProtocolOb. The relation may also
* optionally include a bioResourceList
* 
*/
create table bioSubjectOb (
   subjectName varchar(1024),
   subjectSpeciesName varchar(1024),
   subjectTaxon integer,
   strain varchar(1024),
   subjectdescription text, 
   dob date,
   yob integer,
   mob integer,
   sex varchar(1),
   check (sex in ('M','F')),
   check (obtypeid = 85) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,   displayName,   tablename ,   obtypedescription, displayurl) 
values (85,'Subject','bioSubjectOb','Subject','organism.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioSubjectOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(85);
CREATE TRIGGER filterKeywords BEFORE INSERT OR UPDATE ON bioSubjectOb
    FOR EACH ROW EXECUTE PROCEDURE filterKeywords(obkeywords);




/*
* this table provides storage for general additional attributes
* of a bioSubject
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(86,'Subject Details','bioSubjectFact',FALSE,'Subject Details',TRUE,'organism.gif');
\echo creating bioSubjectFact
create table bioSubjectFact (
   bioSubjectOb integer not null references bioSubjectOb(obid),
   factNameSpace varchar(256),
   attributeDate date,
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 86,   obtypeid,   'bioSubjectOb' from obtype where  upper(tablename) = 'BIOSUBJECTOB';


CREATE OR REPLACE FUNCTION getsubjectcharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        subjectobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from biosubjectfact 
      where biosubjectob = subjectobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



/*
* return a single string of all the fact dimensions
for a subject
*/
create or replace function getSubjectFactDimensions(integer) returns "text" as
'
   declare 
      myob alias for $1;
      result text;
   begin
      select agg_comma_concat(factnamespace) into result from 
          (select distinct factnamespace as factnamespace from 
              biosubjectfact where biosubjectob = myob) as facts;
      return result;
   end;
'
language 'plpgsql' volatile;



\echo setting up sample type ontologies 
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BIOSAMPLE_TYPES','This ontology provides standard terms for biosample types ','ontology.BIOSAMPLE_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Clone' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','EST Clone' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Genomic Clone' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','PCR Product' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Protein Extract' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','2D Gel Spot' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Blood Sample' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','total RNA extract for microarray experiment' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','mRNA extract for microarray experiment' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Histology' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Other' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.BIOSAMPLE_TYPES.food extract','Food Extract' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.BIOSAMPLE_TYPES.Tissue Sample','Tissue Sample' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.BIOSAMPLE_TYPES.GBS SAmple','GBS Sample' from ontologyOb where ontologyName = 'BIOSAMPLE_TYPES';

commit;

\echo setting up sample tissue ontologies 
insert into ontologyob(ontologyName, ontologyDescription, xreflsid)
values('BIOSAMPLE_TISSUES','This ontology provides standard terms for biosample tissues ','ontology.BIOSAMPLE_TISSUES');
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Blood', obid, 'Blood' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Foetus', obid, 'Foetus' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Gall Bladder', obid, 'Gall Bladder' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Intestine', obid, 'Intestine' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Liver', obid, 'Liver' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Lymphoid', obid, 'Lymphoid' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Mammary Gland', obid, 'Mammary Gland' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Milk', obid, 'Milk' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Muscle', obid, 'Muscle' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Ovary', obid, 'Ovary' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Skin', obid, 'Skin' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOSAMPLE_TISSUES.Wool', obid, 'Wool' from ontologyOb where ontologyName = 'BIOSAMPLE_TISSUES';

create table bioSampleOb (
   samplename varchar(1024),
   sampletype varchar(256),
   sampletissue varchar(256),
   sampledate date,
   sampledescription text,
   samplestorage text ,
   samplecount float,
   samplecountunit varchar(64),
   sampleweight float,
   sampleweightunit varchar(64),
   samplevolume float,
   samplevolumeunit varchar(64),
   sampledrymatterequiv float,
   sampledmeunit varchar(64),
   check (obtypeid = 90) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription, displayurl) 
values (90,'Sample','bioSampleOb','Sample','eppendorf.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioSampleOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(90);
\echo attaching ontology check. 
CREATE FUNCTION checkBioSampleTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.sampleType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''BIOSAMPLE_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid sample type '', NEW.sampleType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkBioSampleTypeOntology BEFORE INSERT OR UPDATE ON bioSampleOb
    FOR EACH ROW EXECUTE PROCEDURE checkBioSampleTypeOntology();

CREATE FUNCTION checkSampleUnits() RETURNS trigger AS '
    DECLARE
        units RECORD;
    BEGIN
        if NEW.sampleweightunit is not null then
           select into units  * from ontologytermfact where termname = NEW.sampleweightunit and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''UNITS'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid unit name '', NEW.sampleweightunit;
           end if;
        end if;

        if NEW.samplevolumeunit is not null then
           select into units  * from ontologytermfact where termname = NEW.samplevolumeunit and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''UNITS'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid unit name '', NEW.samplevolumeunit;
           end if;
        end if;

        if NEW.sampledmeunit is not null then
           select into units  * from ontologytermfact where termname = NEW.sampledmeunit and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''UNITS'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid unit name '', NEW.sampledmeunit;
           end if;
        end if;

        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkSampleUnits BEFORE INSERT OR UPDATE ON bioSampleOb
    FOR EACH ROW EXECUTE PROCEDURE checkSampleUnits();


/*
* a bioprotocolOb represents a lab , bioinformatic or statistical protocol. 
*/
\echo setting up bioprotocol ontology 
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BIOPROTOCOL_TYPES','This ontology provides standard terms for bioprotocol types ','ontology.BIOPROTOCOL_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','TWO COLOUR MICROARRAY' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','EST LIBRARY CONSTRUCTION' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','BLAST SEARCH' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','GENOTYPE' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'BIOPROTOCOL_TYPES.Database Update','Database Update' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'BIOPROTOCOL_TYPES.Functional Assay','Functional Assay' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';




insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOPROTOCOL_TYPES.HYBRIDISATION', obid, 'HYBRIDISATION' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOPROTOCOL_TYPES.SLIDE SCANNING', obid, 'SLIDE SCANNING' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOPROTOCOL_TYPES.NORMALISATION', obid, 'NORMALISATION' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOPROTOCOL_TYPES.RNA EXTRACTION', obid, 'RNA EXTRACTION' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOPROTOCOL_TYPES.TISSUE SAMPLE COLLECTION', obid, 'TISSUE SAMPLE COLLECTION' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOPROTOCOL_TYPES.LIBRARY CONSTRUCTION', obid, 'LIBRARY CONSTRUCTION' from ontologyOb where ontologyName = 'BIOPROTOCOL_TYPES';


create table bioProtocolOb (
   protocolName varchar(1024),
   protocolType varchar(1024),
   protocolDescription varchar(1024),
   protocolText text,
   check (obtypeid = 95) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription) 
values (95,'Protocol','bioProtocolOb','Protocol');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioProtocolOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(95);

\echo attaching ontology check. 
CREATE FUNCTION checkBioProtocolTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.protocolType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''BIOPROTOCOL_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid protocol type '', NEW.protocolType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkBioProtocolTypeOntology BEFORE INSERT OR UPDATE ON bioProtocolOb
    FOR EACH ROW EXECUTE PROCEDURE checkBioProtocolTypeOntology();

\echo inserting record into bioprotocolob table, for default protocol in microarray sample form
insert into bioprotocolob (obid,xreflsid,protocolname,protocoltype,protocoldescription,protocoltext)
values (nextval('ob_obidseq'),'microarrayBioProtocol.Unspecified RNA sampling protocol','Unspecified RNA sampling protocol',
'RNA EXTRACTION','Unspecified RNA sampling protocol for users to submit samples with if they want','');





/*
* added 10/2007
*/
\echo setting up sample tissue ontologies 
insert into ontologyob(ontologyName, ontologyDescription, xreflsid)
values('BIOLIBRARY_TYPES','This ontology provides standard bio library types','ontology.BIOLIBRARY_TYPES');
insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOLIBRARY_TYPES.454 Sequencing Library', obid, '454 Sequencing Library' from ontologyOb where ontologyName = 'BIOLIBRARY_TYPES';

insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOLIBRARY_TYPES.EST Contig Assembly', obid, 'EST Contig Assembly' from ontologyOb where ontologyName = 'BIOLIBRARY_TYPES';

insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOLIBRARY_TYPES.EST Tissue Library ', obid, 'EST Tissue Library' from ontologyOb where ontologyName = 'BIOLIBRARY_TYPES';


insert into ontologytermfact (xreflsid, ontologyob, termname)
select 'ontology.BIOLIBRARY_TYPES.Genomic Clone', obid, 'Genomic Clone' from ontologyOb where ontologyName = 'BIOLIBRARY_TYPES';
create table bioLibraryOb (
   libraryName varchar(1024),
   libraryType varchar(256),
   libraryDate date,
   libraryDescription text,
   libraryStorage text ,
   check (obtypeid = 485) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription, displayurl) 
values (485,'Library','bioLibraryOb','Library','biolibrary.jpg');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioLibraryOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(485);


CREATE FUNCTION checkBioLibraryTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.libraryType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''BIOLIBRARY_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid library type '', NEW.libraryType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkBioLibraryTypeOntology BEFORE INSERT OR UPDATE ON bioLibraryOb
    FOR EACH ROW EXECUTE PROCEDURE checkBioLibraryTypeOntology();


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop,displayurl)
values(490,'Library Details','bioLibraryFact',FALSE,'Library Details',TRUE,'biolibrary.jpg');
\echo creating bioLibraryFact
create table bioLibraryFact (
   bioLibraryOb integer not null references bioLibraryOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 490,   obtypeid,   'bioLibraryOb' from obtype where  upper(tablename) = 'BIOLIBRARYOB';


CREATE OR REPLACE FUNCTION getlibrarycharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        libraryobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from biolibraryfact 
      where biolibraryob = libraryobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;


/*
* relationship between a libray and a sample.
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,displayurl)
values(495, 'Library Construction','bioLibraryConstructionFunction',TRUE,'Library construction function',TRUE,'biolibrary.jpg');


\echo creating bioLibraryConstructionFunction
create table bioLibraryConstructionFunction (
   biosampleob integer not null references biosampleob(obid),
   biolibraryob integer not null references biolibraryob(obid),
   bioprotocolob integer references bioprotocolob(obid),
   labResourceList integer references labResourceList(obid),
   labResourceOb integer references labResourceOb(obid),
   labBookReference varchar(2048),
   constructioncomment varchar(1024),
   constructiondate date,
   check(obtypeid = 495),
   unique(obid)  )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 495,   obtypeid,   'biosampleob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 495,   obtypeid,   'biolibraryob' from obtype where  upper(tablename) = 'BIOLIBRARYOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 495,   obtypeid,   'bioprotocolob' from obtype where  upper(tablename) = 'BIOPROTOCOLOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 495,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 495,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioLibraryConstructionFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(495);


/*
*
* BioSample Aliquot Facts - this table provides storage for basic information regarding multiple aliquots
* taken from a given sample - for example,you may wish to record how much sample remains.
* Aliquots taken from a sample may themselves be set up as biosample records, or may not.
* If they are set up as biosample records than a link to the parent sample may be established
* using the predicatelink table, with a link type of "ALIQUOT FROM"
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop,displayurl)
values(400,'Sample Aliquots','bioSampleAliquotFact',TRUE,'Sample Aliquots',TRUE,'eppendorf.gif');
\echo creating bioSampleAliquotFact
create table bioSampleAliquotFact (
   bioSampleOb integer not null references bioSampleOb(obid),
   aliquotvolume float,
   aliquotvolumeunit varchar(64),
   aliquotcount float,
   aliquotcountunit varchar(64),
   aliquotweight float,
   aliquotweightunit varchar(64),
   aliquotdme float,
   aliquotdmeunit varchar(64),
   aliquottype varchar(64),
   aliquotdate date,
   aliquotcomment text,
   check(obtypeid = 400),
   unique(obid)  )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 400,   obtypeid,   'biosampleob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioSampleAliquotFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(400);
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('ALIQUOT_TYPES','This ontology provides standard terms for aliquot types ','ontology.ALIQUOT_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.ALIQUOT_TYPES.Nutrigenomics FBC aliquot','Nutrigenomics FBC aliquot' from ontologyOb where ontologyName = 'ALIQUOT_TYPES';
CREATE FUNCTION checkAliquotRecord() RETURNS trigger AS '
    DECLARE
        units RECORD;
        terms RECORD;
    BEGIN
        if NEW.aliquotweightunit is not null then
           select into units  * from ontologytermfact where termname = NEW.aliquotweightunit and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''UNITS'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid unit name '', NEW.aliquotweightunit;
           end if;
        end if;

        if NEW.aliquotvolumeunit is not null then
           select into units  * from ontologytermfact where termname = NEW.aliquotvolumeunit and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''UNITS'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid unit name '', NEW.aliquotvolumeunit;
           end if;
        end if;

        if NEW.aliquotdmeunit is not null then
           select into units  * from ontologytermfact where termname = NEW.aliquotdmeunit and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''UNITS'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid unit name '', NEW.aliquotdmeunit;
           end if;
        end if;

        return NEW;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkAliquotRecord BEFORE INSERT OR UPDATE ON bioSampleAliquotFact
    FOR EACH ROW EXECUTE PROCEDURE checkAliquotRecord();

\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(410,'Aliquot Attribute','bioSampleAliquotFact2',FALSE,'Aliquot Attribute',TRUE,'eppendorf.gif');
\echo creating bioSampleAliquotFact2
create table bioSampleAliquotFact2 (
   bioSampleAliquotFact integer not null references bioSampleAliquotFact(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 410,   obtypeid,   'bioSampleAliquotFact' from obtype where  upper(tablename) = 'BIOSAMPLEALIQUOTFACT';



/*
* this table provides storage for general additional attributes
* of a bioSample
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop,displayurl)
values(91,'Sample Details','bioSampleFact',FALSE,'Sample Details',TRUE,'eppendorf.gif');
\echo creating bioSampleFact
create table bioSampleFact (
   bioSampleOb integer not null references bioSampleOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 91,   obtypeid,   'bioSampleOb' from obtype where  upper(tablename) = 'BIOSAMPLEOB';


CREATE OR REPLACE FUNCTION getsamplecharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        sampleobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from biosamplefact 
      where biosampleob = sampleobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



/*
* template basic biological sampling function - membership of this
* function is mandatory for biosamples
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,displayurl)
values(100, 'Sampling Done','bioSamplingFunction',TRUE,'Sampling Done',TRUE,'eppendorf.gif');
\echo creating bioSamplingFunction
create table bioSamplingFunction (
   biosubjectob integer references biosubjectob(obid),
   biosampleob integer not null references biosampleob(obid),
   bioprotocolob integer references bioprotocolob(obid),
   labResourceList integer references labResourceList(obid),
   labResourceOb integer references labResourceOb(obid),
   parentsample integer references biosampleob(obid), /* used to support fractions */
   labBookReference varchar(2048),
   samplingcomment varchar(1024),
   samplingdate date,
   check(obtypeid = 100),
   primary key (obid)   )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 100,   obtypeid,   'biosubjectob' from obtype where  upper(tablename) = 'BIOSUBJECTOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 100,   obtypeid,   'biosampleob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 100,   obtypeid,   'bioprotocolob' from obtype where  upper(tablename) = 'BIOPROTOCOLOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 100,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 100,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioSamplingFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(100);

\echo create function to check that ob is one of the valid types - currently either 
\echo bioSubjectOb or 2DGelstudy !!!!!!! to do !!!!!!!


/*
* this table provides storage for general additional attributes
* of a bioSamplingFunction - i.e. of the actual sampling process, not the 
* sample itself. 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(101,'Sampling Details','bioSamplingFact',FALSE,'Sampling Details',TRUE,'eppendorf.gif');
\echo creating bioSampling Fact
create table bioSamplingFact (
   bioSamplingFunction integer not null references bioSamplingFunction(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096),
   unitName varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 101,   obtypeid,   'bioSamplingFunction' from obtype where  upper(tablename) = 'BIOSAMPLINGFUNCTION';
CREATE TRIGGER checkSamplingUnitName BEFORE INSERT OR UPDATE ON bioSamplingFact
    FOR EACH ROW EXECUTE PROCEDURE checkUnitName();


\echo creating bioSampleList
create table bioSampleList (
   listName varchar(256) not null,
   maxMembership integer,
   listComment varchar(1024),
   check (obtypeid = 102) ,
   unique (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription,displayurl) 
values (102,'Sample List','bioSampleList','Sample List','eppendorf.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioSampleList
    FOR EACH ROW EXECUTE PROCEDURE setObType(102);


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(103,'Sample List Membership','bioSampleListMembershipLink',FALSE, 'Sample List Membership',TRUE);
\echo creating bioSampleListMembershipLink
create table bioSampleListMembershipLink (
   bioSampleList integer not null references bioSampleList(obid),
   bioSampleOb integer not null references bioSampleOb(obid),
   inclusionComment varchar(64),  /* e.g. forward primer, reverse primer etc */
   addedDate date DEFAULT now(),
   addedBy varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 103,   obtypeid,   'bioSampleList' from obtype where  upper(tablename) = 'BIOSAMPLELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 103,   obtypeid,   'bioSampleOb' from obtype where  upper(tablename) = 'BIOSAMPLEOB';




/*
************************************************************************
* pedigreeLink tables
************************************************************************
*/

\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(335,'Pedigree Link','pedigreeLink',TRUE, 'Basic pedigree link table used to establish relationships between biosubjects such as FATHER OF ,MOTHER OF ',TRUE,'pedigree.jpg');
\echo creating pedigreeLink
/*
* base table for specific predicate link tables - see Known bugs above, re foreign keys and 
* inheritance
*/
create table pedigreelink (
   subjectob integer not null references biosubjectob(obid),
   objectob integer not null references biosubjectob(obid), 
   relationship varchar(64),
   relationshipcomment varchar(256),
   check(obtypeid = 335),
   unique(obid)  )
   inherits(op)
   without oids ;
CREATE TRIGGER setObType BEFORE INSERT ON pedigreeLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(335);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 335,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSUBJECTOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 335,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSUBJECTOB';


\echo setting up ontology for predicate types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('PEDIGREE_RELATIONSHIP','This ontology provides standard names for pedigree relationships','ontology.PEDIGREE_RELATIONSHIP');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.PEDIGREE_RELATIONSHIP.DAM OF','DAM OF' from ontologyOb where ontologyName = 'PEDIGREE_RELATIONSHIP';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.PEDIGREE_RELATIONSHIP.SIRE OF','SIRE OF' from ontologyOb where ontologyName = 'PEDIGREE_RELATIONSHIP';
commit;


\echo attaching ontology check 
CREATE FUNCTION checkPedigreeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.relationship and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''PEDIGREE_RELATIONSHIP'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid pedigree relationship '', NEW.relationship;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkPedigreeOntology BEFORE INSERT OR UPDATE ON pedigreeLink
    FOR EACH ROW EXECUTE PROCEDURE checkPedigreeOntology();









/*
************************************************************************
* basic bioSequenceOb, sequencingFunction tables 
************************************************************************
*
* bioSampleOb, labResourceList and bioSequenceOb are combined the 
* sequencingFunction op. Not all bioSequenceObs are related to samples and 
* sequencing so this relationship is optional.
*
* 
* bioSequenceObs may be sequences or sequence models
*
* 
*/
/*
* bioSequenceOb - table for storing bioSequences. This table is not for storing things
* like oligos or primers - i.e. bio means bio.
*
* Note however that this table can be used for storing sequence models such as Regexps, PSMs,
* HMMs, as well as sequence strings. (A sequence string is itself a model of a sequence)
* 
* Some of the sequences stored in the table will not be related to samples and
* sequencing functions in this database - hence membership in the seqencingfunction op
* is not mandatory.
*
* As with all obs, an xreflsid column is inherited from the base ob table , this 
* may be used to store an LSID for the sequence, that was derived from an external 
* source
*
* In case the sequence string itself is not stored in the database, a seqURL column
* is included so that we can locate the sequence from a remote source.
* 
* fnindex ("function index") columns are provided to enable indexing into the 
* sequence table by accession or id - even though LSID is the unique id ,
* we still need the redundant accession and id columns for performance reasons.
* 
*/
\echo creating bioSequenceOb
create table bioSequenceOb (
   sequenceName varchar(1024),
   sequenceType varchar(256), /* sequence ontology */
   seqstring text,
   sequencedescription text,
   sequenceTopology varchar(32) default 'linear',
   seqlength integer,
   sequenceURL varchar(2048),
   seqcomment varchar(2048),
   gi integer,
   fnindex_accession varchar(2048),
   fnindex_id varchar(2048),
   check (obtypeid = 115) ,
   check (sequenceTopology in ('linear','circular')),
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription,displayurl) 
values (115,'Sequence','bioSequenceOb','Sequence','biosequence.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioSequenceOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(115);

\echo setting up sequence ontology 
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('AGSEQUENCE_ONTOLOGY','This ontology provides standard terms for a sequence ontology specific to this database','ontology.AGSEQUENCE_ONTOLOGY');
\echo initialising sequence ontology with interim term names - NB not final ontology
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','GENOMIC DNA SEQUENCE' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','SEQUENCE TAGGED SITE' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','mRNA SEQUENCE' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','PROTEIN SEQUENCE' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','PROTEIN SEQUENCE MODEL' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','DNA SEQUENCE MODEL' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','genomic DNA' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','cDNA to mRNA' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','genomic RNA' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','pre-mRNA' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','tRNA' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','rRNA' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','snRNA' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','scRNA' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.mRNA Reference Sequence','mRNA Reference Sequence' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.Protein Reference Sequence','Protein Reference Sequence' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.Affy Probe Oligo','Affy Probe Oligo' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.Affy Target Oligo','Affy Target Oligo' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.BAC End Sequence','BAC End Sequence' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.DNA SEQUENCE','DNA SEQUENCE' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.DNA pseudomolecule (predicted CDS)','DNA pseudomolecule (predicted CDS)' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.primer','primer' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';


insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.AGSEQUENCE_ONTOLOGY.Microarray Probe Oligo','Microarray Probe Oligo' from ontologyOb where ontologyName = 'AGSEQUENCE_ONTOLOGY';


\echo creating table column ontology
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BRDFTABLE_biosequenceob','This ontology contains column names and descriptions for the biosequence table','ontology.BRDFTABLE_biosequenceob');
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.sequencename','sequencename','Name' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.xreflsid','xreflsid','LSID' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.sequencetype','sequencetype','Type' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.seqstring','seqstring' , 'Sequence' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.sequencedescription','sequencedescription','Description' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.sequencetopology','sequencetopology', ' Topology' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.seqlength','seqlength','Length' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.sequenceurl','sequenceurl','URL' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.seqcomment','seqcomment','Comment' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.gi','gi','GI' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.fnindex_accession','fnindex_accession' ,'Accession' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequenceob.fnindex_id','fnindex_id','ID' from ontologyOb where ontologyName = 'BRDFTABLE_biosequenceob';



commit;


\echo attaching ontology check. 
/* depending on the structure of the sequence ontology this may need refining - it does not currently
* care which field the term is being inserted into , only that it is a valid SOFA term which
* may not be correct
*/
CREATE FUNCTION checkSequenceOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.sequenceType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''AGSEQUENCE_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid sequence type '', NEW.sequenceType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkSequenceOntology BEFORE INSERT OR UPDATE ON bioSequenceOb
    FOR EACH ROW EXECUTE PROCEDURE checkSequenceOntology();



/*
* this table provides storage for facts about a protein , created as part of changes 7/2011 to support protein observations from a gel.
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop, displayurl)
values(119,'Protein Details','proteinFact',TRUE,'Protein Details',TRUE, 'protein.gif');
\echo creating proteinFact
create table proteinFact (
   bioSequenceOb integer not null references bioSequenceOb(obid),
   isoElectricPoint float,
   relativeMolecularMass float,
   check (obtypeid = 119) ,
   unique (obid)) 
   inherits (op)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 119,   obtypeid,   'bioSequenceOb' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON proteinFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(119);



/*
* this table provides storage for general facts about a sequence
*/
commit;
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(116,'Sequence Details','bioSequenceFact',FALSE,'Sequence Details',TRUE);
\echo creating bioSequence Fact
create table bioSequenceFact (
   bioSequenceOb integer not null references bioSequenceOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 116,   obtypeid,   'bioSequenceOb' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';


CREATE OR REPLACE FUNCTION getbiosequencefact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        sequenceobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from bioSequenceFact 
      where bioSequenceOb = sequenceobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;




/*
* this table provides storage for features
* of a bioSequence
*/
\echo setting up sequence feature ontology 
insert into ontologyob(ontologyName,   xreflsid, ontologyDescription )
values('SEQUENCE_FEATURE_ONTOLOGY','SEQUENCE_FEATURE_ONTOLOGY','This ontology provides standard terms for sequence features');
\echo initialising sequence feature ontology with interim term names - NB not final ontology
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','SSR' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','SNP' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','attenuator' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','C_region' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','CAAT_signal' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','cds' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','conflict' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','D-loop' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','D_segment' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','enhancer' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','exon' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','gap' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','GC_signal' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','gene' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','iDNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','intron' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','J_segment' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','LTR' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','mat_peptide' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','misc_binding' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','misc_difference' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','misc_feature' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','misc_recomb' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','misc_RNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','misc_signal' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','misc_structure' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','modified_base' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','mRNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','N_region' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','old_sequence' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','operon' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','oriT' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','polyA_signal' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','polyA_site' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','precursor_RNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','prim_transcript' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','primer_bind' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','promoter' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','protein_bind' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','RBS' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','repeat_region' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','repeat_unit' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','rep_origin' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','rRNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','S_region' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','satellite' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','scRNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','sig_peptide' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','snRNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','snoRNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','source' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','stem_loop' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','STS' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','TATA_signal' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','terminator' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','transit_peptide' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','tRNA' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','unsure' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','V_region' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','V_segment' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','variation' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','3primeclip' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','3primeUTR' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','5primeclip' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','5primeUTR' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','-10_signal' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','-35_signal' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'SEQUENCE_FEATURE_ONTOLOGY.sage_tag','sage_tag' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'SEQUENCE_FEATURE_ONTOLOGY.similarity','similarity' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'SEQUENCE_FEATURE_ONTOLOGY.microarray_oligo','microarray_oligo' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
		insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'SEQUENCE_FEATURE_ONTOLOGY.match','match' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
                insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ONTOLOGY.transcript','transcript','transcript' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';
                insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ONTOLOGY.assembled_read','assembled_read','assembled_read' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ONTOLOGY';




\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(117,'Sequence Feature','bioSequenceFeatureFact',TRUE,'Sequence Feature',TRUE);
\echo creating bioSequence Feature Fact
create table bioSequenceFeatureFact (
   bioSequenceOb integer not null references bioSequenceOb(obid),
   featureType varchar(256),
   featureAccession varchar(256),
   featureStart integer,
   featureStop integer,
   featureStrand integer,
   featureFrame integer,
   featureComment text,
   evidence text,
   score float,
   featurelength integer,
   check(obtypeid = 117) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioSequenceFeatureFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(117);

\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 117,   obtypeid,   'bioSequenceOb' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
CREATE FUNCTION checkFeatureOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.featureType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''SEQUENCE_FEATURE_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid feature name '', NEW.featureType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkFeatureOntology BEFORE INSERT OR UPDATE ON bioSequenceFeatureFact
    FOR EACH ROW EXECUTE PROCEDURE checkFeatureOntology();


\echo creating table column ontology
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BRDFTABLE_biosequencefeaturefact','This ontology contains column names and descriptions for the biosequence feature fact  table','ontology.BRDFTABLE_biosequenceob');
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequencefeaturefact.xreflsid','xreflsid','LSID' from ontologyOb where ontologyName = 'BRDFTABLE_biosequencefeaturefact';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequencefeaturefact.featuretype','featuretype','Feature' from ontologyOb where ontologyName = 'BRDFTABLE_biosequencefeaturefact';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequencefeaturefact.featurestrand','featurestrand' , 'Strand' from ontologyOb where ontologyName = 'BRDFTABLE_biosequencefeaturefact';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequencefeaturefact.featurestart','featurestart','Start' from ontologyOb where ontologyName = 'BRDFTABLE_biosequencefeaturefact';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequencefeaturefact.featurestop','featurestop', 'Stop' from ontologyOb where ontologyName = 'BRDFTABLE_biosequencefeaturefact';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termdescription) select obid,'ontology.BRDFTABLE_biosequencefeaturefact.featurecomment','featurecomment','Feature Comment' from ontologyOb where ontologyName = 'BRDFTABLE_biosequencefeaturefact';
insert into ontologyTermFact(ontologyob,xreflsid,termName, termDescription) select 
obid,'BRDFTABLE_biosequencefeaturefact.evidence','evidence','Evidence for the feature'
from ontologyOb where ontologyName = 'BRDFTABLE_biosequencefeaturefact';


/*
and this - though these are loaded as a batch job
insert into ontologytermfact2(ontologytermid,factnamespace,attributename,attributevalue)
select 
   ot.obid,
   'DISPLAY',
   'DISPLAYNAME',
   'Evidence'
from 
   ontologyob o join ontologytermfact ot on 
   o.ontologyName = 'BRDFTABLE_biosequencefeaturefact' and
   ot.ontologyob = o.obid and 
   ot.termname = 'evidence';
*/





/*
* this table provides storage for features
* of a bioSequence
*/
\echo setting up sequence feature ontology 
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY','This ontology provides standard terms for sequence feature attribute names','ontology.SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY');
\echo initialising sequence feature ontology with interim term names - NB not final ontology


insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.SSR unitType','SSR unitType','example : dinucleotide' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.SSR unit','SSR unit','example : AT' from ontologyOb where ontologyName =  'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.SSR score','SSR score','SSR Score assigned by algorithm (e.g. sputnik or tandyman)' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.locationobid',
'locationobid','A reference to a location record - for example where an exon has been annotated by mapping to a location in a genoome' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';


insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.CONSENSUSPOS',
'CONSENSUSPOS','Consensus (i.e. gapped) position of a sequence' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.SNP',
'SNP','specify which polymorphism in a SNP feature' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.DISTRIBUTION',
'DISTRIBUTION','specify base distribution of a polymorphism in a SNP feature' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.DEPTH',
'DEPTH','specify alignment depth in a SNP feature' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.TRUEDEPTH',
'TRUEDEPTH','specify adjusted alignment depth in a SNP feature' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.CONSENSUSLENGTH',
'CONSENSUSLENGTH','specify consensus length of consensus in a SNP feature' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid, termName, termDescription) select obid,'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY.SNPSTHISCONTIG',
'SNPSTHISCONTIG','specify number of SNPs in this contig' from ontologyOb where ontologyName = 'SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY';












\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(118,'Sequence Feature Attribute','bioSequenceFeatureAttributeFact',FALSE,'Sequence Feature Attribute',TRUE);
\echo creating bioSequence Feature Fact Attribute
create table bioSequenceFeatureAttributeFact (
   bioSequenceFeatureFact integer not null references bioSequenceFeatureFact(obid),
   factnamespace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 118,   obtypeid,   'bioSequenceFeatureFact' from obtype where  upper(tablename) = 'BIOSEQUENCEFEATUREFACT';
CREATE FUNCTION checkFeatureAttributeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.attributeName and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''SEQUENCE_FEATURE_ATTRIBUTE_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid feature attribute name '', NEW.attributeName;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkFeatureAttributeOntology BEFORE INSERT OR UPDATE ON bioSequenceFeatureAttributeFact
    FOR EACH ROW EXECUTE PROCEDURE checkFeatureAttributeOntology();



CREATE OR REPLACE FUNCTION getsequencefeatureattribute(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        featureobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from  bioSequenceFeatureAttributeFact
      where bioSequenceFeatureFact = featureobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



/*
* a frunction for retrieving the number of sequence features of a given type for a given
* sequence
*/
CREATE FUNCTION getFeatureDepth(int4, "varchar") returns integer  AS '
    DECLARE
        seqid ALIAS for $1;
        feature ALIAS for $2;
        depth integer;
    BEGIN
        select count(*) into depth from 
        biosequencefeaturefact where biosequenceob = seqid and 
        featuretype = feature;
        return depth;
    END;
' LANGUAGE plpgsql;



/*
* sequencingFunction op - a relation between a bioSampleOb, a bioSequenceOb amd a labResourceList
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop)
values(120, 'Sequencing Done','sequencingFunction',TRUE,'Sequencing Done',TRUE);
\echo creating sequencingFunction
create table sequencingFunction (
   bioSampleob integer references bioSampleOb(obid),
   bioLibraryob integer references bioLibraryOb(obid),
   bioSequenceOb integer not null references bioSequenceOb(obid),
   labResourceList integer references labResourceList(obid),
   labResourceOb integer references labResourceOb(obid),
   sequencedBy varchar(256),
   sequencingdate date,
   functioncomment varchar(1024),
   check(obtypeid = 120) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 120,   obtypeid,   'bioSampleob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 120,   obtypeid,   'bioLibraryob' from obtype where  upper(tablename) = 'BIOLIBRARYOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 120,   obtypeid,   'biosequenceob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 120,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 120,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON sequencingFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(120);

/*
* this table provides storage for general additional attributes
* of a sequencingFunction - i.e. of the actual sequencing process, not the 
* sample itself. 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(121,'Sequencing Details','sequencingFact',FALSE,'Sequencing Details',TRUE);
\echo creating sequencing Fact
create table sequencingFact (
   sequencingFunction integer not null references sequencingFunction(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 121,   obtypeid,   'sequencingFunction' from obtype where  upper(tablename) = 'SEQUENCINGFUNCTION';


/**************************************************************
* This function returns a Genbank record for a sequence
* (author J Mitchell). With suitable mime-type it can be sent to a browser
* and will automatically start a handler (such as VNTI) , for the 
* sequence.
* ( The Mime type is genbankContentHeader = "Content-Type: chemical/seq-na-genbank\n\n")
***************************************************************/
create or replace function getGenbankRecord(varchar) 
  returns varchar as 
'
DECLARE
   cursr refcursor;
   speciesVal varchar;
   taxidVal varchar;
   source varchar;
   
   seqname varchar;
   seqtypeholder varchar;
   seqlen integer;
   seqstr varchar;
   seqtype varchar;
   seqtop varchar;
   seqdate date;

   feattype varchar;
   featstart integer;
   featstop integer;
   featxref varchar;
   featcom varchar;
   featevid varchar;

   --biosequenceobid ALIAS for $1;
   biosequenceobid integer;
   seqbuff varchar;
   strbuff varchar;

   comments varchar;
   position integer;
   basesize integer;
   lastfeature varchar;
   lastseqstart integer;
   lastseqstop integer;

BEGIN
   --Test if obid is an obid or is an xreflsid
   select into biosequenceobid obid from biosequenceob where xreflsid = $1;
   if not FOUND then
      select into biosequenceobid obid from biosequenceob where obid = $1;
   end if;
   if not FOUND then
      return ''ERROR - obid not found!'';
   end if;
   
   strbuff := '''';

   open cursr for
    select
       sequencename,    --name                                 seqname
       seqlength,       --number of bps or aas               seqlen
       seqstring,       --dna/aa sequence                      seqstr
       sequencetype,    --type of sequence, eg "genomic DNA"   seqtype
       sequencetopology,--type of sequence, eg "genomic DNA"   seqtop
       createddate      --date record was created              seqdate
    from
       biosequenceob
    where
       obid = biosequenceobid;
    
   fetch cursr into seqname, seqlen, seqstr, seqtype, seqtop, seqdate;

   close cursr;
   
   if (strpos(seqtype,''RNA'') > 0) then
      seqtypeholder = '' bp    RNA'';
   elsif (strpos(seqtype,''DNA'') > 0) then
      seqtypeholder = '' bp    DNA'';
   elsif (strpos(seqtype,''PROTEIN'') > 0) then
      seqtypeholder = '' aa       '';
   else
      seqtypeholder = ''          '';
   end if;

   -- LOCUS       <externalname>
   if (length(seqname)<25) then
      seqbuff := ''LOCUS       ''||rpad(seqname, 25, '' '');
   else 
      seqbuff := ''LOCUS       ''||seqname||'' '';
   end if;
   strbuff := strbuff||seqbuff;
   
   seqbuff := seqlen||
        seqtypeholder||''     ''||
        seqtop||''   ''||
        ''    ''|| --MAM, INV, etc (the genus? e.g. Mammal, Invertebrate - is this recorded?)
        to_char(seqdate, ''DD-MON-YYYY'')||chr(10);
   strbuff := strbuff||seqbuff;

   -- ACCESSION   <externalname>
   seqbuff := ''ACCESSION   ''||seqname||chr(10);
   strbuff := strbuff||seqbuff;

    -- SOURCE      AgResearch
   select into source su.subjectspeciesname 
   from biosubjectob su, biosamplingfunction f, biosampleob sa, sequencingfunction se
   where su.obid = f.biosubjectob
   and f.biosampleob = sa.obid
   and sa.obid = se.biosampleob
   and se.biosequenceob = biosequenceobid;
   
   if FOUND then 
      seqbuff := ''SOURCE      ''||source||chr(10);
      strbuff := strbuff||seqbuff;
   end if;
    
   open cursr for
    select
       speciesname, --speciesVal
       speciestaxid --taxidVal
    from
       geneticlocationfact 
    where
       biosequenceob = biosequenceobid
       and speciestaxid is not null;

   fetch cursr into speciesVal, taxidVal;

   close cursr;
   
   if NOT FOUND then --is this right? Will it do what I want???
      speciesVal := '''';
      taxidVal := '''';
   end if;

   -- TAXON (Source Organism)
   if speciesVal != '''' then
      seqbuff := ''  ORGANISM  ''||speciesVal||chr(10);
      strbuff := strbuff||seqbuff;
   end if;

   open cursr for
     select
        featuretype,    --feature title  feattype
        featurestart,   --start pos      featstart
        featurestop,    --stop pos       featstop
        xreflsid,       --/db_xref=      featxref
        featurecomment, --/note=         featcom
        evidence        --/evidence=     featevid
     from
        biosequencefeaturefact
     where
        biosequenceob = biosequenceobid
     order by
        featurestart,
        featurestop,
        featuretype;
   
   fetch cursr into feattype, featstart, featstop, featxref, featcom, featevid;
   
   -- FEATURES
   if (speciesVal != '''') or FOUND then
      seqbuff := ''FEATURES              Location/Qualifiers''||chr(10);
      strbuff := strbuff||seqbuff;
   end if;

   -- TAXON (Feature)
   if (speciesVal != '''') then
      seqbuff := ''     source           1..''||seqlen||chr(10);
      strbuff := strbuff||seqbuff;
      seqbuff := ''                     /organism="''||speciesVal||''"''||chr(10);
      strbuff := strbuff||seqbuff;
      if (taxidVal != '''') then
          seqbuff := ''                     /db_xref="taxon:''||taxidVal||''"''||chr(10);
          strbuff := strbuff||seqbuff;
      end if;
   end if;

   -- CDS and GENES
   lastfeature := ''blurb'';
   lastseqstart := -1;
   lastseqstop := -1;
   while FOUND loop
      if (feattype <> lastfeature or featstart <> lastseqstart or featstop <> lastseqstop) then
         if featstop >= featstart then
            seqbuff := ''     ''||rpad(feattype,16,'' '')||featstart||''..''||featstop||chr(10);
         else
            seqbuff := ''     ''||rpad(feattype,16,'' '')||''complement(''||featstop||''..''||featstart||'')''||chr(10);
         end if;
         strbuff := strbuff||seqbuff;
         lastfeature := feattype;
         lastseqstart := featstart;
         lastseqstop := featstop;
      end if;
      if (featxref != '''') then
         seqbuff := ''                     /db_xref="''||featxref||''"''||chr(10);
         strbuff := strbuff||seqbuff;
      end if;
      if (featevid != '''') then
         seqbuff := ''                     /evidence="''||featevid||''"''||chr(10);
         strbuff := strbuff||seqbuff;
      end if;
      if (featcom != '''') then
         seqbuff := ''                     /comment="''||featcom||''"''||chr(10);
         strbuff := strbuff||seqbuff;
      end if;
      fetch cursr into feattype, featstart, featstop, featxref, featcom, featevid;
   end loop;

   close cursr;
   
/*   -- COMMENTS formatted into lines of 68 chars plus ''COMMENT     ''
   comments := getAgResearchGenbankComments(seqname,dbname);
   if (length(comments) > 0) then
      seqbuff := rpad(''COMMENT'',12,'' '');
      strbuff := strbuff||seqbuff;
      position := 1;
      basesize := 68;
      while (position <= length(comments)) loop
         seqbuff := substr(comments,position,basesize);
         seqbuff := seqbuff || chr(10);
         strbuff := strbuff||seqbuff;
         position := position + 68;
         if (position < length(comments)) then
            seqbuff := lpad('' '',12,'' '');
            strbuff := strbuff||seqbuff;
         end if;
      end loop;
   end if;*/

   -- ORIGIN
   seqbuff := ''ORIGIN      '';
   strbuff := strbuff||seqbuff;

   if (seqstr is not null) then
      -- <7-9 spaces base number> <6 groups of 10 bases>
      position := 1;
      basesize := 10;
      while (position <= seqlen) loop
         if (mod(position,60) = 1) then
            seqbuff := chr(10)||lpad(to_char(position,''FM99999999''),9,'' '')||'' '';
            strbuff := strbuff||seqbuff;
         end if;
         seqbuff := substr(seqstr,position,basesize);
         seqbuff := seqbuff || '' '';
         strbuff := strbuff||seqbuff;
         position := position + 10;
      end loop;
   end if;

   -- //
   seqbuff := chr(10)||''//''||chr(10);
   strbuff := strbuff||seqbuff;

   return strbuff;
END
'
  LANGUAGE 'plpgsql' VOLATILE;






/*
************************************************************************
* basic dataSourceOb , importProcedureOb and importingFunction tables and dependencies
************************************************************************
* a dataSourceOb represents a source of data that is either imported into the 
* database, or is otherwise associated with a database object.
* 
* For example it could be a CSV file, ACCESS database , or Excel spreadsheet
*
* Or it may be a TIF file which is the ultimate source of the data but 
* is not imported ; or a microarray jpeg which is a summary of the original
* data source.
*
* An importProcedureOb represents an import procedure used to 
* import the data - it should include the script name and any 
* manual processing instructions.
*
* a displayProcedureOb represents a display procedure used to retrieve and 
* display data , such as joeg files.
*
* an importFunction is a relation between a dataSourceOb, a database ob
* ( any ob) , and an importProcedureOb. 
*
*
* a displayFunction is a relation between a dataSourceOb, a database ob (any ob) and
* a displayProcedureOb  
*/
\echo creating dataSourceOb
create table dataSourceOb (
   dataSourceName varchar(1024),
   dataSourceType varchar(256), /* DATASOURCE_TYPES ontology */
   dataSupplier varchar(2048),
   uploadSourceURI varchar(2048),
   physicalSourceURI varchar(2048), /* location of either the file, or directory, in the case of multiple files. */
   dataSuppliedDate date,
   dataSourceComment text,
   dataSourceContent text,   /* static content stored inline */
   dynamicContentMethod varchar(256), /* specify content is to be obtained dynamically at run time, and how to do it (e.g. DHTML etc)*/
   numberOfFiles integer,
   check (obtypeid = 125) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription, displayurl) 
values (125,'Data Source','dataSourceOb','Data Source Ob','datasource.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON dataSourceOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(125);

\echo setting up data source type ontology 
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('DATASOURCE_TYPES','This ontology provides standard terms for data source types','ontology.DATASOURCE_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','CSV' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.Tab delimited text','Tab delimited text' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','ACCESS Database' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','GPRFile' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','GALFile' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.GALFile_noheader','GALFile_noheader' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.FASTA','FASTA' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Other' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.CSV from Affy CEL File','CSV from Affy CEL File' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.ABI Tracefile','ABI Tracefile' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.blastx_agresearch_csv','blastx_agresearch_csv' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.blastn_agresearch_csv','blastn_agresearch_csv' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.blastx_agresearch_csv_nokeywords','blastx_agresearch_csv_nokeywords' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.454 SFF File','454 SFF File' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.megablast_D3','megablast_D3' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.blastx_agresearch_csv_moderated','blastx_agresearch_csv_moderated' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.blastn_agresearch_csv_moderated','blastn_agresearch_csv_moderated' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.paralignprot','paralignprot' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';


insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.SQL','SQL' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.SQL (no header)','SQL (no header)' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';


insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.interpro_csv','interpro_csv' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.Excel Spreadsheet','Excel Spreadsheet' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.AgResearchArrayExport1','AgResearchArrayExport1' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.GFF','GFF' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_TYPES.Contributed Database Table','Contributed Database Table' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.Assembly ACE File','Assembly ACE File' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.R Workspace','R Workspace' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.ACE File Zip Archive','ACE File Zip Archive' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.Form Element','Form Element' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.Executable','Executable' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.Executable ; Raw Download','Executable ; Raw Download' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';


insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.ABI Tracefile Zip Archive','ABI Tracefile Zip Archive' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.Parameter','Parameter' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.R Targets File','R Targets File' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.Python data','Python data' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.CAP3 Assembly Zip Archive','CAP3 Assembly Zip Archive' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.blastx_orthoblast','blastx_orthoblast' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.blastn_orthoblast','blastn_orthoblast' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.PickleFile','PickleFile' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.Textfile Report Output','Textfile Report Output' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.DATASOURCE_TYPES.GBS Keyfile','GBS Keyfile' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';

commit;


\echo attaching ontology check. 
CREATE FUNCTION checkDataSourceOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.dataSourceType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''DATASOURCE_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid datasource type '', NEW.dataSourceType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkDataSourceOntology BEFORE INSERT OR UPDATE ON dataSourceOb
    FOR EACH ROW EXECUTE PROCEDURE checkDataSourceOntology();



/*
* this table provides storage for general additional attributes
* of a dataSource
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(126,'DataSource Details','dataSourceFact',FALSE,'DataSource Details',TRUE,'datasource.gif');
\echo creating dataSourceFact
create table dataSourceFact (
   dataSourceOb integer not null references dataSourceOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 126,   obtypeid,   'dataSourceOb' from obtype where  upper(tablename) = 'DATASOURCEOB';


CREATE OR REPLACE FUNCTION getdatasourcecharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        datasourceobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from datasourcefact 
      where datasourceob = datasourceobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



CREATE OR REPLACE FUNCTION getdatasourceimportdate(int4)
  RETURNS "date" AS
'
    DECLARE
      datecursor refcursor;
      datasourceobid ALIAS for $1;
      myimportdate date;
    BEGIN
      open datecursor for
      select max(createddate) from importfunction
      where datasourceob = datasourceobid ;

      fetch datecursor into myimportdate;
      close datecursor;
      return myimportdate;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;




create table importProcedureOb (
   procedureName varchar(1024),
   author varchar(2048),
   authordate date,
   sourceCode text,
   procedureComment text,
   importDataSourceInvocation text,
   displayDataSourceInvocation text,
   check (obtypeid = 130) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription) 
values (130,'Import Procedure','importProcedureOb','Import Procedure');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON importProcedureOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(130);



\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop)
values(135, 'Data Import','importFunction',TRUE,'Data Import',TRUE);
\echo creating importFunction
create table importFunction (
   ob integer,
   dataSourceOb integer not null references dataSourceOb(obid),
   importProcedureOb integer not null references importProcedureOb(obid),
   importErrors text,
   processingInstructions text,
   notificationAddresses text,
   submissionReasons text,
   functioncomment varchar(1024),
   check(obtypeid = 135) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 135,   obtypeid,   'Ob' from obtype where  upper(tablename) = 'OB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 135,   obtypeid,   'dataSourceOb' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 135,   obtypeid,   'importProcedureOb' from obtype where  upper(tablename) = 'IMPORTPROCEDUREOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON importFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(135);

\echo creating checkImportObKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkImportObKey() RETURNS trigger AS '
    BEGIN
        select obid into NEW.ob from ob where obid = NEW.ob;
        if not FOUND then
           RAISE EXCEPTION ''checkimportobkey : key error - obid not found'';
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkImportObKey BEFORE INSERT OR UPDATE ON importFunction
    FOR EACH ROW EXECUTE PROCEDURE checkImportObKey();



/*
* this table provides storage for general additional attributes
* of an import - such as checksums etc
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(385,'Import Details','importFunctionFact',FALSE,'Import Details',TRUE,'ob.gif');
\echo creating importFunctionFact
create table importFunctionFact (
   importFunction integer not null references importFunction(obid),
   factNameSpace varchar(256),
   attributeDate date,
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 385,   obtypeid,   'importFunction' from obtype where  upper(tablename) = 'IMPORTFUNCTION';


CREATE OR REPLACE FUNCTION getimportcharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        importobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from importfunctionfact 
      where importfunction = importobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;





/********* no longer required **********
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop)
values(135, 'LabResource Data Import','labResourceImportFunction',TRUE,'LabResource Data Import',TRUE);
\echo creating labResource  importFunction
create table labResourceImportFunction (
   labResourceOb integer not null references labResourceOb(obid),
   dataSourceOb integer not null references dataSourceOb(obid),
   importProcedureOb integer not null references importProcedureOb(obid),
   importErrors text,
   functioncomment varchar(1024),
   check(obtypeid = 135) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 135,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 135,   obtypeid,   'dataSourceOb' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 135,   obtypeid,   'importProcedureOb' from obtype where  upper(tablename) = 'IMPORTPROCEDUREOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON labResourceImportFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(135);
******************/



/***************************************
* misc datasourceob dependencies (that really belong above)
****************************************/

/*
* this is similar to the sequencing function relation. The sequencing relation connects
* samples directly to sequences. While this connects a library to a data source - i.e. to 
* an imported data file.
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop)
values(500, 'Library Sequencing Run','librarySequencingFunction',TRUE,'Library Sequencing Run',TRUE);
\echo creating librarySequencingFunction
create table librarySequencingFunction (
   bioLibraryOb integer references bioLibraryOb(obid),
   dataSourceOb integer not null references dataSourceOb(obid),
   bioprotocolob integer references bioprotocolob(obid),
   labResourceList integer references labResourceList(obid),
   labResourceOb integer references labResourceOb(obid),
   runBy varchar(256),
   runDate date,
   functioncomment varchar(1024),
   check(obtypeid = 500) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 500,   obtypeid,   'bioLibraryOb' from obtype where  upper(tablename) = 'BIOLIBRARYOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 500,   obtypeid,   'dataSourceOb' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 500,   obtypeid,   'bioprotocolob' from obtype where  upper(tablename) = 'BIOPROTOCOLOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 500,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 500,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON librarySequencingFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(500);

/*
* this table provides storage for general additional attributes
* of a sequencingFunction - i.e. of the actual sequencing process, not the 
* sample itself. 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(530,'Library Sequencing Details','librarySequencingFact',FALSE,'Library Sequencing Details',TRUE);
\echo creating library sequencing Fact
create table librarySequencingFact (
   librarySequencingFunction integer not null references librarySequencingFunction(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 530,   obtypeid,   'librarySequencingFunction' from obtype where  upper(tablename) = 'LIBRARYSEQUENCINGFUNCTION';



/*********************** 
* display procedures
***********************/


create table displayProcedureOb (
   procedureName varchar(1024),
   author varchar(2048),
   authordate date,
   sourceCode text,
   proceduredescription varchar(1024),
   procedureComment text,
   invocation text,
   check (obtypeid = 140) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription) 
values (140,'Display Procedure','displayProcedureOb','Display Procedure');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON displayProcedureOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(140);


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription, isop)
values(145, 'Data Display','displayFunction',TRUE,'Display Function',TRUE);
\echo creating displayFunction
create table displayFunction (
   ob integer not null,
   dataSourceOb integer references dataSourceOb(obid),
   displayProcedureOb integer not null references displayProcedureOb(obid),
   functioncomment varchar(1024),
   invocation text,
   invocationorder integer,
   check(obtypeid = 145) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 145,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 145,   obtypeid,   'dataSourceOb' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 145,   obtypeid,   'displayProcedureOb' from obtype where  upper(tablename) = 'DISPLAYPROCEDUREOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON displayFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(145);


\echo creating checkDisplayFunctionObKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkDisplayFunctionObKey() RETURNS trigger AS '
    BEGIN
        select obid into NEW.ob from ob where obid = NEW.ob;
        if not FOUND then
           RAISE EXCEPTION ''checkdisplayfunctionobkey : key error - obid not found'';
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkDisplayFunctionObKey BEFORE INSERT OR UPDATE ON displayFunction
    FOR EACH ROW EXECUTE PROCEDURE checkDisplayFunctionObKey();


/*
**********************************
Analysis procedures and functions
**********************************
An analysis function is a relationship between one or more datasources - a datasource list - and 
a display procedure.

This enables a given procedure - for example, some R code , to be attached to a given 
database object and executed when the page for that object is displayed.


The datasources in the datasourcelist may be of several types - e.g.

* DATASOURCE_TYPES.Tab delimited text
* SQL Query
* report

An analysis procedure is attached to an object, and any data sources it requires,
by creating a record in the analysisfunction table.

The brdf system will choose an appropriate handler for the analysis function call - for 
example if the procedure type is "R procedure" , then the handler method, 
in the analysisProcedures module , will be runRProcedure. This will  

1. perform any datasource marshalling that is required, as specified by the datasourcelist. 
   For example in the case of  a series of SQL queries - run each query and write to a temporary file

2. parse the presentationTemplate, and calculate any output filenames
   required for mixed / multimedia output.

   Currently it is assumed that the instantiated template will be
   rendered in-line in an HTML document - i.e. it just consists of an
   HTML fragment.

   Here is an example template : 

   <!----- begin -------/>
   <pre>
   __stdout__     # stdout will be merged here
   </pre>

   <pre>
   __stderr__     # stderr will be merged here
   <pre>


   <pre>
   __myout1__     # output file 1 will be merged here
   <pre>

   <pre>
   __myout2__     # output file 2 will be merged here
   <pre>


   <img src=__mypng1__/>
   <img src=__mypng2__/>

   <!----- end --------/>


for example , the combination of the datasource list, and the presentation template, 
may cause the following R invocation to be compiled

./runRProcedure.sh ./myanalysis.r datasource1 datasource2 textout1.txt textout2.txt 14323.png 56765.png 

- the runRprocedure will have marshalled the indicated datasources ; the R code will 
output to the supplied file names ; the runRprocedure will return an instantiated presentationTemplate
to the caller, merging stdout and stderr , and opening the text output to merge into the template as indicated, and 
replace the image file-name placeholders with the actual temporary file names
*/


insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('ANALYSIS_PROCEDURE_TYPES','This ontology provides standard terms for analysis procedure types','ontology.ANALYSIS_PROCEDURE_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ANALYSIS_PROCEDURE_TYPES.R procedure','R procedure' from ontologyOb where ontologyName = 'ANALYSIS_PROCEDURE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ANALYSIS_PROCEDURE_TYPES.Java jar procedure','Java jar procedure' from ontologyOb where ontologyName = 'ANALYSIS_PROCEDURE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ANALYSIS_PROCEDURE_TYPES.SQL Query','SQL Query' from ontologyOb where ontologyName = 'ANALYSIS_PROCEDURE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ANALYSIS_PROCEDURE_TYPES.python script','python script' from ontologyOb where ontologyName = 'ANALYSIS_PROCEDURE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ANALYSIS_PROCEDURE_TYPES.perl script','perl script' from ontologyOb where ontologyName = 'ANALYSIS_PROCEDURE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ANALYSIS_PROCEDURE_TYPES.executable','executable' from ontologyOb where ontologyName = 'ANALYSIS_PROCEDURE_TYPES';




create table analysisProcedureOb (
   procedureName varchar(1024),
   author varchar(2048),
   authordate date,
   sourceCode text,
   proceduredescription varchar(1024),
   procedureComment text,
   procedureType varchar(64),
   invocation text,
   presentationTemplate text,
   textincount integer,
   textoutcount integer,
   imageoutcount integer,
   textintypes integer,
   textouttypes varchar(1024),
   imageouttypes varchar(1024),
   check (obtypeid = 540) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription, displayurl) 
values (540,'Data Analysis Procedure','analysisProcedureOb','analysis Procedure','analysis.jpg');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON analysisProcedureOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(540);


/*
* this table provides storage for general additional attributes
* of an analysis Procedure
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(560,'Analysis Procedure Details','analysisProcedureFact',FALSE,'Analysis Procedure Details',TRUE);
\echo creating analysisProcedureFact
create table analysisProcedureFact (
   analysisProcedureOb integer not null references analysisProcedureOb(obid),
   factNameSpace varchar(256),
   attributeDate date,
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 560,   obtypeid,   'analysisProcedureOb' from obtype where  upper(tablename) = 'ANALYSISPROCEDUREOB';


\echo attaching ontology check. 
CREATE FUNCTION checkAnalysisTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.procedureType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''ANALYSIS_PROCEDURE_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid analysis procedure type '', NEW.procedureType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkAnalysisTypeOntology BEFORE INSERT OR UPDATE ON analysisProcedureOb
    FOR EACH ROW EXECUTE PROCEDURE checkAnalysisTypeOntology();



insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('DATASOURCE_LIST_TYPES','This ontology provides standard terms for data source list types','ontology.DATASOURCE_LIST_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATASOURCE_LIST_TYPES','Data Form' from ontologyOb where ontologyName = 'DATASOURCE_LIST_TYPES';



\echo creating dataSourceList
create table dataSourceList (
   listName varchar(256) not null,
   maxMembership integer,
   listComment varchar(1024),
   listtype varchar(128),
   check (obtypeid = 550) ,
   unique (obid) )
   inherits(ob) 
   without oids;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription,displayurl) 
values (550,'Data Source List','dataSourceList','Data Source List','datasource.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON dataSourceList
    FOR EACH ROW EXECUTE PROCEDURE setObType(550);


\echo attaching ontology check. 
CREATE or replace FUNCTION checkDatasourceListTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        if NEW.ListType is not null then 
           select into terms  * from ontologytermfact where termname = NEW.ListType and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''DATASOURCE_LIST_TYPES'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid datasource list type '', NEW.ListType;
           else
              return NEW;
           end if;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkDatasourceListTypeOntology BEFORE INSERT OR UPDATE ON datasourcelist
    FOR EACH ROW EXECUTE PROCEDURE checkDatasourceListTypeOntology();


/*
* this table provides storage for general additional attributes
* of a data source list - such as database binding
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(585,'DataSource List Details','dataSourceListFact',FALSE,'Datasource List Details',TRUE);
\echo creating dataSourceListFact
create table dataSourceListFact (
   dataSourceList integer not null references dataSourceList(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 585,   obtypeid,   'dataSourceList' from obtype where  upper(tablename) = 'DATASOURCELIST';




\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(555,'Datasource List Membership','dataSourceListMembershipLink',FALSE, 'Datasource List Membership',TRUE);
\echo creating dataSourcelistMembershipLink
create table dataSourceListMembershipLink (
   dataSourceList integer not null references dataSourceList(obid),
   dataSourceOb integer not null references dataSourceOb(obid),
   inclusionComment varchar(64),  
   listorder integer,
   addedDate date DEFAULT now(),
   addedBy varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 555,   obtypeid,   'dataSourceList' from obtype where  upper(tablename) = 'DATASOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 555,   obtypeid,   'dataSourceOb' from obtype where  upper(tablename) = 'DATASOURCEOB';


/*
* return a single concatenating facts from all data source objects in a list
*/
create or replace function concatDatasourceFacts(integer, varchar, varchar) returns "text" as
'
   declare 
      mylist alias for $1;
      mynamespace alias for $2;
      myattributename alias for $3;
      result text;
   begin
      select agg_newline_concat(df.attributevalue) into result 
      from 
      datasourcelistmembershiplink dl join datasourcefact df on
      df.datasourceob = dl.datasourceob
      where
      dl.datasourcelist = mylist ;
      return result;
   end;
'
language 'plpgsql' volatile;

/*
* a named link function , for applications where we need
* to qualify the inclusion. For example form elements
*  - where we need to add attributes such as database binding
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(575,'Datasource Named List Membership','dataSourceNamedListMembershipLink',TRUE, 'dataSourceNamedListMembershipLink',TRUE);
\echo creating dataSourceNamedlistMembershipLink
create table dataSourceNamedListMembershipLink (
   dataSourceList integer not null references dataSourceList(obid),
   dataSourceOb integer not null references dataSourceOb(obid),
   inclusionComment varchar(64),  
   listorder integer,
   check(obtypeid = 575) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 575,   obtypeid,   'dataSourceList' from obtype where  upper(tablename) = 'DATASOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 575,   obtypeid,   'dataSourceOb' from obtype where  upper(tablename) = 'DATASOURCEOB';
CREATE TRIGGER setObType BEFORE INSERT ON dataSourceNamedListMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(575);


/*
* this table provides storage for general additional attributes
* of a data source membership link - such as database binding
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(580,'Named List Membership Details','dataSourceNamedListMembershipLinkFact',FALSE,'Named List Membership Details',TRUE);
\echo creating dataSourceNamedListMembershipLinkFact
create table dataSourceNamedListMembershipLinkFact (
   dataSourceNamedListMembershipLink integer not null references dataSourceNamedListMembershipLink(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 580,   obtypeid,   'dataSourceNamedListMembershipLink' from obtype where  upper(tablename) = 'DATASOURCENAMEDLISTMEMBERSHIPLINK';

CREATE OR REPLACE FUNCTION getdsnamedlistlinkfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        linkobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from dataSourceNamedListMembershipLinkFact 
      where dataSourceNamedListMembershipLink = linkobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription, isop,displayurl)
values(545, 'Data analysis','analysisFunction',TRUE,'Data analysis',TRUE,'analysis.jpg');
\echo creating analysisFunction
create table analysisFunction (
   ob integer not null,
   dataSourceList integer references dataSourceList(obid),
   dataSourceOb integer references dataSourceOb(obid),
   dataSourceDescriptors text,
   analysisProcedureOb integer not null references analysisProcedureOb(obid),
   functioncomment varchar(1024),
   invocation text,
   invocationorder integer,
   invokeon varchar(64) default 'USER SELECT' 
   check(obtypeid = 545) ,
   check(invokeon in ('USER SELECT','PAGE DISPLAY')),
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 545,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 545,   obtypeid,   'dataSourceList' from obtype where  upper(tablename) = 'DATASOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 545,   obtypeid,   'analysisProcedureOb' from obtype where  upper(tablename) = 'ANALYSISPROCEDUREOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON analysisFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(545);


\echo creating checkanalysisFunctionObKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkanalysisFunctionObKey() RETURNS trigger AS '
    BEGIN
        select obid into NEW.ob from ob where obid = NEW.ob;
        if not FOUND then
           RAISE EXCEPTION ''checkanalysisfunctionobkey : key error - obid not found'';
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkanalysisFunctionObKey BEFORE INSERT OR UPDATE ON analysisFunction
    FOR EACH ROW EXECUTE PROCEDURE checkanalysisFunctionObKey();



/*
********************************************************
Security procedures and functions
********************************************************
*/


insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription) 
values (460,'Security Procedure','securityProcedureOb','Security Procedure');
create table securityProcedureOb (
   procedureName varchar(1024),
   author varchar(2048),
   authordate date,
   sourceCode text,
   proceduredescription varchar(1024),
   procedureComment text,
   invocation text,
   check (obtypeid = 460) ,
   unique (obid)) 
   inherits (ob)
   without oids;
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON securityProcedureOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(460);


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription, isop)
values(465, 'Security Function','securityFunction',TRUE,'Security Function',TRUE);
\echo creating securityFunction
-- entries can record the application of a security policy to a whole object type (via 
-- the applytotype field), or to individual object instances.
-- to apply a policy to all objects, set applytotype = 0
create table securityFunction (
   ob integer ,
   applytotype integer references obtype(obtypeid),
   securityProcedureOb integer not null references securityProcedureOb(obid),
   functioncomment varchar(1024),
   invocation text,
   invocationorder integer,
   check(obtypeid = 465) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 465,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 465,   obtypeid,   'securityProcedureOb' from obtype where  upper(tablename) = 'SECURITYPROCEDUREOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON securityFunction
    FOR EACH ROW EXECUTE PROCEDURE setObType(465);


\echo creating checkSecurityFunctionObKey (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkSecurityFunctionObKey() RETURNS trigger AS '
    BEGIN
        if NEW.ob is not null then
	        select obid into NEW.ob from ob where obid = NEW.ob;
        	if not FOUND then
           	RAISE EXCEPTION ''checksecurityfunctionobkey : key error - obid not found'';
        	end if;
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkSecurityFunctionObKey BEFORE INSERT OR UPDATE ON securityFunction
    FOR EACH ROW EXECUTE PROCEDURE checkSecurityFunctionObKey();


/*
****************************
Staff lists as used to define roles
****************************
*/
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription,displayurl) 
values (470,'Staff List','staffList','Staff List','ob.gif');
create table staffList (
   listName varchar(256) not null,
   listDefinition text,
   listComment varchar(1024),
   check (obtypeid = 470) ,
   unique (obid) )
   inherits(ob)
   without oids;
\echo initialising obtype

\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON staffList
    FOR EACH ROW EXECUTE PROCEDURE setObType(470);



insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(475,'staffListMembershipLink','staffListMembershipLink',TRUE, 'staffListMembershipLink',TRUE);
\echo creating staffListMembershipLink
create table staffListMembershipLink (
   staffList integer not null references staffList(obid),
   staffOb integer not null references staffOb(obid),
   addedDate date DEFAULT now(),
   addedBy varchar(256),   
   membershipcomment varchar(1024), 
   check(obtypeid = 475),
   unique(obid))
   inherits(op) 
   without oids;
\echo initialising optypesignature
insert into optypesignature (obtypeid, argobtypeid, optablecolumn)
select 475, obtypeid, 'staffList' from obtype where upper(tablename) = 'STAFFLIST';
insert into optypesignature (obtypeid, argobtypeid, optablecolumn)
select 475, obtypeid, 'staffOb' from obtype where upper(tablename) = 'STAFFOB';
CREATE TRIGGER setObType BEFORE INSERT ON staffListMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE setObType();






/*
********************************************************
Set up Phenotype study and observation tables
********************************************************
*/
/*
* set up the phenotype study table
*/
create table phenotypeStudy (
   studyName varchar(1024) not null,
   phenotypeOntologyName varchar(256) default 'MYPHENOTYPE',
   studyDescription text,
   studyDate date,
   check (obtypeid = 150) ,
   unique (obid) )
   inherits(op)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription,isop) 
values (150,'Phenotype Study','phenotypeStudy','Phenotype study',TRUE);
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON phenotypeStudy
    FOR EACH ROW EXECUTE PROCEDURE setObType(150);
\echo attaching check on valid ontology name 


CREATE FUNCTION checkPhenotypeOntologyName() RETURNS trigger AS '
    DECLARE
        names RECORD;
    BEGIN
        if NEW.phenotypeOntologyName is not null then
           select into names  * from ontologyOb where ontologyName = NEW.phenotypeOntologyName;
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid phenotype ontology '', NEW.phenotypeOntologyName;
           else
              return NEW;
           end if;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkPhenotypeOntologyName BEFORE INSERT OR UPDATE ON phenotypeStudy
    FOR EACH ROW EXECUTE PROCEDURE checkPhenotypeOntologyName();


/*
* set up the phenotypeObservation table - it is an op
* linking a bioSample with a phenotypeStudy.
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(155,'Phenotype Observation','phenotypeObservation',TRUE, 'Phenotype Observation',TRUE);
\echo creating phenotypeObservation
create table phenotypeObservation (
   bioSampleOb integer references bioSampleOb(obid),
   bioSampleList integer references bioSampleList(obid),
   bioSubjectOb integer references bioSubjectOb(obid),
   phenotypestudy integer not null references phenotypeStudy(obid),
   phenotypeNameSpace varchar(1024),
   phenotypeTerm varchar(2048),
   phenoTypeRawScore float,
   phenoTypeAdjustedScore float,
   observationComment text,
   observationDate date,
   check(obtypeid = 155),
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 155,   obtypeid,   'bioSubjectOb' from obtype where  upper(tablename) = 'BIOSUBJECTOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 155,   obtypeid,   'phenotypeStudy' from obtype where  upper(tablename) = 'PHENOTYPESTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 155,   obtypeid,   'bioSampleOb' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 155,   obtypeid,   'bioSampleList' from obtype where  upper(tablename) = 'BIOSAMPLELIST';


\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON phenotypeObservation
    FOR EACH ROW EXECUTE PROCEDURE setObType(155);

\echo setting up phenotype ontology 
insert into ontologyob(ontologyName,   ontologyDescription , xreflsid)
values('MYPHENOTYPE','This ontology provides standard local terms for phenotypes','ontology.MYPHENOTYPE');


insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Angiogenesis', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Ballooning', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Edema', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Angiogenesis', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Entercyte loss', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Fibrin exudation', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Granulomas', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Hyperplasia', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Lymphangiectasis', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Monocytes', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Mucosal atrophy', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'ontology.term','Neutrophils', 'Gut tissue histology term' from ontologyOb 
where ontologyName = 'MYPHENOTYPE';



commit;
\echo attaching ontology check. 
CREATE FUNCTION checkPhenotypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
        myontologyob integer;
    BEGIN
        -- check if we have an ontology, if not no check
        select into myontologyob obid from ontologyOb where ontologyName = (
             select phenotypeOntologyName from phenotypeStudy where obid = NEW.phenotypestudy);

        if not FOUND then
           return NEW;
        end if;


        select into terms  * from ontologytermfact where termname = NEW.phenotypeTerm and 
                       ontologyob = myontologyob;

        if not FOUND then
           RAISE EXCEPTION ''% is not a valid phenotype term '', NEW.phenotypeTerm;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkPhenotypeOntology BEFORE INSERT OR UPDATE ON phenotypeObservation
    FOR EACH ROW EXECUTE PROCEDURE checkPhenotypeOntology();




/*
********************************************************
Set up Survey study and observation tables
********************************************************
*/
/*
* set up the survey study table
*/
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription, isop, displayurl) 
values (510,'Survey Study','surveyStudy','Survey Study',TRUE, 'survey.jpg');
create table surveyStudy (
   studyName varchar(1024) not null,
   labResourceOb integer not null references labResourceOb(obid),
   studyDate date,
   check (obtypeid = 510) ,
   unique (obid) )
   inherits(op)
   without oids ;
\echo initialising obtype
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 510,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';

\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON surveyStudy
    FOR EACH ROW EXECUTE PROCEDURE setObType(510);


/*
* return a single string of all the survey's on file for a subject
for a subject
*/
create or replace function getSubjectSurveys(integer) returns "text" as
'
   declare 
      myob alias for $1;
      result text;
   begin
      select agg_comma_concat(resourcename) into result from 
          (select distinct 
          lr.resourcename from
          ((surveyobservation so join surveystudy ss on  
          so.surveystudy = ss.obid) join labresourceob lr on 
          lr.obid = ss.labresourceob ) where
          so.biosubjectob = myob) as surveys;
          return result;
   end;
'
language 'plpgsql' volatile;


/*
* set up the surveyObservation table - it is an op
* linking a bioSubject with a surveyStudy.
4/5/2010 added formSection - in some cases it is not enough to know which form (=lab resource) a 
question is from , as the form may be multi-part, and the questions coming through in the 
import are appropriately named within an id that includes the section
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(520,'Survey Observation','surveyObservation',TRUE, 'Survey Observation',TRUE);
\echo creating surveyObservation
create table surveyObservation (
   bioSubjectOb integer references bioSubjectOb(obid),
   surveyStudy integer not null references surveyStudy(obid),
   observationComment text,
   rawDataRecord text,
   formSection varchar(128),
   observationDate date,
   check(obtypeid = 520),
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 520,   obtypeid,   'bioSubjectOb' from obtype where  upper(tablename) = 'BIOSUBJECTOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 520,   obtypeid,   'surveyStudy' from obtype where  upper(tablename) = 'SURVEYSTUDY';


\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON surveyObservation
    FOR EACH ROW EXECUTE PROCEDURE setObType(520);




/*
* set up the surveyFact table - this hangs off a surveyObservation and provides parsed fields from 
* the raw data record 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(525,'Survey Question','surveyQuestionFact',FALSE, 'Survey Question',TRUE);
\echo creating survey Question Fact
create table surveyQuestionFact (
   surveyObservation  integer references surveyObservation(obid),
   formSection varchar(128),
   question varchar(2048),
   answer text,
   answercode varchar(2048),
   answerstatus varchar(32))
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 525,   obtypeid,   'surveyObservation' from obtype where  upper(tablename) = 'SURVEYOBSERVATION';



CREATE OR REPLACE FUNCTION getsurveyanswer(int4, "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        answercursor refcursor;
        observationobid ALIAS for $1;
        myquestion ALIAS for $2;
        myanswer varchar;
    BEGIN
      myanswer := null;
      open answercursor for 
      select trim(answer) from surveyQuestionFact   
      where surveyObservation = observationobid and   
      question = myquestion ;

      fetch answercursor into myanswer;
      close answercursor;
      return myanswer;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;


/*
* example : 
select getsubjectsurveyanswer(7175126,'surveyform.Risk Factor Survey Form Version 1','rf 64.bedroomsadol');
select getsubjectsurveyanswer(7175126,'surveyform.Crohns Disease Clinical Data Form v6 14-11-07','sex');
*/
CREATE OR REPLACE FUNCTION getsubjectsurveyanswer(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        answercursor refcursor;
        subjectobid ALIAS for $1;
        formlsid ALIAS for $2;
        myquestion ALIAS for $3;
        myanswer varchar;
    BEGIN
      myanswer := null;
      open answercursor for 
      select trim(sqf.answer) from
      ((surveyobservation so join surveystudy ss on 
      so.biosubjectob = subjectobid and 
      so.surveystudy = ss.obid) join 
      labresourceob l on l.obid = ss.labresourceob and
      l.xreflsid = formlsid) join surveyQuestionFact sqf
      on sqf.surveyobservation = so.obid and
      sqf.question = myquestion ;

      fetch answercursor into myanswer;
      close answercursor;
      return myanswer;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



/*
* example : 
select getsubjectsurveyanswer(7175126,'surveyform.Risk Factor Survey Form Version 1');
select getsubjectsurveyanswer(7175126,'surveyform.Crohns Disease Clinical Data Form v6 14-11-07');
*/
CREATE OR REPLACE FUNCTION getsubjectsurveyid(int4, "varchar")
  RETURNS "int4" AS
'
    DECLARE
        idcursor refcursor;
        subjectobid ALIAS for $1;
        formlsid ALIAS for $2;
        myid integer;
    BEGIN
      myid := null;
      open idcursor for 
      select so.obid from
      ((surveyobservation so join surveystudy ss on 
      so.biosubjectob = subjectobid and 
      so.surveystudy = ss.obid) join 
      labresourceob l on l.obid = ss.labresourceob and
      l.xreflsid = formlsid)  ;

      fetch idcursor into myid;
      close idcursor;
      return myid;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;

/*
* example :
 
select getsubjectsurveyanswercount(136,'surveyform.IBD Diet Survey Questionnaire Version 3','biscuithomemade','3 both');
select getsubjectsurveyanswer(136,'surveyform.IBD Diet Survey Questionnaire Version 3','biscuithomemade');
                             

*/
CREATE OR REPLACE FUNCTION getsubjectsurveyanswercount(int4, "varchar", "varchar","varchar")
  RETURNS "int4" AS
'
    DECLARE
        answercountcursor refcursor;
        subjectobid ALIAS for $1;
        formlsid ALIAS for $2;
        myquestion ALIAS for $3;
        myanswer alias for $4;
        mycount int4;
    BEGIN
      mycount := null;
      open answercountcursor for 
      select count(*)  from
      ((surveyobservation so join surveystudy ss on 
      so.biosubjectob = subjectobid and 
      so.surveystudy = ss.obid) join 
      labresourceob l on l.obid = ss.labresourceob and
      l.xreflsid = formlsid) join surveyQuestionFact sqf
      on sqf.surveyobservation = so.obid and
      sqf.question = myquestion and
      upper(trim(sqf.answer)) = upper(trim(myanswer));

      fetch answercountcursor into mycount;
      close answercountcursor;
      return mycount;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;




/*
************************************************************************************************************************
* set up suite of genetic tables
*
* geneticOb , geneticObList, geneticLocationFact, geneticLocationList , geneticFunctionFact , geneticExpressionFact, geneticFact,
* geneProductLink
************************************************************************************************************************
*
* These tables provide a homologene-centric schema for storing a list of gene objects in the central 
* geneticOb table, then with various types of fact about a genetic object stored in a series of fact 
* tables, in a star schema. 
*
* Objects such as gene families are stored as lists
* of geneticobs - i.e. geneticObList - rather than as geneticObs ; however a set of paralogs
* with identical expression and function may be stored as a single geneticOb, with multiple
* locations if this is suitable for the task at hand. 
*
* A geneticOb itself is a location-less genetic object, and corresponds to a comparative genetic entity 
* that has been inherited and has evolved, and is now represented by descendants in multiple species 
* or maybe multiple copies in a single species, which all have a common ancestor. 
* 
* A genetic object is any genetic feature which persists and evolves over time - any may be a gene,
* an exon , an SSR or even a single base pair, if we are able to trace the ancestry of that 
* base pair.
*
* GeneticObs are linked to bioSequences via geneProduct and geneRegulation links
*
* The geneticLocationFact stored location facts about a gene or sequence. Note that
* it was decided to have the geneticlocationfact table carry with it information about
* the map version to refer to , rather than normalise this out to a seperate table
*
* Note also that it was decided not to use an alternative design fact , whereby 
* genetic locations are set up as objects and maybe be associated with more than 
* one sequence , or gene. Thus a given location can be used only by a single gene record
* (or a single sequence record)
*
* This is because location facts are treated as essentially as coordinates , and we
* do not normalise these coordinates , in the same way that we do not normalise (say)
* home addresses in a database of people, or geometric coordinates
*
* 
*/


create table geneticOb (
   geneticObName varchar(256),
   geneticObType varchar(256), /* based on sequence ontology */
   geneticObDescription text,
   geneticObsymbols varchar(2048),
   obcomment varchar(2048),
   check (obtypeid = 160) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription, displayurl) 
values (160,'Genetic Feature','geneticOb','Genetic Feature','genes.jpg');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(160);

\echo setting up ontology for geneticOb types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('GENETICOB_ONTOLOGY','This ontology provides standard terms for the types of Genetic Object that may be stored in the geneticOb table','ontology.GENETICOB_ONTOLOGY');
\echo initialising geneticob ontology with interim term names - NB not final ontology
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Gene' from ontologyOb where ontologyName = 'GENETICOB_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.GENETICOB_ONTOLOGY.Homologene','Homologene' from ontologyOb where ontologyName = 'GENETICOB_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','SNP' from ontologyOb where ontologyName = 'GENETICOB_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','QTL' from ontologyOb where ontologyName = 'GENETICOB_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','SSR Marker' from ontologyOb where ontologyName = 'GENETICOB_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Pseudogene' from ontologyOb where ontologyName = 'GENETICOB_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','CDS' from ontologyOb where ontologyName = 'GENETICOB_ONTOLOGY';


commit;


\echo attaching ontology check. 
CREATE FUNCTION checkGeneticObOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.geneticObType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''GENETICOB_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid genetic ob type '', NEW.geneticObType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkGeneticObOntology BEFORE INSERT OR UPDATE ON geneticOb
    FOR EACH ROW EXECUTE PROCEDURE checkGeneticObOntology();



insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('GENETIC_LIST_TYPES','This ontology provides standard names for types of genetic list','ontology.GENETIC_LIST_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.GENETIC_LIST_TYPES.REGULATORY PATHWAY','REGULATORY PATHWAY' from ontologyOb where  ontologyName = 'GENETIC_LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.GENETIC_LIST_TYPES.METABOLIC PATHWAY','METABOLIC PATHWAY' from ontologyOb where  ontologyName = 'GENETIC_LIST_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.GENETIC_LIST_TYPES.CANDIDATE GENE LIST','CANDIDATE GENE LIST' from ontologyOb where  ontologyName = 'GENETIC_LIST_TYPES';

commit;

\echo creating geneticObList
create table geneticObList (
   listName varchar(256) not null,
   listType varchar(128),
   listDefinition text,
   bookMark integer,
   maxMembership integer,
   currentMembership integer default 0,
   listComment varchar(1024),
   displayURL varchar(2048) default 'ob.gif',
   membershipvisibility varchar(32) default 'public',
   check (obtypeid = 165) ,
   unique (obid) )
   inherits(ob)
   without oids;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription,displayurl) 
values (165,'Genetic List','geneticObList','Genetic List','genes.jpg');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticObList
    FOR EACH ROW EXECUTE PROCEDURE setObType(165);

\echo attaching ontology check 
CREATE FUNCTION checkGeneticListOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.listType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''GENETIC_LIST_TYPES'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid genetic list type '', NEW.listType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkGeneticListOntology BEFORE INSERT OR UPDATE ON geneticObList
    FOR EACH ROW EXECUTE PROCEDURE checkGeneticListOntology();


/*
* this table provides storage for general additional attributes
* of a genetic list 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(430,'Genetic List Details','geneticoblistfact',FALSE,'Genetic List Details',TRUE,'ob.gif');
\echo creating geneticoblistFact
create table geneticoblistfact (
   geneticOblist integer not null references geneticOblist(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 430,   obtypeid,   'geneticOblist' from obtype where  upper(tablename) = 'GENETICOBLIST';



/*********mod 19/2/2007 to use obids as below.
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(170,'geneticObListMembershipLink','geneticObListMembershipLink',FALSE, 'geneticObListMembershipLink',TRUE);
\echo creating geneticObListMembershipLink
create table geneticObListMembershipLink (
   geneticObList integer not null references geneticObList(obid),
   geneticOb integer not null references geneticOb(obid),
   inclusionComment varchar(64), 
   addedDate date DEFAULT now(),
   addedBy varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (obtypeid, argobtypeid, optablecolumn)
select 170, obtypeid, 'geneticObList' from obtype where upper(tablename) = 'GENETICOBLIST';
**************/
/*********mod 19/2/2007 to use obids *******/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(170,'geneticObListMembershipLink','geneticObListMembershipLink',TRUE, 'geneticObListMembershipLink',TRUE);
\echo creating geneticObListMembershipLink
create table geneticObListMembershipLink (
   geneticObList integer not null references geneticObList(obid),
   geneticOb integer not null references geneticOb(obid),
   geneticObxreflsid varchar(2048), 
   addedDate date DEFAULT now(),
   addedBy varchar(256),   
   listorder integer DEFAULT nextval('listorderseq') ,   
   membershipcomment varchar(64), 
   check(obtypeid = 170),
   unique(obid))
   inherits(op) 
   without oids;
\echo initialising optypesignature
insert into optypesignature (obtypeid, argobtypeid, optablecolumn)
select 170, obtypeid, 'geneticObList' from obtype where upper(tablename) = 'GENETICOBLIST';
CREATE TRIGGER setObType BEFORE INSERT ON geneticObListMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(170);


/*
* a table to store attributes of the membership of a gene in a gene list - e.g. , why is it in the list ? 
* who added it , priority etc
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(425,'Genetic list membership annotation','geneticoblistmembershiplinkfact',FALSE,'Genetic list membership annotation',TRUE,'ob.gif');
\echo creating geneticoblistmembershiplinkfact
create table geneticoblistmembershiplinkfact (
   geneticObListMembershipLink integer not null references geneticObListMembershipLink(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 425,   obtypeid,   'geneticObListMembershipLink' from obtype where  upper(tablename) = 'GENETICOBLISTMEMBERSHIPLINK';







/****
*** deprecated
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(186,'geneticLocationSequenceLink','geneticLocationSequenceLink',FALSE, 'geneticLocationSequenceLink',TRUE);
\echo creating geneticLocationSequenceLink
create table geneticLocationSequenceLink (
   geneticLocationFact integer not null references geneticLocationFact(obid),
   bioSequenceOb integer not null references bioSequenceOb(obid),
   sequencingComment varchar(64),  /* e.g. forward primer, reverse primer etc */
   addedDate date DEFAULT now(),
   addedBy varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 186,   obtypeid,   'geneticLocationFact' from obtype where  upper(tablename) = 'GENETICLOCATIONFACT';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 186,   obtypeid,   'bioSequenceOb' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
*/





\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop,displayurl)
values(190,'Genetic Function','geneticFunctionFact',TRUE,'Genetic Function',TRUE,'genes.jpg');
\echo creating geneticFunctionFact
create table geneticFunctionFact (
   geneticOb integer not null references geneticOb(obid),
   GOTerm varchar(2048),
   GODescription varchar(2048),
   functionDescription varchar(2048),
   functionComment text,
   check(obtypeid = 190) )
   inherits(op) 
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 190,   obtypeid,   'geneticOb' from obtype where  upper(tablename) = 'GENETICOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticFunctionFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(190);



/**** Thsi table is soon to be deprecated - a different design based on expression maps is being used
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop,displayurl)
values(195,'Genetic Expression','geneticExpressionFact',TRUE,'Genetic Expression',TRUE,'genes.jpg');
\echo creating geneticExpressionFact
create table geneticExpressionFact (
   geneticOb integer not null references geneticOb(obid),
   GOTerm varchar(2048),
   GODescription varchar(2048),
   tissueType varchar(256),
   lifeCycleStage varchar(256),
   cellularLocalisation varchar(256),
   microarrayExperimentLSID varchar(2048),
   microarrayExperimentResultDescription text,
   expressionComment text,
   check(obtypeid = 195) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 195,   obtypeid,   'geneticOb' from obtype where  upper(tablename) = 'GENETICOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticExpressionFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(195);
*****/



/*
* this table records information about gene expression - such as by tissue, life cycle stage, time etc
*
* this is treated as a series of expression "maps". Map names are stored in the 
* system as ontologies, and the terms in these ontologies provided the items on the 
* axes - e.g each term might be a tissue library , life-cycle stage etc
*
* expression information can also be recorded about a sequence
*
* In addition , there is a virtual fact type - sequenceExpressionFact- that 
* uses this table.
*
* Thus the geneticExpressionFact table looks like a relation between 
* a geneticOb and a bioSequenceOb - but it is not. It is just that the 
* same fact type can be attached to different types of object , and that a virtual 
* fact type (sequence location) also uses this table
*
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop,displayurl)
values(195,'Genetic Expression','geneticExpressionFact',TRUE,'Genetic Expression',TRUE,'genes.jpg');
\set up a virtual sequence loction fact - this is used (e.g.) to store the location of sequences on a contig
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, isVirtual, displayurl)
values(196,'Sequence Expression','geneticExpressionFact',TRUE,'Sequence Expression',TRUE, TRUE, 'genes.jpg');

\echo creating geneticExpressionFact
create table geneticExpressionFact (
   geneticOb integer references geneticOb(obid),
   bioSequenceOb integer references bioSequenceOb(obid),
   expressionMapName varchar(2048),                      -- there should be an ontology with this name
   expressionMapLocus varchar(128),                      -- each locus should be listed in the ontology
   speciesName varchar(256),                             -- a locus is a tissue name, lifecycle stage, time , etc
   speciestaxid integer,
   expressionAmount float,
   evidence text,
   evidencepvalue float,
   check(obtypeid = 195), 
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 195,   obtypeid,   'geneticob' from obtype where  upper(tablename) = 'GENETICOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 196,   obtypeid,   'biosequenceob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticExpressionFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(195);






/***** This table is now deprecated
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(196,'Genetic Variation','geneticVariationFact',TRUE,'Genetic Variation',TRUE);
\echo creating geneticVariationFact
create table geneticVariationFact (
   geneticOb integer not null references geneticOb(obid),
   genoType text,
   variantComment text,
   check(obtypeid = 196) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 196,   obtypeid,   'geneticOb' from obtype where  upper(tablename) = 'GENETICOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticVariationFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(196);
******/



\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(200,'Genetic Fact','geneticFact',TRUE,'Genetic Fact',TRUE);
\echo creating geneticFact
create table geneticFact (
   geneticOb integer not null references geneticOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096),
   check(obtypeid = 200) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 200,   obtypeid,   'geneticOb' from obtype where  upper(tablename) = 'GENETICOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(200);




\echo setting up ontology for geneProductLink types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('GENEPRODUCTLINK_ONTOLOGY','This ontology provides standard terms for the gene productlink types of gene product link records','ontology.GENEPRODUCTLINK_ONTOLOGY');
\echo initialising geneproductlink ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','spliced transcript' from ontologyOb where ontologyName = 'GENEPRODUCTLINK_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','protein' from ontologyOb where ontologyName = 'GENEPRODUCTLINK_ONTOLOGY';
commit;


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(201,'Gene Product Link','geneProductLink',TRUE,'GeneProductLink',TRUE);
\echo creating geneProductLink
create table geneProductLink (
   geneticOb integer not null references geneticOb(obid),
   bioSequenceOb integer not null references bioSequenceOb(obid),
   productType varchar(1024),
   evidence text,
   productComment text,
   check(obtypeid = 201) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 201,   obtypeid,   'geneticOb' from obtype where  upper(tablename) = 'GENETICOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 201,   obtypeid,   'bioSequenceOb' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneProductLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(201);



\echo setting up ontology for geneRegulationLink types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('GENEREGULATIONLINK_ONTOLOGY','This ontology provides standard terms for the gene regulation link types of gene regulation link records','ontology.GENEREGULATIONLINK_ONTOLOGY');
\echo initialising gene regulation ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','promotor' from ontologyOb where ontologyName = 'GENEREGULATIONLINK_ONTOLOGY';
commit;

\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(202,'Gene Regulation Link','geneRegulationLink',TRUE,'GeneRegulationLink',TRUE);
\echo creating geneRegulationLink
create table geneRegulationLink (
   geneticOb integer not null references geneticOb(obid),
   bioSequenceOb integer not null references bioSequenceOb(obid),
   regulationType varchar(1024),
   evidence text,
   regulationComment text,
   check(obtypeid = 202) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 202,   obtypeid,   'geneticOb' from obtype where  upper(tablename) = 'GENETICOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 202,   obtypeid,   'bioSequenceOb' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneRegulationLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(202);




/*
* not sure about this table !

\echo setting up ontology for homologyLink types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('HOMOLOGY_ONTOLOGY','This ontology provides standard terms for the types of homology','ontology.HOMOLOGY_ONTOLOGY');
\echo initialising homology ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','paralog' from ontologyOb where ontologyName = 'HOMOLOGYLINK_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','ortholog' from ontologyOb where ontologyName = 'HOMOLOGYLINK_ONTOLOGY';
commit;

\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(203,'Homolog Link','homologLink',TRUE,'Homolog Link',TRUE);
\echo creating homologLink
create table homologLink (
   fromGeneticOb integer not null references geneticOb(obid),
   toGeneticOb integer not null references geneticOb(obid),
   homologyType varchar(512),
   evidence text,
   homologyComment text,
   check(obtypeid = 203) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 203,   obtypeid,   'fromGeneticOb' from obtype where  upper(tablename) = 'GENETICOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 203,   obtypeid,   'toGeneticOb' from obtype where  upper(tablename) = 'GENETICOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON homologyLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(203);

\echo attaching ontology check. 
CREATE FUNCTION checkHomologyOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.homologyType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''HOMOLOGY_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid homology type '', NEW.homologyType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkHomologyOntology BEFORE INSERT OR UPDATE ON homologLink
    FOR EACH ROW EXECUTE PROCEDURE checkHomologyOntology();

*/




/*
************************************************************************************************************************
* set up suite of genotype related tables.
*
* The model for genotyping is an analogue of the model for microarrays :
*
* - a genotype study is a relation between a sample, a labresource and a protocol
*
* the lab resource is either a single marker or something like a SNP chip
*
* geneticTestFacts give information about the individual markers
*
* a genotype observation relates a study to a marker and contains the 
* results for that marker
*
*
* Note that we may need to distinguish markers in this sense , from sequence tagged 
* sites that are not polymorphic
*
*
************************************************************************************************************************ 
*/

/*
********************************************************
Set up Genotype study and observation tables
********************************************************
*/
/*
* set up the Genotype study table
*/
\echo setting up ontology for genotype study types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('GENOTYPESTUDY_ONTOLOGY','This ontology provides standard terms for the types of genotype  studies','ontology.GENOTYPESTUDY_ONTOLOGY');
\echo initialising genotype study ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','SNP Marker' from ontologyOb where ontologyName = 'GENOTYPESTUDY_ONTOLOGY';
commit;
\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,displayurl)
values(290, 'Genotype Study','genotypeStudy',TRUE,'Genotype Study',TRUE,'snp.png');
\echo creating genotypeStudy
create table genotypeStudy (
   bioSampleList integer references bioSampleList(obid),
   bioSampleOb integer references bioSampleOb(obid),
   labResourceList integer references labResourceList(obid),
   labResourceOb integer references labResourceOb(obid),
   bioProtocolOb integer not null references bioProtocolOb(obid),
   studyType varchar(128),
   check(obtypeid = 290),
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 290,   obtypeid,   'biosamplelist' from obtype where  upper(tablename) = 'BIOSAMPLELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 290,   obtypeid,   'biosampleob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 290,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 290,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 290,   obtypeid,   'bioProtocolOb' from obtype where  upper(tablename) = 'BIOPROTOCOLOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON genotypeStudy
    FOR EACH ROW EXECUTE PROCEDURE setObType(290);
\echo attaching ontology check. 
CREATE FUNCTION checkGenotypeStudyTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.studyType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''GENOTYPESTUDY_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid studytype term '', NEW.studyType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkenotypeStudyTypeOntology BEFORE INSERT OR UPDATE ON genotypeStudy
    FOR EACH ROW EXECUTE PROCEDURE checkGenotypeStudyTypeOntology();



/*
* this table provides storage for general additional attributes
* of a genotypestudy
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(295,'Genotype Study Fact','genotypeStudyFact',FALSE,'Genotype Study Fact',TRUE);
\echo creating genotypeStudyFact
create table genotypeStudyFact (
   genotypeStudy integer not null references genotypeStudy(obid),
   factNameSpace varchar(256),
   attributeDate date,
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 295,   obtypeid,   'genotypeStudy' from obtype where  upper(tablename) = 'GENOTYPESTUDY';


/*
* a genetic Test is modelled as a labResource. A geneticTestFact is attached to the labResource table
*/
\echo setting up ontology for genetic test facts
insert into ontologyob(ontologyName,   xreflsid, ontologyDescription )
values('GENETICTEST_ONTOLOGY','ontology.GENETICTEST_ONTOLOGY','This ontology provides standard terms for the types of genetic tests');
\echo initialising genetic test ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','SNP' from ontologyOb where ontologyName = 'GENETICTEST_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'GENETICTEST_ONTOLOGY.EPIGENOTYPE-METHYLATION-SEQUENOME','EPIGENOTYPE-SEQUENOME' from ontologyOb where ontologyName = 'GENETICTEST_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'GENETICTEST_ONTOLOGY.EPIGENOTYPE-METHYLATION-BISULFITE-SEQUENCING','EPIGENOTYPE-METHYLATION-BISULFITE-SEQUENCING' from ontologyOb where ontologyName = 'GENETICTEST_ONTOLOGY';


commit;
\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(305,'Genetic Test','geneticTestFact',TRUE,'Genetic Test',TRUE,'snp.png');
\echo creating geneticTestFact
create table geneticTestFact (
   labResourceOb integer not null references labResourceOb(obid),
   accession       varchar(256),
   testType varchar(1024),
   locusName varchar(256),
   testdescription text,
   variation varchar(1024),
   check(obtypeid = 305) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 305,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticTestFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(305);
\echo attaching ontology check. 
CREATE FUNCTION checkGeneticTestOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.testType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''GENETICTEST_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid testtype  '', NEW.testType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkGeneticTestOntology BEFORE INSERT OR UPDATE ON geneticTestFact
    FOR EACH ROW EXECUTE PROCEDURE checkGeneticTestOntology();


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(480,'Genetic Test Details','geneticTestFact2',FALSE,'Genetic Test Details',TRUE,'snp.png');
\echo creating geneticTestFact2
create table geneticTestFact2 (
   geneticTestFact integer not null references geneticTestFact(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 480,   obtypeid,   'geneticTestFact' from obtype where  upper(tablename) = 'GENETICTESTFACT';



CREATE OR REPLACE FUNCTION getgenetictestfact2char(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        factid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from genetictestfact2 
      where genetictestfact = factid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;





/*
* set up the genotypeObservation table - it is an op
* linking a genotypeStudy with a geneticTestFact
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(300,'genotypeObservation','genotypeObservation',TRUE, 'genotypeObservation',TRUE,'snp.png');
\echo creating genotypeObservation
create table genotypeObservation (
   genotypeStudy integer references genotypeStudy(obid),
   geneticTestFact integer references geneticTestFact(obid),
   observationDate date,
   genotypeObserved varchar(256),
   genotypeObservedDescription varchar(1024),
   finalGenotype varchar(256),
   finalGenotypeDescription varchar(1024),
   observationComment text,
   check(obtypeid = 300),
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 300,   obtypeid,   'genotypeStudy' from obtype where  upper(tablename) = 'GENOTYPESTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 300,   obtypeid,   'geneticTestFact' from obtype where  upper(tablename) = 'GENETICTESTFACT';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON genotypeObservation
    FOR EACH ROW EXECUTE PROCEDURE setObType(300);


/*
* this table provides storage for general additional attributes
* of a genotypeobservation
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(310,'Genotype Observation Fact','genotypeObservationFact',FALSE,'Genotype Observation Fact',TRUE);
\echo creating genotypeObservationFact
create table genotypeObservationFact (
   genotypeObservation integer not null references genotypeObservation(obid),
   factNameSpace varchar(256),
   attributeDate date,
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 310,   obtypeid,   'genotypeObservation' from obtype where  upper(tablename) = 'GENOTYPEOBSERVATION';




/*
* set up the epigenotypeObservation table - it is an op
* linking a genotypeStudy with a geneticTestFact
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(660,'epiGenotypeObservation','epigenotypeObservation',TRUE, 'epigenotypeObservation',TRUE,'epigenotype.jpg');
\echo creating epiGenotypeObservation
create table epiGenotypeObservation (
   genotypeStudy integer references genotypeStudy(obid),
   geneticTestFact integer references geneticTestFact(obid),
   observationDate date,
   epigenotypeObserved double precision,
   genotypeObservedDescription varchar(2048),
   observationComment text,
   check(obtypeid = 660),
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 660,   obtypeid,   'genotypeStudy' from obtype where  upper(tablename) = 'GENOTYPESTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 660,   obtypeid,   'geneticTestFact' from obtype where  upper(tablename) = 'GENETICTESTFACT';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON epiGenotypeObservation
    FOR EACH ROW EXECUTE PROCEDURE setObType(660);


/*
* this table provides storage for general additional attributes
* of an epigenotypeobservation
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(665,'EpiGenotype Observation Fact','epiGenotypeObservationFact',FALSE,'EpiGenotype Observation Fact',TRUE);
\echo creating epiGenotypeObservationFact
create sequence egof_factidseq;
create table epiGenotypeObservationFact (
   factid integer  DEFAULT nextval('egof_factidseq') primary key,   
   epiGenotypeObservation integer not null references epiGenotypeObservation(obid),
   factNameSpace varchar(256),
   attributeDate date,
   attributeName varchar(256),
   attributeValue varchar(4096))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 665,   obtypeid,   'epiGenotypeObservation' from obtype where  upper(tablename) = 'EPIGENOTYPEOBSERVATION';




/*
* Set up location fact table 
* Note that location facts can be attached to a number of 
* different objects - genes, genetic tests
* 
* In addition , there is a virtual fact type - sequenceLocationFact- that 
* uses this table.
*
* Thus the geneticLocationFact table looks like a relation between 
* a geneticOb ,  a bioSequenceOb and a geneticTestFact - but it is not. It is just that the 
* same fact type can be attached to different types of object , and that a virtual 
* fact type (sequence location) also uses this table
* 
* 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(175,'Genetic Location','geneticLocationFact',TRUE,'Genetic Location',TRUE);

-- set up a virtual sequence loction fact - this is used (e.g.) to store the location of sequences on a genome or species
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, isVirtual)
values(176,'Sequence Location','geneticLocationFact',TRUE,'Sequence Location',TRUE, TRUE);


-- set up a virtual genetic test location fact - this is used (e.g.) to store the location of a genetic test
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, isVirtual)
values(177,'Genetic Test Location','geneticLocationFact',TRUE,'Genetic Test Location',TRUE, TRUE);

-- set up a virtual sequence-contig loction fact - this is used (e.g.) to store the location of sequences on a contig that is
-- in the database
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, isVirtual)
values(178,'Contig Location','geneticLocationFact',TRUE,'Contig Location',TRUE, TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 178,   obtypeid,   'biosequenceob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 178,   obtypeid,   'mapobid' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';







\echo creating geneticLocationFact
create table geneticLocationFact (
   geneticOb integer references geneticOb(obid),
   bioSequenceOb integer references bioSequenceOb(obid),
   geneticTestFact integer references geneticTestFact(obid),
   mapName varchar(2048),
   mapobid integer references bioSequenceOb(obid),
   mapType varchar(2048) default 'sequence',
   mapUnit varchar(128) default 'bases',
   speciesName varchar(256),
   speciestaxid integer,
   entrezgeneid integer,
   locusName varchar(256),
   locusTag varchar(128),
   locusSynonyms varchar(2048),
   chromosomeName varchar(32),
   strand varchar(3),
   locationstart numeric(12),
   locationstop numeric(12),
   locationString varchar(2048),
   regionSize numeric(12),
   markers varchar(2048),
   locationDescription varchar(2048),
   othermaplocation1 varchar(128),
   evidence text,
   evidenceScore float,
   evidencepvalue float,
   check(obtypeid = 175), 
   check(mapType in ('linkage','rh','sequence','physical')),
   check(mapUnit in ('centiMorgans','bases')),
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 175,   obtypeid,   'geneticob' from obtype where  upper(tablename) = 'GENETICOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 176,   obtypeid,   'biosequenceob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 177,   obtypeid,   'genetictestfact' from obtype where  upper(tablename) = 'GENETICTESTFACT';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticLocationFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(175);


\echo creating geneticLocationList
create table geneticLocationList (
   listName varchar(256) not null,
   maxMembership integer,
   listComment varchar(1024),
   check (obtypeid = 180) ,
   unique (obid) )
   inherits(ob)
   without oids ;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription) 
values (180,'GeneticLocation List','geneticLocationList','GeneticLocation List');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneticLocationList
    FOR EACH ROW EXECUTE PROCEDURE setObType(180);


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(185,'geneticLocationListMembershipLink','geneticLocationListMembershipLink',FALSE, 'geneticLocationListMembershipLink',TRUE);
\echo creating geneticLocationListMembershipLink
create table geneticLocationListMembershipLink (
   geneticLocationList integer not null references geneticLocationList(obid),
   geneticLocationFact integer not null references geneticLocationFact(obid),
   inclusionComment varchar(64),  /* e.g. forward primer, reverse primer etc */
   addedDate date DEFAULT now(),
   addedBy varchar(256))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 185,   obtypeid,   'geneticLocationList' from obtype where  upper(tablename) = 'GENETICLOCATIONLIST';



/*
* function to retrieve location details such as locusname, given 
* geneid and taxid
*/
create or replace function getGeneLocationDetail(integer, integer, text) returns varchar VOLATILE AS '
declare
   detailcursor refcursor;
   geneid alias for $1;
   taxid alias for $2;
   detailname alias for $3;
   detailresult varchar;
begin
   detailresult := null;
   if lower(detailname) = ''locusname'' then
      open detailcursor for
      select locusname from geneticlocationfact where
      geneticob = geneid and
      speciestaxid = taxid ;
      fetch detailcursor into detailresult;
      close detailcursor; 
   end if;

   if detailresult = '''' then
      detailresult := null;
   end if;

   return detailresult;
end;
' LANGUAGE plpgsql;


/*
* function to assemble a string of synonyms for a gene 
*/
create or replace function getGeneSynonyms(integer) returns varchar VOLATILE AS '
declare
   syncursor refcursor;
   geneid alias for $1;
   syn varchar;
   synresult varchar;
   sep varchar;
begin
   synresult := '''';
   sep := '''';

   open syncursor for 
      select otf.termname
      from
      predicatelink p join ontologytermfact otf on
      p.subjectob = geneid and p.predicate = ''PROVIDES_NOMENCLATURE'' and
      p.predicatecomment like ''Link to aliases%'' and
      otf.ontologyob = p.objectob;

   fetch syncursor into syn;
   while FOUND loop
      synresult := synresult || sep || syn;
      sep := '' ; '';
      fetch syncursor into syn;
   end loop;

   close syncursor;

   if synresult = '''' then
      synresult := null;
   end if;
   
   return synresult;
end;
' LANGUAGE plpgsql;








/*
*************************************************************
*
* Workflow tables. A WorflowOb is a master for a series of WorkStageObs. WorkStageObs
* are connected to a workFlowOb by workFlowMembership links ( stage can potentially be 
* a member of more than one workflow) , and to each other by  
* workFlowLink records  - i.e. these represent the actual flow pattern of the 
* workflow. Together these define the design of the workflow.
* 
* Each instance of a workflowStage being visited - i.e. actual instances of 
* these - is stored in a workStageVisitFact table, recording who, when and 
* comments
*
***************************************************************
*/


\echo creating workflowob
create table workFlowOb (
   workFlowName varchar(256),
   workFlowDescription varchar(2048),
   workFlowComment text
   check (obtypeid = 205) ,
   primary key  (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription, displayurl) 
values (205,'Workflow Object','workFlowOb','workFlowOb','workflow.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON workFlowOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(205);


\echo setting up ontology for workstage types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('WORKFLOW_ONTOLOGY','This ontology provides standard terms for the types of stages in workflows','ontology.WORKFLOW_ONTOLOGY');
\echo initialising workflow ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Process' from ontologyOb where ontologyName = 'WORKFLOW_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','DataSource' from ontologyOb where ontologyName = 'WORKFLOW_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Analysis' from ontologyOb where ontologyName = 'WORKFLOW_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Decision' from ontologyOb where ontologyName = 'WORKFLOW_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Datastore' from ontologyOb where ontologyName = 'WORKFLOW_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Annotation' from ontologyOb where ontologyName = 'WORKFLOW_ONTOLOGY';

commit;

\echo creating workstageob
create table workFlowStageOb (
   workFlowStageName varchar(256),
   workFlowStageType varchar(64),
   workFlowStageDescription varchar(2048),
   work text,
   workFlowStageComment text
   check (obtypeid = 210) ,
   primary key (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription,displayurl) 
values (210,'Workflow Stage','workFlowStageOb','workFlowStageOb','workflow.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON workFlowStageOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(210);



\echo attaching ontology check. 
CREATE FUNCTION checkWorkFlowOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.workFlowStageType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''WORKFLOW_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid workflow stage type '', NEW.workFlowStageType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkWorkFlowOntology BEFORE INSERT OR UPDATE ON workFlowStageOb
    FOR EACH ROW EXECUTE PROCEDURE checkWorkFlowOntology();


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop,displayurl)
values(225,'Workflow Details','workStageVisitFact',TRUE,'workStageVisitFact',TRUE,'workflowstage.gif');
\echo creating workStageVisitFact
create sequence wsvf_factidseq;
create table workStageVisitFact (
   factid integer  DEFAULT nextval('wsvf_factidseq') primary key,   
   workFlowStage integer not null references workFlowStageOb(obid),
   workflow integer references workFlowOb(obid),
   workName varchar(256),
   workDoneBy varchar(256),
   WorkDoneDate date,
   work text,
   workComment text,
   check(obtypeid = 225) ,
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 225,   obtypeid,   'workFlowStage' from obtype where  upper(tablename) = 'WORKFLOWSTAGEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON workStageVisitFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(225);


/*
* this method returns the id of the latest visit to a workflow stage - e.g.
* this can be used to obtain the latest snapshot
*/
CREATE FUNCTION getLatestWorkStageVisit(varchar) RETURNS integer as '
DECLARE
   worklsid alias for $1;
   curs refcursor;
   latestvisit integer;
BEGIN
   open curs for 
   select 
      obid
   from
      workstagevisitfact
   where
      workflowstage = (select obid from workflowstageob where xreflsid = worklsid)
   order by 
      workdonedate desc;
   fetch curs into latestvisit;
   close curs;
   
   return latestvisit;
END;
' LANGUAGE plpgsql;



/*
* this method returns the id of the latest visit to a workflow stage - e.g.
* this can be used to obtain the latest snapshot
*/
CREATE FUNCTION getLatestWorkStageVisitName(varchar) RETURNS varchar as '
DECLARE
   worklsid alias for $1;
   curs refcursor;
   latestvisit varchar;
BEGIN
   open curs for 
   select 
      workname 
   from
      workstagevisitfact
   where
      obid = getLatestWorkStageVisit(worklsid);
   fetch curs into latestvisit;
   close curs;
   
   return latestvisit;
END;
' LANGUAGE plpgsql;





\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,displayurl)
values(215, 'WorkFlow Membership Link','workFlowMembershipLink',TRUE,'Workflow Membership Link',TRUE,'workflow.gif');
\echo creating workFlowMembershipLink
create table workFlowMembershipLink (
   workFlowOb integer not null references workFlowOb(obid),
   workFlowStageOb integer not null references workFlowStageOb(obid),
   workfloworder float,
   membershipComment varchar(1024),
   check(obtypeid = 215),
   primary key(obid)  )
   inherits(op) 
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 215,   obtypeid,   'workFlowOb' from obtype where  upper(tablename) = 'WORKFLOWOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 215,   obtypeid,   'workFlowStageOb' from obtype where  upper(tablename) = 'WORKFLOWSTAGEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON workFlowMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(215);


/*
* deprecated 
*
*\echo initialising obtype
*insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,displayurl)
*values(220, 'WorkFlowLink','workFlowLink',TRUE,'WorkFlowLink',TRUE,'workflow.gif');
*\echo creating workFlowLink
*create table workFlowLink (
*   fromStage integer not null references workFlowStageOb(obid),
*   toStage integer not null references workFlowStageOb(obid),
*   workComment varchar(1024),
*   check(obtypeid = 220),
*   unique(obid)  )
*   inherits(op)
*   without oids ;
*alter table workFlowLink add primary key(obid);
*\echo initialising optypesignature
*insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
*select 220,   obtypeid,   'fromStage' from obtype where  upper(tablename) = 'WORKFLOWSTAGEOB';
*insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
*select 220,   obtypeid,   'toStage' from obtype where  upper(tablename) = 'WORKFLOWSTAGEOB';
*\echo attaching trigger
*CREATE TRIGGER setObType BEFORE INSERT ON workFlowLink
*    FOR EACH ROW EXECUTE PROCEDURE setObType(220);
*/




/********************
* genotype snapshots
*********************/



/*
* this table provides storage for snap-shot of genotypes
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop, displayurl)
values(87,'Genotype Snapshot','genotypeSnapshotFunction',FALSE,'Genotype Snapshot',TRUE, 'snapshot.jpg');
\echo creating genotypeSnapshotFunction
create sequence gssh_functionidseq;
create table genotypeSnapshotFunction (
   factid integer  DEFAULT nextval('gssh_functionidseq') primary key, 
   bioSubjectOb integer not null references bioSubjectOb(obid),
   snplsid varchar(2048) not null,
   labresourceob integer references labresourceob(obid),
   workstagevisitfact integer not null references workstagevisitfact(obid),
   genotype varchar(256),
   genotypeCount integer,
   genotypeConcordance float)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 87,   obtypeid,   'bioSubjectOb' from obtype where  upper(tablename) = 'BIOSUBJECTOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 87,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 87,   obtypeid,   'workStageVisitFact' from obtype where  upper(tablename) = 'WORKSTAGEVISITFACT';



CREATE OR REPLACE FUNCTION getgenotypesnapshot("int4", "int4","int4", "varchar")
  RETURNS "varchar" AS
' 
    DECLARE
        finalgenotypecursor refcursor;
        argsubject ALIAS for $1;
        arggenetictest ALIAS for $2;
        argsnapshot ALIAS for $3;
        argrequest ALIAS for $4;
        genotypeinfo varchar(64);
    BEGIN
        if upper(trim(argrequest)) = ''GENOTYPE'' then
           genotypeinfo := null;
           open finalgenotypecursor for 
           select 
              genotype 
           from 
              genotypeSnapshotFunction
           where
              biosubjectob = argsubject and
              labresourceob = arggenetictest and
              workstagevisitfact = argsnapshot;              

           fetch finalgenotypecursor into genotypeinfo;


           close finalgenotypecursor;

        elsif upper(trim(argrequest)) = ''COUNT'' then
           genotypeinfo := null;
           open finalgenotypecursor for 
           select 
              to_char(genotypecount,''999999'')  
           from 
              genotypeSnapshotFunction
           where
              biosubjectob = argsubject and
              labresourceob = arggenetictest and
              workstagevisitfact = argsnapshot;              

           fetch finalgenotypecursor into genotypeinfo;

           close finalgenotypecursor;

        else
           genotypeinfo := ''unsupported request : '' || argrequest;
        end if;

        return genotypeinfo;

    END;
'
  LANGUAGE 'plpgsql' VOLATILE;




/*
*
*********************************************************************
* Gene Expression
*********************************************************************
* 
*
* The geneExpressionStudy is a relation between
*
* 
- a bioSampleList (core schema)
- a labResourceList (core schema)
- an analysisOb (nunz schema)
*
* geneExpressionStudies include microarray, realtime PCR
*
*
* For example , for a microarray study, each microarray is recorded in the 
* labResourceOb table - there is not a specific microarray table.
*, however there is a microarrayFact table linked to the labResourceTable,
* and each spot on the microarray is recorded as a fact record in the microarraySpotFact table
*, also linked to the master record in the labResourceOb table 
*
* A microarrayObservation table is a link  between a geneExpressionStudy and a 
* a microarraySpotFact table and contains the normalised logratios - after the analysis 
* recorded in the analysisOp.
*
* an RTPCRObservation table is a link between a geneExpressionStudy and a 
* RTPCRLabResource entry
*
*
* Microarray studies have additional fact tables attached such as
* miameFact - information about the experiment as per MIAME, including 
the header section of GPR file
*
*/
/*
* Set up the microarray entry in the ontology of lab resources
*/
\echo updating labResource table for microarray resource
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','microarray' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','GALFile' from ontologyOb where ontologyName = 'DATASOURCE_TYPES';
commit;


/*
* microarrayFact table attached to the labResourceOb table
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(230,'Microarray','microarrayFact',TRUE,'Microarray',TRUE,'microarray.jpg');
\echo creating microarrayFact
create table microarrayFact (
   labResourceOb integer not null references labResourceOb(obid),
   arrayName varchar(256),
   arrayComment varchar(2048),
   GAL_Type varchar(256),
   GAL_BlockCount integer,
   GAL_BlockType integer,
   GAL_URL varchar(512),
   GAL_Supplier varchar(512),
   GAL_Block1 varchar(512)
   check(obtypeid = 230), 
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 230,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON microarrayFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(230);

/*
* microarraySpotFact table attached to the labResourceOb table
*/
\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(235,'Microarray Spot','microarraySpotFact',TRUE,'Microarray Spot',TRUE,'spot.jpg');
\echo creating microarraySpotFact
create table microarraySpotFact (
   labResourceOb integer not null references labResourceOb(obid),
   accession       varchar(256),
   blocknumber     integer,
   blockrow        integer,
   blockcolumn     integer,
   metarow         integer,
   metacolumn      integer,
   spotcomment     varchar(2048),
   GAL_Block integer,
   GAL_Column integer,
   GAL_Row integer,
   GAL_Name varchar(256),
   GAL_ID varchar(128),
   GAL_RefNumber integer,
   GAL_ControlType varchar(32),
   GAL_GeneName varchar(128),
   GAL_TopHit varchar(256),
   GAL_Description varchar(2048),
   genesymbol varchar(64),
   spottype varchar(64),
   check(obtypeid = 235) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 235,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON microarraySpotFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(235);
CREATE TRIGGER filterKeywords BEFORE INSERT OR UPDATE ON microarraySpotFact
    FOR EACH ROW EXECUTE PROCEDURE filterKeywords(obkeywords);



\echo setting up ontology for workstage types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('MICROARRAY_SPOT_ONTOLOGY','This ontology provides standard terms for the types of spot on a microarray','ontology.MICROARRAY_SPOT_ONTOLOGY');
\echo initialising  ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'microarray_spot_ontology.probe','probe' from ontologyOb where ontologyName = 'MICROARRAY_SPOT_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'microarray_spot_ontology.whole array','whole array' from ontologyOb where ontologyName = 'MICROARRAY_SPOT_ONTOLOGY';






/*
* 7/2011 gelSpotFact table attached to the labResourceOb table. A Gelspotfact refers to a spot on a reference gel. In general a spot may 
* be associated with more than 1 protein
*
* links to protein sequences (and hence proteomics info such as isoelectricpoint etc), is maintained by 
* a typed entry in the predicateLink table (see type 266))

*/
\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(655,'Protein Reference Gel Spot','proteinReferenceGelSpotFact',TRUE,'Protein Reference Gel Spot',TRUE,'gelspot.jpg');
\echo creating proteinReferenceGelSpotFact
create table proteinReferenceGelSpotFact (
   labResourceOb integer not null references labResourceOb(obid),
   spotnumber      integer,
   spotname 	   varchar(128),
   spotposition    varchar(256),
   spotComment	   text,
   check(obtypeid = 655) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 655,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON proteinReferenceGelSpotFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(655);
CREATE TRIGGER filterKeywords BEFORE INSERT OR UPDATE ON proteinReferenceGelSpotFact
    FOR EACH ROW EXECUTE PROCEDURE filterKeywords(obkeywords);


\echo setting up ontology for workstage types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('PROTEIN_GELSPOT_ONTOLOGY','This ontology provides standard terms for the types of gel spot on a reference gel','ontology.PROTEIN_GELSPOT_ONTOLOGY');
\echo initialising  ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'PROTEIN_GELSPOT_ONTOLOGY.single spot','single spot' from ontologyOb where ontologyName = 'PROTEIN_GELSPOT_ONTOLOGY';



/*
* 
a gene expression study relates :

- a bioSampleList (core schema)

   for example a two colour experiment will involve two samples

- a labResourceList (core schema)

   the array is a labResource

- an bioProtocolOb (core schema), recording the normalisation method used.

*/
\echo setting up ontology for gene expression study types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('GENEEXPRESSIONSTUDYTYPE_ONTOLOGY','This ontology provides standard terms for the types of gene expression  studies','ontology.GENEEXPRESSIONSTUDYTYPE_ONTOLOGY');
\echo initialising workflow ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','treated vs untreated microarray' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','time course microarray' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','dose response microarray' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','knock-out response microarray' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','insertion response microarray' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','mutant response microarray' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','phenotype contrast microarray' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','other microarray' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';

/* 
* changes 7/2011 to support protein gels : 

* add term to expression study type ontology
* added notes on how to link images to a study - no changes to db, however 
  collecting together this documentation here now

*/
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY.gel based protein expression','gel based protein expression' from ontologyOb where ontologyName = 'GENEEXPRESSIONSTUDYTYPE_ONTOLOGY';


commit;
\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,displayurl)
values(240, 'Gene Expression Study','geneExpressionStudy',TRUE,'Gene Expression Study',TRUE,'microarray.jpg');
\echo creating geneExpressionStudy
create table geneExpressionStudy (
   bioSampleList integer not null references bioSampleList(obid),
   labResourceList integer references labResourceList(obid),
   labResourceOb integer references labResourceOb(obid),
   bioProtocolOb integer references bioProtocolOb(obid),
   studyName varchar(128),
   studyType varchar(128),
   studydescription text,
   check(obtypeid = 240),
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 240,   obtypeid,   'biosamplelist' from obtype where  upper(tablename) = 'BIOSAMPLELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 240,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 240,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 240,   obtypeid,   'bioProtocolOb' from obtype where  upper(tablename) = 'BIOPROTOCOLOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON geneExpressionStudy
    FOR EACH ROW EXECUTE PROCEDURE setObType(240);
\echo attaching ontology check. 
CREATE FUNCTION checkGeneExpressionStudyTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.studyType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''GENEEXPRESSIONSTUDYTYPE_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid studytype term '', NEW.studyType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkGeneExpressionStudyTypeOntology BEFORE INSERT OR UPDATE ON geneExpressionStudy
    FOR EACH ROW EXECUTE PROCEDURE checkGeneExpressionStudyTypeOntology();


/*
* notes on linking images , such as microarray or gel jpegs, to expression studies.

=> This is done at the level of the study and then, where a page for an individual spot 
   is to display an image for just that spot, a displayProcedure will query the database
   to retrieve the image associated with the study

=> In general there may be more than one image associated with a study - for example, scans
   at low, medium and high laser settings.

   In the brdf schema, an image is a datasource. The display of this image on a page
   is a relationship between that data source, the record for which the display is to be presented 
   - e.g. a microarray or protein gel expression study, and a displayprocedure - i.e. the 
   procedure to display the image

   (the displayprocedure code can either be hosted on the database server and called on the fly when a page is 
   loaded - or it could live elsewhere and be accessed via a URL (e.g. as in the below GBrowse example) )



Examples : 

INSERT INTO displayfunction(xreflsid, ob,displayprocedureob,invocation,functioncomment)
SELECT
   bs.xreflsid || '.' || dp.xreflsid,
   bs.obid,
   dp.obid,
   'getInlineURL(' || bs.obid ||
    ', obtype="biosequenceob", usercontext=context, fetcher=self.fetcher,imagepath=self.imagepath, tempimageurl=self.tempimageurl,method="img",sectionheading="Rice GBrowse for ' ||
    bs.xreflsid ||
    ' (top Blat hit)",uristring="http://gbrowse.agresearch.co.nz/cgi-bin/gbrowse_img/rice/?name='|| split_part(bsf.xreflsid,'.',2) || ':' ||
    featurestart || '..' || featurestop || ';type=Contig+Genes+Rice_Annotation+rice_gi+%22Blat%20CS37%20Top%20Hit%22+%22Blat%20CS37%20All%20Hits%22+monocot_gi+Maize_IBMn_Marker+Wheat_Bin_Marker+ATH_MATCH+%22DNA%2FGC%20Content%22+Translation;width=800;keystyle=between;grid=on"'||
    ',linkuri="http://gbrowse.agresearch.co.nz/cgi-bin/gbrowse/rice/?start=' || bsf.featurestart || ';stop=' || featurestop || ';ref=' ||
     split_part(bsf.xreflsid,'.',2) || ';width=800;version=100;label=Contig-Genes-Rice_Annotation-rice_gi-Blat%20CS37%20Top%20Hit-Blat%20CS37%20All%20Hits-monocot_gi-Maize_IBMn_Marker-Wheat_Bin_Marker-ATH_MATCH-DNA%2FGC%20Content-Translation")',
   'AgReseach Rice GBRowse inline display for CS37 contigs with SNPs'
FROM
   (biosequenceob bs JOIN biosequencefeaturefact bsf ON 
   bs.sequencename = split_part(bsf.featurecomment,' ',2)) JOIN displayprocedureob dp ON
   dp.xreflsid = 'displayProcedures.getInlineURL' 
WHERE
   bsf.xreflsid LIKE 'Rice Genome%';



insert into displayfunction(xreflsid, ob,displayprocedureob,invocation)
select distinct
   ges.xreflsid || '.' || dp.xreflsid || '.peek high scan',
   ges.obid,
   dp.obid,
   'getGenepixThumbnailDisplay(jpegfilename="/var/www/agbrdf/html/test/'||replace(split_part(ges.xreflsid,'.',3),'low','High')||'_R1.jpg",xy=re.split("\t",self.databaseFields["rawdatarecord"])[5:7],usercontext=context,fetcher=self.fetcher, imagepath=self.imagepath, tempimageurl=self.tempimageurl, sectionheading="Spot Images : Peek at high scan both Channels (AgResearch Print132 Experiment)" ,pixelsize='||getMiameCharFact(ges.obid,'GPRHeader','gpr_pixelsize')||',xyoffset=('||getMiameCharFact(ges.obid,'GPRHeader','gpr_jpegorigin')||'),thumbcount=3,thumbdimensions=(10,10),zoomincrement=15)'
from
   (geneexpressionstudy ges join miamefact mf on 
   mf.microarraystudy = ges.obid)
   join displayprocedureob dp on
   dp.xreflsid = 'displayProcedures.getGenepixThumbnailDisplay' and 
   ges.xreflsid like 'GeneExpressionStudy.microarray.%low%';

=>  





*/



/*
* miameFact table attached to the gene expression table
* !!! note - use of this table is (tentatively) deprecated for future development - facts that relate to MIAME should
* be stored in the geenexpressionstudyfact table with a factnamespace of MIAME. There seems to be no 
* point in having an additional specific miamefact table
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(245,'MIAME Fact','miameFact',FALSE,'MIAME Fact',TRUE,'microarray.jpg');
\echo creating miameFact
create table miameFact (
   microarrayStudy integer not null references geneExpressionStudy(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 245,   obtypeid,   'microarrayStudy' from obtype where  upper(tablename) = 'GENEEXPRESSIONSTUDY';



CREATE OR REPLACE FUNCTION getmiamecharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        studyobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from miamefact 
      where microarraystudy = studyobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;




/*
* geneexpressionstudyFact table attached to the gene expression table 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(390,'Gene Expression Study Fact','geneExpressionStudyFact',FALSE,'Gene Expression Study Fact',TRUE,'ob.jpg');
\echo creating geneExpressionStudyFact
create table geneExpressionStudyFact (
   geneExpressionStudy integer not null references geneExpressionStudy(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 390,   obtypeid,   'geneExpressionStudy' from obtype where  upper(tablename) = 'GENEEXPRESSIONSTUDY';



CREATE OR REPLACE FUNCTION getgeneexpressionstudycharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        studyobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from geneExpressionStudyFact 
      where geneExpressionStudy = studyobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



/*
* Observation table attached to the geneexpressionstudy table. This contains both raw and normalised
* observation data
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(250,'Microarray Observation','microarrayObservation',TRUE,'Microarray Observation',TRUE,'spot.jpg');
\echo creating microarrayObservation
create table microarrayObservation (
   microarrayStudy integer not null references geneExpressionStudy(obid),
   microarrayspotfact integer references microarrayspotFact(obid),
   gpr_block integer,
   gpr_column integer,
   gpr_row integer,
   gpr_name varchar(256),
   gpr_id varchar(256),
   gpr_dye1foregroundmean integer,
   gpr_dye1backgroundmean integer,
   gpr_dye2foregroundmean integer,
   gpr_dye2backgroundmean integer,
   gpr_logratio real,
   gpr_flags integer,
   gpr_autoflag integer,
   affy_meanpm real,
   affy_meanmm real,
   affy_stddevpm real,
   affy_stddevmm real,
   affy_count integer,
   norm_logratio real,
   norm_dye1intensity real,
   norm_dye2intensity real, 
   rawDataRecord text,
   rawDataSource integer references datasourceob(obid),
   observationcomment varchar(1024),
   check(obtypeid = 250) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 250,   obtypeid,   'microarrayStudy' from obtype where  upper(tablename) = 'GENEEXPRESSIONSTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 250,   obtypeid,   'microarraySpotFact' from obtype where  upper(tablename) = 'MICROARRAYSPOTFACT';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON microarrayObservation
    FOR EACH ROW EXECUTE PROCEDURE setObType(250);




/*
* microarrayObservationFact table attached to microarrayObservation. This is mostly used to store
* normalised log ratios, intensities etc - it allows more than one type of normalisation to be 
stored
*/
\echo setting up ontology for normalisation values
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('MICROARRAY_NORMALISED_VALUES','This ontology provides standard terms for the various normalised values that are stored in the database','ontology.MICROARRAY_NORMALISED_VALUES');
\echo initialising workflow ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'MICROARRAY_NORMALISED_VALUES.GENSTAT Normed Ratio','GENSTAT Normed Ratio','Normalised log (base2) ratio from Genstat algorithm' from ontologyOb where ontologyName = 'MICROARRAY_NORMALISED_VALUES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'MICROARRAY_NORMALISED_VALUES.GENSTAT Normed Ch1','GENSTAT Normed Ch1','Normalised Channel 1 from Genstat algorithm' from ontologyOb where ontologyName = 'MICROARRAY_NORMALISED_VALUES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'MICROARRAY_NORMALISED_VALUES.GENSTAT Normed Ch2','GENSTAT Normed Ch2','Normalised Channel 2 from Genstat algorithm' from ontologyOb where ontologyName = 'MICROARRAY_NORMALISED_VALUES';
commit;

insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'MICROARRAY_NORMALISED_VALUES.Genstat.Intensity','Intensity','Intensity from Genstat algorithm' from ontologyOb where ontologyName = 'MICROARRAY_NORMALISED_VALUES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'MICROARRAY_NORMALISED_VALUES.Genstat.clogRatio','clogRatio','clogRatio from Genstat algorithm' from ontologyOb where ontologyName = 'MICROARRAY_NORMALISED_VALUES';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'MICROARRAY_NORMALISED_VALUES.Genstat.WtlogRatio','WtlogRatio','WtlogRatio from Genstat algorithm' from ontologyOb where ontologyName = 'MICROARRAY_NORMALISED_VALUES';
commit;






\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(345,'Microarray Observation Fact','microarrayObservationFact',FALSE,'Microarray Observation Fact',TRUE);
\echo creating microarrayObservationFact
create table microarrayObservationFact (
   microarrayobservation integer not null references microarrayObservation(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 345,   obtypeid,   'microarrayObservation' from obtype where  upper(tablename) = 'MICROARRAYOBSERVATION';


CREATE OR REPLACE FUNCTION getmicroarrayobservationcharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        observationobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from microarrayObservationFact 
      where microarrayObservation = observationobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;


/*
* this function still returns a char, but wil return a missing value code (as specified
*by the call) , if there is a blank or NULL. 
*/
CREATE OR REPLACE FUNCTION getmicroarrayobservationnumfact(int4, "varchar", "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        observationobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        mymissingvaluetoken ALIAS for $4;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select 
         CASE 
            WHEN trim(attributevalue) is null THEN mymissingvaluetoken
            WHEN length(trim(attributevalue)) = 0 THEN  mymissingvaluetoken
            ELSE trim(attributevalue)
         END 
      from microarrayObservationFact 
      where microarrayObservation = observationobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;






/*
* proposed for protein expression experiments 7/2011
*/

/*
* Observation table attached to the geneexpressionstudy table, for storing protein expression observations
*
* the geneexpressionstudy table provides the "study level" details - links to the sample , a labresource (such as a microarray,
* or a type of protein Gel) , and a protocol 
*
* For microarrays, the observation is of a microarray spot, which is a fact associated with a microarray, which is a labresource
* For protein gels, the observation is of a gelspot, which is a fact associated with a gel, which is a labresource
*
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(650,'Gel Protein Expression Observation','gelProteinExpressionObservation',TRUE,'gelProteinExpressionObservation',TRUE,'gel.jpg');
\echo creating gelProteinExpressionObservation
create table gelProteinExpressionObservation (
   expressionStudy integer not null references geneExpressionStudy(obid),
   gelspotfact integer references proteinReferenceGelSpotFact(obid),
   peptidesMatched integer,
   sequenceCoverage float,
   foldChange float,
   pValue double precision,
   observationComment varchar(5096),
   check(obtypeid = 650) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 650,   obtypeid,   'expressionStudy' from obtype where  upper(tablename) = 'GENEEXPRESSIONSTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 650,   obtypeid,   'gelspotfact' from obtype where  upper(tablename) = 'PROTEINREFERENCEGELSPOTFACT';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON gelProteinExpressionObservation
    FOR EACH ROW EXECUTE PROCEDURE setObType(650);


/*
*************************************************************
*
* BioDatabase and database search tables. 
*
* These tables model the general activity of using one sequence to find 
* other sequences, including the usual sequence comparison methods such as
* blast etc , but also keyword searching and search based on genomic co-location.
*
* The method used to execute the search (Blast , InterproScan, Transfac , Keyword Search , 
* co-location etc) is stored as a bioProtocolOb - for blast , this
* will include details of the evalue and other options used , and any other 
* filtering or adjustment - but not the database searched, as a single bioprotocol
* may be used for a number of different databases.
*
* A databaseSearchStudy is an actual run of a search, and is a relation between 
* a bioDatabaseOb and a bioProtocolOb. It includes details such as run date
*
* The blast, keyword or genomic co-location hits are observations made as part of the study. 
* A databaseSearchObservation is a relation between a databaseSearchStudy, and two bioSequences - 
* one a query and the other a hit. (In the case of HMMSearches, the bioSequence is a sequence model 
* rather than a sequence string)
*
* Each type of search observation - blast , keyword, colocation - will have its own specific 
* data-values collected as part of that observation (pvalue,evalue,zvalue,score,querystart,querystop,etc
* etc). These are stored in fact tables attached to the observation
*
*
* For example blast HSPs are alignmentFacts of the oservation. 
*
* Other types of search - keyword (where we would search for sequences that exhibited similar
* keyword terms to a given target sequence), and colocation - would have their own
* fact tables as required to qualify the observation, but these tables are not defined
* in this release of the database create script.
*
***************************************************************
*/

\echo creating databaseOb
create table bioDatabaseOb (
   databaseName varchar(256),
   databaseDescription varchar(2048),
   databaseType varchar(2048),
   databaseComment text,
   displayurl varchar(2048)
   check (obtypeid = 315) ,
   unique (obid)) 
   inherits (ob)
   without oids;
insert into obtype(   obtypeid ,  displayName,   tablename ,   obtypedescription, displayurl) 
values (315,'Bio Database','bioDatabaseOb','bioDatabaseOb','bioDatabase.gif');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON bioDatabaseOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(315);


\echo setting up ontology for workstage types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BIODATABASETYPE_ONTOLOGY','This ontology provides standard terms for the types of biodatabases','ontology.BIODATABASETYPE_ONTOLOGY');
\echo initialising biodatabase ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Nucleotide Sequence database' from ontologyOb where ontologyName = 'BIODATABASETYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Protein Sequence database' from ontologyOb where ontologyName = 'BIODATABASETYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Protein Family database' from ontologyOb where ontologyName = 'BIODATABASETYPE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'BIODATABASETYPE_ONTOLOGY.Taxonomy Database','Taxonomy Database' from ontologyOb where ontologyName = 'BIODATABASETYPE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'BIODATABASETYPE_ONTOLOGY.Gene Association','Gene Association' from ontologyOb where ontologyName = 'BIODATABASETYPE_ONTOLOGY';

insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'BIODATABASETYPE_ONTOLOGY.Ontology','Ontology' from ontologyOb where ontologyName = 'BIODATABASETYPE_ONTOLOGY';




CREATE FUNCTION checkBioDatabaseType() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.databaseType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''BIODATABASETYPE_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid biodatabase type '', NEW.databaseType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkBioDatabaseTypeOntology BEFORE INSERT OR UPDATE ON bioDatabaseOb
    FOR EACH ROW EXECUTE PROCEDURE checkBioDatabaseType();

/*
* this table stores general additional facts for a biodatabaseob - e.g. one or
*more URLs to use to retrieve and display accessions
*/
\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(420,'Biodatabase Fact','bioDatabaseFact',FALSE,'Biodatabase Fact',TRUE);
\echo creating bioDatabaseFact
create table bioDatabaseFact (
   bioDatabaseOb integer not null references bioDatabaseOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 420,   obtypeid,   'bioDatabaseOb' from obtype where  upper(tablename) = 'BIODATABASEOB';

CREATE OR REPLACE FUNCTION getbiodatabasecharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        databaseobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from biodatabasefact 
      where biodatabaseob = databaseobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;

/*
* set up some standard biodatabases. Note that the urilinks sometimes fails if done in the same 
* session as the db create - need to run later in a different session
*/


insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Genbank','Genbank','Genbank Nucleotide','Nucleotide Sequence database','');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Genbank.homeurl','http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=Nucleotide','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Genbank.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Non-redundant Protein (NR)','NCBI Non-redundant Protein (NR)',
'All non-redundant Genbank CDS translations+PDB+SwissProt+PIR+PRF excluding environmental samples','Protein Sequence database','');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Non-redundant Protein (NR).homeurl','http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=Protein','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Non-redundant Protein (NR).retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=protein&val=%s','URL');
commit;


insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Human mRNA Refseqs','NCBI Human mRNA Refseqs',
'NCBI Human mRNA Refseqs','Nucleotide Sequence database','');
commit;


insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Fungal mRNA Refseqs','NCBI Fungal mRNA Refseqs',
'NCBI Fungal mRNA Refseqs','Nucleotide Sequence database','');
commit;


insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.mRNA Refseqs','NCBI mRNA Refseqs',
'NCBI mRNA Refseqs','Nucleotide Sequence database','');
commit;


insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Protein Refseqs','NCBI Protein Refseqs',
'NCBI Protein Refseqs','Protein Sequence database','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Bovine mRNA Refseqs','NCBI Bovine mRNA Refseqs',
'NCBI Bovine mRNA Refseqs','Nucleotide Sequence database','');
commit;


insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Mouse mRNA Refseqs','NCBI Mouse mRNA Refseqs',
'NCBI Mouse mRNA Refseqs','Nucleotide Sequence database','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Rat mRNA Refseqs','NCBI Rat mRNA Refseqs',
'NCBI Rat mRNA Refseqs','Nucleotide Sequence database','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('DFCI.Cattle Gene Index','DFCI Cattle Gene Index',
'DFCI Cattle Gene Index','Nucleotide Sequence database','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('DFCI.Rice Gene Index','DFCI Rice Gene Index',
'DFCI Rice Gene Index','Nucleotide Sequence database','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('DFCI.Wheat Gene Index','DFCI Wheat Gene Index',
'DFCI Wheat Gene Index','Nucleotide Sequence database','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('DFCI.Tall Fescue Gene Index','DFCI Tall Fescue Gene Index',
'DFCI Tall Fescue Gene Index','Nucleotide Sequence database','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Taxdump','NCBI Taxdump','NCBI Taxonomy database dump files','Taxonomy Database','');
commit;


insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Gene','NCBI Gene ','Various NCBI Entrez Gene Association Files','Gene Association','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('GO.Filtered Ontology','GO Filtered Ontology','Filtered ontology; cross-products, inter-ontology links, and has_part relationships removed','Ontology','');
commit;







insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Fungal mRNA Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.mRNA Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Protein Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Bovine mRNA Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Human mRNA Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;


insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Mouse mRNA Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Rat mRNA Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Invertebrate mRNA Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Invertebrate Protein Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Plant Protein Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Plant mRNA Refseqs.homeurl','http://www.ncbi.nlm.nih.gov/RefSeq/','URL');
commit;






insert into uriob(xreflsid, uristring , uritype  )
values ('DFCI.Cattle Gene Index.homeurl','http://compbio.dfci.harvard.edu/tgi/cgi-bin/tgi/gimain.pl?gudb=cattle','URL');
commit;
insert into uriob(xreflsid, uristring , uritype  )
values ('DFCI.Rice Gene Index.homeurl','http://compbio.dfci.harvard.edu/tgi/cgi-bin/tgi/gimain.pl?gudb=rice','URL');
commit;
insert into uriob(xreflsid, uristring , uritype  )
values ('DFCI.Wheat Gene Index.homeurl','http://compbio.dfci.harvard.edu/tgi/cgi-bin/tgi/gimain.pl?gudb=wheat','URL');
commit;
insert into uriob(xreflsid, uristring , uritype  )
values ('DFCI.Tall Fescue Gene Index.homeurl','http://compbio.dfci.harvard.edu/tgi/cgi-bin/tgi/gimain.pl?gudb=f_arundinacea','URL');
commit;



insert into uriob(xreflsid, uristring , uritype  )
values ('Btau4.GLEAN CDS.homeurl','http://agbrdf.agresearch.co.nz/cgi-bin/fetch.py?obid=Btau4.GLEAN CDS&context=default&target=ob','URL');
commit;



insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Fungal mRNA Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');


insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.mRNA Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Protein Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=protein&val=%s','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Bovine mRNA Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Human mRNA Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');



insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Mouse mRNA Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');


insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Rat mRNA Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Invertebrate mRNA Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Invertebrate Protein Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Plant Protein Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=protein&val=%s','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('NCBI.Plant mRNA Refseqs.retrieveaccessionurl','http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=%s','URL');
commit;




insert into uriob(xreflsid, uristring , uritype  )
values ('DFCI.Cattle Gene Index.retrieveaccessionurl','http://compbio.dfci.harvard.edu/tgi/cgi-bin/tgi/tc_report.pl?tc=%s&species=cattle','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('DFCI.Rice Gene Index.retrieveaccessionurl','http://compbio.dfci.harvard.edu/tgi/cgi-bin/tgi/tc_report.pl?tc=%s&species=rice','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('DFCI.Wheat Gene Index.retrieveaccessionurl','http://compbio.dfci.harvard.edu/tgi/cgi-bin/tgi/tc_report.pl?tc=%s&species=wheat','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('DFCI.Tall Fescue Gene Index.retrieveaccessionurl','http://compbio.dfci.harvard.edu/tgi/cgi-bin/tgi/tc_report.pl?tc=%s&species=f_arundinacea','URL');


insert into uriob(xreflsid, uristring , uritype  )
values ('Btau4.GLEAN CDS.retrieveaccessionurl','http://agbrdf.agresearch.co.nz/cgi-bin/fetch.py?obid=Btau4.GLEAN.DNA.%s&context=default&target=ob','URL');



/*
* Uniprot
*/
insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('UniProt.UniProtKB','UniProtKB',
'UniProt Knowledgebase (UniProtKB) is the central access point for extensive curated protein information, including function, classification, and cross-reference',
'Protein Sequence database','');

insert into uriob(xreflsid, uristring , uritype  )
values ('UniProt.UniProtKB.homeurl','http://www.pir.uniprot.org/','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('UniProt.UniProtKB.retrieveaccessionurl','http://www.pir.uniprot.org/cgi-bin/upEntry?id=%s','URL');
commit;






insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('MIPS.Fusarium Genome Predicted Proteins','MIPS Fusarium Genome Predicated Proteins Database',
'MIPS Fusarium Genome Predicated Proteins Database','Protein Sequence database','');

commit;
insert into uriob(xreflsid, uristring , uritype  )
values ('MIPS.Fusarium Genome Predicted Proteins.homeurl','http://mips.gsf.de/genre/proj/fusarium','URL');
commit;

insert into uriob(xreflsid, uristring , uritype  )
values ('MIPS.Fusarium Genome Predicted Proteins.retrieveaccessionurl','http://mips.gsf.de/genre/proj/fusarium/singleGeneReport.html?entry=%s','URL');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('CPS NRPS Predicted Proteins','CPS NRPS Predicted Proteins',
'CPS NRPS Predicted Proteins','Protein Sequence database','');
commit;

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('Interpro','Interpro','InterPro is a database of protein families, domains and functional sites in which identifiable features found in known proteins can be applied to unknown protein sequences','Protein Family database','');
insert into uriob(xreflsid, uristring , uritype  )
values ('Interpro.homeurl','http://www.ebi.ac.uk/interpro/','URL');

insert into uriob(xreflsid, uristring , uritype  )
values ('Interpro.retrieveaccessionurl','http://www.ebi.ac.uk/interpro/DisplayIproEntry?ac=%s','URL');



\echo **********inserting URL links : 
\echo **********these inserts may fail - if so do in a later session.
insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'entrez_nuc.gif',
   '(465,45)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Genbank' and
   u.xreflsid = 'NCBI.Genbank.homeurl';

insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'entrez_prot.gif',
   '(465,45)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Non-redundant Protein (NR)' and
   u.xreflsid = 'NCBI.Non-redundant Protein (NR).homeurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Genbank' and
   u.xreflsid = 'NCBI.Genbank.retrieveaccessionurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Non-redundant Protein (NR)' and
   u.xreflsid = 'NCBI.Non-redundant Protein (NR).retrieveaccessionurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Plant Protein Refseqs' and
   u.xreflsid = 'NCBI.Plant Protein Refseqs.retrieveaccessionurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Plant mRNA Refseqs' and
   u.xreflsid = 'NCBI.Plant mRNA Refseqs.retrieveaccessionurl';




insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'RSbanner.gif',
   '(465,45)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.mRNA Refseqs' and
   u.xreflsid = 'NCBI.mRNA Refseqs.homeurl';

insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'RSbanner.gif',
   '(465,45)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Protein Refseqs' and
   u.xreflsid = 'NCBI.Protein Refseqs.homeurl';


insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'cow_2.png',
   '(83,96)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Bovine mRNA Refseqs' and
   u.xreflsid = 'NCBI.Bovine mRNA Refseqs.homeurl';


insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'RSbanner.gif',
   '(465,45)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Human mRNA Refseqs' and
   u.xreflsid = 'NCBI.Human mRNA Refseqs.homeurl';



insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'mouse01.gif',
   '(125,83)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Mouse mRNA Refseqs' and
   u.xreflsid = 'NCBI.Mouse mRNA Refseqs.homeurl';


insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'rat01.gif',
   '(125,83)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Rat mRNA Refseqs' and
   u.xreflsid = 'NCBI.Rat mRNA Refseqs.homeurl';


insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'invertebrate.jpg',
   '(111,111)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Invertebrate mRNA Refseqs' and
   u.xreflsid = 'NCBI.Invertebrate mRNA Refseqs.homeurl';

insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'RSbanner.gif',
   '(465,45)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Plant Protein Refseqs' and
   u.xreflsid = 'NCBI.Plant Protein Refseqs.homeurl';

insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'RSbanner.gif',
   '(465,45)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Plant mRNA Refseqs' and
   u.xreflsid = 'NCBI.Plant mRNA Refseqs.homeurl';






insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'dfci_cattle.gif',
   '(100,58)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'DFCI.Cattle Gene Index' and
   u.xreflsid = 'DFCI.Cattle Gene Index.homeurl';


insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   '/images/dfci_rice.gif',
   '(140,140)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'DFCI.Rice Gene Index' and
   u.xreflsid = 'DFCI.Rice Gene Index.homeurl';

insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   '/images/dfci_wheat.gif',
   '(103,150)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'DFCI.Wheat Gene Index' and
   u.xreflsid = 'DFCI.Wheat Gene Index.homeurl';


insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   '/images/dfci_tallfescue.gif',
   '(222,149)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'DFCI.Tall Fescue Gene Index' and
   u.xreflsid = 'DFCI.Tall Fescue Gene Index.homeurl';









insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Fungal mRNA Refseqs' and
   u.xreflsid = 'NCBI.Fungal mRNA Refseqs.retrieveaccessionurl';


insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.mRNA Refseqs' and
   u.xreflsid = 'NCBI.mRNA Refseqs.retrieveaccessionurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Protein Refseqs' and
   u.xreflsid = 'NCBI.Protein Refseqs.retrieveaccessionurl';


insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Bovine mRNA Refseqs' and
   u.xreflsid = 'NCBI.Bovine mRNA Refseqs.retrieveaccessionurl';



insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Human mRNA Refseqs' and
   u.xreflsid = 'NCBI.Human mRNA Refseqs.retrieveaccessionurl';


insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Mouse mRNA Refseqs' and
   u.xreflsid = 'NCBI.Mouse mRNA Refseqs.retrieveaccessionurl';


insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Rat mRNA Refseqs' and
   u.xreflsid = 'NCBI.Rat mRNA Refseqs.retrieveaccessionurl';



insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Invertebrate mRNA Refseqs' and
   u.xreflsid = 'NCBI.Invertebrate mRNA Refseqs.retrieveaccessionurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'NCBI.Invertebrate Protein Refseqs' and
   u.xreflsid = 'NCBI.Invertebrate Protein Refseqs.retrieveaccessionurl';









insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'DFCI.Cattle Gene Index' and
   u.xreflsid = 'DFCI.Cattle Gene Index.retrieveaccessionurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'DFCI.Rice Gene Index' and
   u.xreflsid = 'DFCI.Rice Gene Index.retrieveaccessionurl';


insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'DFCI.Wheat Gene Index' and
   u.xreflsid = 'DFCI.Wheat Gene Index.retrieveaccessionurl';


insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'DFCI.Tall Fescue Gene Index' and
   u.xreflsid = 'DFCI.Tall Fescue Gene Index.retrieveaccessionurl';







insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'Btau4.GLEAN CDS' and
   u.xreflsid = 'Btau4.GLEAN CDS.retrieveaccessionurl';






insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'fgdb_link.png',
   '(180,77)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'MIPS.Fusarium Genome Predicted Proteins' and
   u.xreflsid = 'MIPS.Fusarium Genome Predicted Proteins.homeurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'MIPS.Fusarium Genome Predicted Proteins' and
   u.xreflsid = 'MIPS.Fusarium Genome Predicted Proteins.retrieveaccessionurl';



insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'interpro_small.jpg',
   '(75,50)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'Interpro' and
   u.xreflsid = 'Interpro.homeurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'Interpro' and
   u.xreflsid = 'Interpro.retrieveaccessionurl';


/*
* Uniprot
*/
insert into urilink(uriob,ob,iconpath,iconattributes,linktype)
select 
   u.obid,
   d.obid,
   'UNIPROT.jpg',
   '(339,85)',
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'UniProt.UniProtKB' and
   u.xreflsid = 'UniProt.UniProtKB.homeurl';

insert into urilink(uriob,ob,linktype)
select 
   u.obid,
   d.obid,
   'system'
from 
   uriob u join biodatabaseob d on 
   d.xreflsid = 'UniProt.UniProtKB' and
   u.xreflsid = 'UniProt.UniProtKB.retrieveaccessionurl';



/*
* set up blast setup details from some standard databases
*/

/*
* 
Human Refseq refresh
*/

insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Human mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/H_sapiens/mRNA_Prot/human.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Human mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f human.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Human mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i human.rna.fna -n hs.fna -p F -o T -t "hs.fna (Human mRNA Refseqs)"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Human mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv hs.fna.n* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Human mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/hs.fna -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Human mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'gzip human.rna.fna'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Human mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Human mRNA Refseqs';




/*
Mouse refseqs
*/

insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Mouse mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/M_musculus/mRNA_Prot/mouse.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Mouse mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f mouse.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Mouse mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i mouse.rna.fna -n mouse.fna -p F -o T -t "mouse.fna (Mouse mRNA Refseqs)"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Mouse mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv mouse.fna.n* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Mouse mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/mouse.fna -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Mouse mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'gzip mouse.rna.fna'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Mouse mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Mouse mRNA Refseqs';



/*
Rat refseqs
*/

insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Rat mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/R_norvegicus/mRNA_Prot/rat.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Rat mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f rat.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Rat mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i rat.rna.fna -n rat.fna -p F -o T -t "rat.fna (Rat mRNA Refseqs)"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Rat mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv rat.fna.n* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Rat mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/rat.fna -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Rat mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'gzip rat.rna.fna'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Rat mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Rat mRNA Refseqs';













/*
Cattle refseqs
*/

insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/B_taurus/mRNA_Prot/cow.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f cow.rna.fna.gz ; mv cow.rna.fna bt.fna'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i bt.fna -n bt.fna -p F -o T -t "bt.fna (Bovine mRNA Refseqs)"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv bt.fna.n* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/bt.fna -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'gzip bt.fna'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine mRNA Refseqs';


/* bt proteins....*/


insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Bovine Protein Refseqs','NCBI Bovine Protein Refseqs',
'NCBI Bovine Protein Refseqs','Protein Sequence database','');
commit;

insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/B_taurus/mRNA_Prot/cow.protein.faa.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f cow.protein.faa.gz ; mv cow.protein.faa bt.faa'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i bt.faa -n bt.faa -p T -o T -t "bt.faa (Bovine Protein Refseqs)"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv bt.faa.p* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/bt.faa -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'gzip bt.faa'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Bovine Protein Refseqs';



/*
* EMBL prokaryote and Phage seqs
*/
insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('EMBL.Prokaryote and Phage Sequences','EMBL Prokaryote and Phage Sequences',
'EMBL Prokaryote and Phage Sequences','Nucleotide Sequence database','');
commit;

insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/embl/pro_phg'
from 
   biodatabaseob
where
   xreflsid = 'EMBL.Prokaryote and Phage Sequences';

insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'EMBL.Prokaryote and Phage Sequences';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ebi.ac.uk/pub/databases/embl/release/rel_std_phg_*.dat.gz  ftp://ftp.ebi.ac.uk/pub/databases/embl/release/rel_std_pro_*.dat.gz'
from 
   biodatabaseob
where
   xreflsid = 'EMBL.Prokaryote and Phage Sequences';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -c rel_std_phg_*.dat.gz rel_std_pro_*.dat.gz | seqret -filter > embl_pro_phg.fa'
from 
   biodatabaseob
where
   xreflsid = 'EMBL.Prokaryote and Phage Sequences';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i embl_pro_phg.fa -n embl_pro_phg.fa  -p F -o T -t "embl_pro_phg.fa (EMBL prokaryote and phage nucleotide seqs)"'
from 
   biodatabaseob
where
   xreflsid = 'EMBL.Prokaryote and Phage Sequences';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv embl_pro_phg.fa.n* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'EMBL.Prokaryote and Phage Sequences';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/embl_pro_phg.fa -I'
from 
   biodatabaseob
where
   xreflsid = 'EMBL.Prokaryote and Phage Sequences';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm embl_pro_phg.fa'
from 
   biodatabaseob
where
   xreflsid = 'EMBL.Prokaryote and Phage Sequences';























/*
nt database
*/


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Genbank';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://biomirror.auckland.ac.nz/blast/nt.*.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Genbank';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   '/data/anonftp/pub/mirror/blast/unpack.sh nt'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Genbank';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    'echo "No foromatdb done - this database is pre-formatted"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Genbank';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'echo "No move required"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Genbank';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/nt -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Genbank';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm nt.*.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Genbank';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Genbank';


/*
nr 
*/
insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Non-redundant Protein (NR)';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://biomirror.auckland.ac.nz/blast/nr.*.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Non-redundant Protein (NR)';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   '/data/anonftp/pub/mirror/blast/unpack.sh nr'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Non-redundant Protein (NR)';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    'echo "No formatdb done - this database is pre-formatted"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Non-redundant Protein (NR)';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'echo "No move required"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Non-redundant Protein (NR)';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/nr -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Non-redundant Protein (NR)';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm nr.*.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Non-redundant Protein (NR)';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Non-redundant Protein (NR)';





/*
* Plant Refseqs - RNA
*/
insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/release/plant/plant*.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f plant*.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'PREFORMAT',
   'cat plant*.rna.fna > allplant.tmp'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i allplant.tmp -n plant.rna.fna -p F -o T -t "Plant public mRNA refseqs"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv plant.rna.fna.n* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/plant.rna.fna -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm allplant.tmp plant*.rna.fna'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq/impala'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant mRNA Refseqs';



/*
* Plant Refseqs - Protein
*/
insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/release/plant/plant*.protein.faa.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f plant*.protein.faa.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'PREFORMAT',
   'cat plant*.protein.faa > allplant.tmp'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i allplant.tmp -n plant.protein.faa -p T -o T -t "Plant public protein refseqs"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv plant.protein.faa.p* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/plant.protein.faa -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm allplant.tmp plant*.protein.faa'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq/impala'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Plant Protein Refseqs';























/*
* Fungal Refseqs
*/
insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/release/fungi/fungi*.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f fungi*.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'PREFORMAT',
   'cat fungi*.rna.fna > allfungi.tmp'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i allfungi.tmp -n fungi.rna.fna -p F -o T -t "Fungal public mRNA refseqs"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv fungi.rna.fna.n* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/fungi.rna.fna -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm allfungi.tmp ; gzip fungi*.rna.fna'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal mRNA Refseqs';

/*
Proteins
*/

insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Fungal Protein Refseqs','NCBI Fungal Protein Refseqs',
'NCBI Fungal Protein Refseqs','Protein Sequence database','');
commit;


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/release/fungi/fungi*.protein.faa.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f fungi*.protein.faa.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'PREFORMAT',
   'cat fungi*.protein.faa > allfungi.tmp'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i allfungi.tmp -n fungi.protein.faa -o T -t "Fungal public protein refseqs"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv fungi.protein.faa.p* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/fungi.protein.faa -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm allfungi.tmp ; gzip fungi*.protein.faa'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Fungal Protein Refseqs';




/*
**************** Invertebrate refseqs *************
*/
insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Invertebrate mRNA Refseqs','Invertebrate mRNA Refseqs',
'Invertebrate mRNA Refseqs','Nucleotide Sequence database','');
commit;
insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/release/invertebrate/invertebrate*.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f invertebrate*.rna.fna.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'PREFORMAT',
   'cat invertebrate*.rna.fna > allinvertebrate.tmp'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i allinvertebrate.tmp -n invertebrate.rna.fna -p F -o T -t "Invertebrate public mRNA refseqs"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv invertebrate.rna.fna.n* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/invertebrate.rna.fna -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm allinvertebrate.tmp ; gzip invertebrate*.rna.fna'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate mRNA Refseqs';


/* proteins */
insert into biodatabaseob(xreflsid,databasename,databasedescription,databasetype,databasecomment)
values('NCBI.Invertebrate Protein Refseqs','Invertebrate Protein Refseqs',
'Invertebrate Protein Refseqs','Protein Sequence database','');
commit;
insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.ncbi.nlm.nih.gov/refseq/release/invertebrate/invertebrate*.protein.faa.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -f invertebrate*.protein.faa.gz'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'PREFORMAT',
   'cat invertebrate*.protein.faa > allinvertebrate.tmp'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i allinvertebrate.tmp -n invertebrate.protein.faa -p T -o T -t "Invertebrate public Protein refseqs"'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv invertebrate.protein.faa.p* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/invertebrate.protein.faa -I'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm allinvertebrate.tmp ; gzip invertebrate*.protein.faa'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/ncbi/refseq'
from 
   biodatabaseob
where
   xreflsid = 'NCBI.Invertebrate Protein Refseqs';





/*
* Uniprot
*/

insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'SETUP METHOD',
   'METHOD 1'
from 
   biodatabaseob
where
   xreflsid = 'UniProt.UniProtKB';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD',
   'wget --no-verbose --timestamping ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_*.fasta.gz'
from 
   biodatabaseob
where
   xreflsid = 'UniProt.UniProtKB';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'UNPACK',
   'gunzip -c uniprot_trembl.fasta.gz uniprot_sprot.fasta.gz > uniprot_kb.fa'
from 
   biodatabaseob
where
   xreflsid = 'UniProt.UniProtKB';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'FORMATDB',
    '/usr/local/blast/formatdb -i uniprot_kb.fa -n uniprot_kb.fa -p T -o T -t "UniProt plus TrEMBL"'
from 
   biodatabaseob
where
   xreflsid = 'UniProt.UniProtKB';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'MOVE',
    'mv uniprot_kb.fa.* /data/anonftp/pub/mirror/blast'
from 
   biodatabaseob
where
   xreflsid = 'UniProt.UniProtKB';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'INFO',
    '/usr/local/blast/fastacmd -d /data/anonftp/pub/mirror/blast/uniprot_kb.fa -I'
from 
   biodatabaseob
where
   xreflsid = 'UniProt.UniProtKB';


insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'CLEAN UP',
    'rm uniprot_kb.fa'
from 
   biodatabaseob
where
   xreflsid = 'UniProt.UniProtKB';



insert into biodatabasefact(biodatabaseob,factnamespace,attributename,attributevalue)
select 
   obid,
   'BLAST SETUP',
   'DOWNLOAD DIRECTORY',
    '/data/anonftp/pub/mirror/uniprot'
from 
   biodatabaseob
where
   xreflsid = 'UniProt.UniProtKB';



\echo setting up ontology for database search study types
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('DATABASESEARCHSTUDYTYPE_ONTOLOGY','This ontology provides standard terms for the types of database search studies','ontology.DATABASESEARCHSTUDYTYPE_ONTOLOGY');
\echo initialising database search study type ontology 
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Blast' from ontologyOb where ontologyName = 'DATABASESEARCHSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Interpro IPRSCAN' from ontologyOb where ontologyName = 'DATABASESEARCHSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Transfac Profile' from ontologyOb where ontologyName = 'DATABASESEARCHSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Keyword Similarity' from ontologyOb where ontologyName = 'DATABASESEARCHSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Genomic Co-location' from ontologyOb where ontologyName = 'DATABASESEARCHSTUDYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'ontology.term','Smith Waterman' from ontologyOb where ontologyName = 'DATABASESEARCHSTUDYTYPE_ONTOLOGY';

commit;
\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,displayurl)
values(320, 'Database Search Study','databaseSearchStudy',TRUE,'Database Search',TRUE,'search.gif');
\echo creating databaseSearchStudy
create table databaseSearchStudy (
   bioDatabaseOb integer references bioDatabaseOb(obid),
   bioProtocolOb integer references bioProtocolOb(obid),
   studyname varchar(1024),
   runBy varchar(256),
   rundate date,
   studycomment varchar(2048),
   studyType varchar(128),
   studyDescription varchar(2048),
   check(obtypeid = 320),
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 320,   obtypeid,   'bioDatabaseOb' from obtype where  upper(tablename) = 'BIODATABASEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 320,   obtypeid,   'bioProtocolOb' from obtype where  upper(tablename) = 'BIOPROTOCOLOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON databaseSearchStudy
    FOR EACH ROW EXECUTE PROCEDURE setObType(320);
\echo attaching ontology check. 
CREATE FUNCTION checkDatabaseSearchStudyTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.studyType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''DATABASESEARCHSTUDYTYPE_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid studytype '', NEW.studyType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkDatabaseSearchStudyTypeOntology BEFORE INSERT OR UPDATE ON databaseSearchStudy
    FOR EACH ROW EXECUTE PROCEDURE checkDatabaseSearchStudyTypeOntology();
commit;


/*
* Observation table attached to the databasesearchstudy table.
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(325,'Database Search Result','databaseSearchObservation',TRUE,'Database Search Result',TRUE,'databaseSearchResult.gif');
\echo creating databaseSearchObservation
create table databaseSearchObservation (
   databaseSearchStudy integer not null references databaseSearchStudy(obid),
   querySequence integer not null references bioSequenceOb(obid),
   hitSequence integer not null references bioSequenceOb(obid),
   queryxreflsid varchar(2048),
   querylength numeric(12,0),
   hitxreflsid varchar(2048),
   hitdescription text,
   hitlength numeric(12,0),
   hitevalue double precision,
   hitpvalue double precision,
   rawSearchResult text,
   userflags varchar(2048),
   observationcomment varchar(2048),
   check(obtypeid = 325) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 325,   obtypeid,   'databaseSearchStudy' from obtype where  upper(tablename) = 'DATABASESEARCHSTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 325,   obtypeid,   'querySequence' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 325,   obtypeid,   'hitSequence' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON databaseSearchObservation
    FOR EACH ROW EXECUTE PROCEDURE setObType(325);



insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('DATABASESEARCHUSERFLAGS_ONTOLOGY','This ontology provides standard phrases that can be used to flag blast hits','ontology.DATABASESEARCHUSERFLAGS_ONTOLOGY');
\echo initialising database search hit flags  ontology 
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'DATABASESEARCHUSERFLAGS_ONTOLOGY.Top hit','Top hit' from ontologyOb where ontologyName = 'DATABASESEARCHUSERFLAGS_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'DATABASESEARCHUSERFLAGS_ONTOLOGY.Top meaningful hit','Top meaningful hit' , 'This hit has been flagged as containing more informative keywords than others' from ontologyOb where ontologyName = 'DATABASESEARCHUSERFLAGS_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'DATABASESEARCHUSERFLAGS_ONTOLOGY.New','New','This is a new hit for this sequence' from ontologyOb where ontologyName = 'DATABASESEARCHUSERFLAGS_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'DATABASESEARCHUSERFLAGS_ONTOLOGY.Best Reciprocal Hit','Best Reciprocal Hit','This hit is the best reciprocal hit of this sequence' from ontologyOb where ontologyName = 'DATABASESEARCHUSERFLAGS_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'DATABASESEARCHUSERFLAGS_ONTOLOGY.Ortholog','Ortholog','The query and hit sequence are predicted orthologs' from ontologyOb where ontologyName = 'DATABASESEARCHUSERFLAGS_ONTOLOGY';


insert into ontologytermfact2(
 ontologytermid,
 factnamespace ,
 attributename  ,
 attributevalue )
select obid, 'display','iconpath','informative.jpg'
from ontologytermfact where termname = 'Top meaningful hit';

insert into ontologytermfact2(
 ontologytermid,
 factnamespace ,
 attributename  ,
 attributevalue )
select obid, 'display','iconpath','new.gif'
from ontologytermfact where termname = 'New';


insert into ontologytermfact2(
 ontologytermid,
 factnamespace ,
 attributename  ,
 attributevalue )
select obid, 'display','iconpath','informative.jpg'
from ontologytermfact where termname = 'Reciprocal Top Hit';








/*
* Alignment Fact table attached to the databaseSearchObservation table.
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(330,'Sequence Alignment Details','sequenceAlignmentFact',TRUE,'Alignment Details',TRUE,'databaseSearchResult.gif');
\echo creating sequenceAlignmentFact
create table sequenceAlignmentFact (
   databaseSearchObservation integer not null references databaseSearchObservation(obid),
   bitscore double precision,
   mismatches integer,
   indels integer,
   pctidentity float,
   score double precision,
   evalue double precision,
   queryFrom numeric(12,0),
   queryTo numeric(12,0),
   HitFrom numeric(12,0),
   HitTo numeric(12,0),
   queryFrame integer,
   hitFrame integer,
   hitStrand integer,
   identities integer,
   positives integer,
   gaps integer,
   alignlen integer,
   hspqseq text,
   hsphseq text,
   hspmidline text,
   alignmentComment varchar(2048),
   check(obtypeid = 330) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 330,   obtypeid,   'databaseSearchObservation' from obtype where  upper(tablename) = 'DATABASESEARCHOBSERVATION';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON sequenceAlignmentFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(330);




CREATE OR REPLACE FUNCTION getTopSearchHitAttribute(int4, int4, varchar,varchar) RETURNS varchar AS
'
   DECLARE
      hitcursor refcursor;
      seqobid ALIAS for $1;
      studyobid ALIAS for $2;
      argflag ALIAS for $3;
      attributename ALIAS for $4;
      tophitattribute varchar(5196);
      tophit integer;
      topobservation integer;
   BEGIN
      if upper(attributename) != ''HITFROM'' and upper(attributename) != ''HITTO'' and upper(attributename) != ''EVALUE''  and
         upper(attributename) != ''QUERYFROM'' and upper(attributename) != ''QUERYTO''  and upper(attributename) != ''NEWFLAG'' and
         upper(attributename) != ''QUERYFRAME''  and upper(attributename) != ''HITSTRAND'' then
         tophit := getTopSearchHit(seqobid,studyobid,argflag);
         tophitattribute := null;
         if tophit is not null then
            if upper(attributename) = ''NAME'' then
               open hitcursor for 
               select sequencename from 
               biosequenceob where obid = tophit;
            elsif  upper(attributename) = ''NAME AND DESCRIPTION'' then
               open hitcursor for 
               select coalesce(sequencename || '' '' || sequencedescription, sequencename) from 
               biosequenceob where obid = tophit; 
            elsif  upper(attributename) = ''DESCRIPTION'' then
               open hitcursor for 
               select sequencedescription from 
               biosequenceob where obid = tophit; 
            else 
               raise Exception ''unknown attribute specification'';
            end if;
            fetch hitcursor into tophitattribute;
            close hitcursor;
         end if;
      else 
         topobservation := getTopSearchObservation(seqobid,studyobid,argflag);
         tophitattribute := null;
         if topobservation is not null then
            if upper(attributename) = ''QUERYTO'' then
               open hitcursor for 
               select to_char(queryto,''9999999999'') from 
               sequencealignmentfact  where databasesearchobservation  = topobservation;
            elsif  upper(attributename) = ''QUERYFROM'' then
               open hitcursor for 
               select to_char(queryfrom,''9999999999'')  from 
               sequencealignmentfact  where databasesearchobservation  = topobservation;
            elsif upper(attributename) = ''HITTO'' then
               open hitcursor for 
               select to_char(hitto,''9999999999'') from 
               sequencealignmentfact  where databasesearchobservation  = topobservation;
            elsif  upper(attributename) = ''HITFROM'' then
               open hitcursor for 
               select to_char(hitfrom,''9999999999'')  from 
               sequencealignmentfact  where databasesearchobservation  = topobservation;
            elsif  upper(attributename) = ''QUERYFRAME'' then
               open hitcursor for 
               select to_char(queryframe,''9999999999'')  from 
               sequencealignmentfact  where databasesearchobservation  = topobservation;
            elsif  upper(attributename) = ''HITSTRAND'' then
               open hitcursor for 
               select to_char(hitstrand,''9999999999'')  from 
               sequencealignmentfact  where databasesearchobservation  = topobservation;
            elsif  upper(attributename) = ''EVALUE'' then
               open hitcursor for 
               select format_evalue(hitevalue)  from 
               databasesearchobservation  where obid = topobservation;
            elsif  upper(attributename) = ''NEWFLAG'' then
               open hitcursor for 
               select 
                  case
                     when upper(userflags) like ''%NEW%'' then ''New'' 
                     else null
                  end 
               from  
               databasesearchobservation  where obid = topobservation; 
            else 
               raise exception ''unsupported attribute % '', attributename;
            end if;
 
            fetch hitcursor into tophitattribute;

            close hitcursor;
         end if;
      end if;
     
      return tophitattribute;
   END;
'
LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION getTopSearchHitAttribute(varchar, int4, varchar,varchar) RETURNS varchar AS 
'
   DECLARE
      hitcursor refcursor;
      seqobid int4;
      seqname ALIAS for $1;
      studyobid ALIAS for $2;
      argflag ALIAS for $3;
      attributename ALIAS for $4;
      tophitattribute varchar(5196);
      tophit integer;
      topobservation integer;
  BEGIN
      seqobid := null;

      select obid into seqobid from biosequenceob where sequencename = seqname;

      if seqobid is null then
          return null;
      else
          return getTopSearchHitAttribute(seqobid, studyobid,argflag,attributename);
      end if;
  END;
'
LANGUAGE plpgsql;






CREATE OR REPLACE FUNCTION getTopSearchHitName(int4, int4, varchar) RETURNS varchar AS
'
   DECLARE
      seqobid ALIAS for $1;
      studyobid ALIAS for $2;
      argflag ALIAS for $3;
   BEGIN
      return getTopSearchHitAttribute(seqobid,studyobid,argflag,''NAME'');
   END;
'
LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION getTopSearchObservation(int4, int4, varchar) RETURNS int4 AS
'
   DECLARE
      hitcursor refcursor;
      seqobid ALIAS for $1;
      studyobid ALIAS for $2;
      argflag ALIAS for $3;
      topobservation int4;
   BEGIN   
      if seqobid is null then
         return null;
      end if;

      if argflag is null then 
         open hitcursor for
       	    select
       	       dso.obid
            from 
               databasesearchobservation dso left outer join sequencealignmentfact saf on
               saf.databasesearchobservation = dso.obid
            where           
               dso.databasesearchstudy = studyobid and 
               dso.querysequence = seqobid 
            order by
               dso.hitevalue asc,
               saf.bitscore desc;
      else
         open hitcursor for 
       	    select
       	       dso.obid
            from 
               databasesearchobservation dso left outer join sequencealignmentfact saf on
               saf.databasesearchobservation = dso.obid
            where           
               dso.databasesearchstudy = studyobid and 
               dso.querysequence = seqobid and
               dso.userflags like ''%''||argflag||''%''
            order by
               dso.hitevalue asc,
               saf.bitscore desc;
      end if;


      fetch hitcursor into topobservation;
      if not FOUND then
         topobservation := null;
      end if;
      close hitcursor;
      return topobservation;
    END;
'
LANGUAGE plpgsql;

      
CREATE OR REPLACE FUNCTION getTopSearchHit(int4, int4, varchar) RETURNS int4 AS
'
   DECLARE
      hitcursor refcursor;
      seqobid ALIAS for $1;
      studyobid ALIAS for $2;
      argflag ALIAS for $3;
      tophit int4;
      topobservation int4;
   BEGIN   
      select getTopSearchObservation(seqobid, studyobid, argflag) into topobservation;
      if topobservation  is null then
         return null;
      end if;

      select hitsequence into tophit from databasesearchobservation where obid = topobservation;

      return tophit;
    END;
'
LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION getTopSearchHit(int4, int4) RETURNS int4 AS
'
   DECLARE
      seqobid ALIAS for $1;
      studyobid ALIAS for $2;
   BEGIN   
      return getTopSearchHit(seqobid, studyobid, null);
    END;
'
LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION getTopSearchHit(varchar, int4, varchar) RETURNS int4 AS
'
   DECLARE
      hitcursor refcursor;
      seqname ALIAS for $1;
      seqobid int4;
      studyobid ALIAS for $2;
      argflag ALIAS for $3;
      tophit int4;
      topobservation int4;
   BEGIN   
      seqobid := null;

      select obid into seqobid from biosequenceob where sequencename = seqname;

      if seqobid is null then
          return null;
      else
          return getTopSearchHit(seqobid,studyobid,argflag);
      end if;
    END;
'
LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION getTopSearchQuery(int4, int4) RETURNS int4 AS
'
   DECLARE
      hitcursor refcursor;
      seqobid ALIAS for $1;
      studyobid ALIAS for $2;
      tophit int4;
   BEGIN   

      if seqobid is null then
         return null;
      end if;


      open hitcursor for
    	select
       	   querysequence
        from 
           databasesearchobservation dso left outer join sequencealignmentfact saf on
           saf.databasesearchobservation = dso.obid
        where
           dso.databasesearchstudy = studyobid and 
           dso.hitsequence = seqobid
        order by
           dso.hitevalue asc,
           saf.bitscore desc;
      fetch hitcursor into tophit;
      if not FOUND then
         tophit := null;
      end if;
      close hitcursor;
      return tophit;
    END;
'
LANGUAGE plpgsql;


/*
* this function is used to annotate a blast run with 
* "new" and "top hit" user flags
*/
CREATE OR REPLACE FUNCTION annotateBlastRun(int4,varchar,date) RETURNS int4 AS
'
   DECLARE
      querycursor refcursor;
      hitcursor refcursor;
      blastsearch ALIAS for $1;
      argflags ALIAS for $2;
      newdate ALIAS for $3; 
      tophit int4;
      currentquery int4;
      currenthit int4;
      currentflags varchar;
      annotatecount integer;
   BEGIN   
      

      if upper(argflags) like ''%TOP%HIT%'' then
         open querycursor for
    	    select distinct
       	       querysequence 
            from 
               databasesearchobservation 
            where
               databasesearchstudy = blastsearch;

         fetch querycursor into currentquery;

         annotatecount := 0;      

         while found LOOP
      
               -- get the top hit of this query
               tophit := getTopSearchHit(currentquery, blastsearch);
 
               if tophit is not null then
                  select userflags into currentflags from
                  databasesearchobservation where
                  databasesearchstudy = blastsearch and
                  querysequence = currentquery and 
                  hitsequence = tophit;  

                  if upper(currentflags) not like ''%TOP%HIT%'' then
                     update databasesearchobservation
                     set userflags = coalesce(userflags || '',Top Hit'', ''Top Hit''),
                     lastupdateddate = now()
                     where databasesearchstudy = blastsearch and 
                     querysequence = currentquery and
                     hitsequence = tophit;
                     annotateCount := annotateCount  + 1;
               end if;
            end if;


            fetch querycursor into currentquery;

         end LOOP;
      end if;

      close querycursor;

      if upper(argflags) like ''%NEW%'' then
         open hitcursor for
    	    select distinct
       	       hitsequence
            from 
               databasesearchobservation 
            where
               databasesearchstudy = blastsearch and
               createddate >= newdate;

         fetch hitcursor into currenthit;
      

         while found LOOP

            update databasesearchobservation
            set userflags = coalesce(userflags || '',New'', ''New''),
            lastupdateddate = now()
            where databasesearchstudy = blastsearch and 
            hitsequence = currenthit;

            annotateCount := annotateCount  + 1;

            fetch hitcursor into currenthit;

         end LOOP;
      end if;

      close hitcursor;

      return annotateCount;


    END;
'
LANGUAGE plpgsql;

select annotateBlastRun(1268614,'new,top hit','2010-06-01');
























-- reciprocal annotation - the next two methods are simple reciprocal top hit methods
-- and are !!!!!! deprecated !!!!!!!!
/***
CREATE OR REPLACE FUNCTION DEPRECATEDannotateReciprocalTophits(int4) RETURNS int4 AS
'
   DECLARE
      querycursor refcursor;
      blastsearch ALIAS for $1;
      tophit int4;
      tophitstopquery int4;
      currentquery int4;
      reciprocalcount int4;
   BEGIN   
      
      open querycursor for
    	select distinct
       	   querysequence
        from 
           databasesearchobservation 
        where
           databasesearchstudy = blastsearch;

      fetch querycursor into currentquery;
      reciprocalcount := 0;

      while found LOOP
      
         -- get the top hit of this query
         tophit := getTopSearchHit(currentquery, blastsearch);

         -- if the top query of the top hit is the current query, annotate
         -- reciprocal
         if tophit is not null then
            tophitstopquery := getTopSearchQuery(tophit,blastsearch);
            if tophitstopquery = currentquery then
               update databasesearchobservation
               set userflags = coalesce(userflags || '',Reciprocal Top Hit(1)'', ''Reciprocal Top Hit(1)''),
               lastupdateddate = now()
               where databasesearchstudy = blastsearch and 
               querysequence = currentquery and
               hitsequence = tophit;
               reciprocalcount := reciprocalcount + 1;
            end if;
         end if;

         fetch querycursor into currentquery;

      end LOOP;


      close querycursor;
      return reciprocalcount;
    END;
'
LANGUAGE plpgsql;


select annotateReciprocalTophits(37524635);


-- reciprocal annotation using two blast runs (it can also be done with a single blast run as above)
CREATE OR REPLACE FUNCTION DEPRECATEDannotateReciprocalTophits2(int4, int4, boolean, boolean) RETURNS int4 AS
'
   DECLARE
      querycursor refcursor;
      blastsearch1 ALIAS for $1;
      blastsearch2 ALIAS for $2;
      annotateSearch1 ALIAS for $3;
      annotateSearch2 ALIAS for $4;
      tophit int4;
      tophitstophit int4;
      currentquery int4;
      reciprocalcount int4;
   BEGIN   
      --the annotateSearch* parms control which of the two searches we are to flag - usually
      -- you would only flag the queries in the first search
      if not annotateSearch1 and not annotateSearch2 then
         return 0;
      end if;
      
      open querycursor for
    	select distinct
       	   querysequence
        from 
           databasesearchobservation 
        where
           databasesearchstudy = blastsearch1;

      fetch querycursor into currentquery;
      reciprocalcount := 0;

      while found LOOP
      
         -- get the top hit of this query
         tophit := getTopSearchHit(currentquery, blastsearch1);

         -- if the top hit of the top hit is the current query, annotate
         -- reciprocal
         if tophit is not null then
            tophitstophit := getTopSearchHit(tophit,blastsearch2);
            if tophitstophit = currentquery then
               if annotateSearch1 then
                  update databasesearchobservation
                  set userflags = coalesce(userflags || '',Reciprocal Top Hit'', ''Reciprocal Top Hit''),
                  lastupdateddate = now()
                  where databasesearchstudy = blastsearch1 and 
                  querysequence = currentquery and
                  hitsequence = tophit;
               end if;

               if annotateSearch2 then
                  update databasesearchobservation
                  set userflags = coalesce(userflags || '',Reciprocal Top Hit'', ''Reciprocal Top Hit''),
                  lastupdateddate = now()
                  where databasesearchstudy = blastsearch2 and 
                  querysequence = tophit and
                  hitsequence = currentquery;
               end if;

               reciprocalcount := reciprocalcount + 1;
            end if;
         end if;

         fetch querycursor into currentquery;

      end LOOP;


      close querycursor;
      return reciprocalcount;
    END;
'
LANGUAGE plpgsql;
***/


CREATE OR REPLACE FUNCTION annotateReciprocalTophits(int4, int4, int4, boolean, boolean) RETURNS int4 AS
'
-- this use the method of
-- Proc. Natl. Acad. Sci. USA
--Vol. 95, pp. 6239-6244, May 1998
--Genetics
--Genomic evidence for two functionally distinct gene classes
--MARIA C. RIVERA, RAVI JAIN, JONATHAN E. MOORE, AND JAMES A. LAKE* 
-- ...orthologs were selected according to a symmetrical (distancelike)
--procedure by using MSPs. If a and b are orthologous
--genes in genomes A and B, respectively, then we required that
--a BLASTP search of database B with gene a should select gene
--b and the reciprocal search of database A with gene b should
--select gene a. The four sequences with the highest MSPs were
--selected from each BLASTP comparison, and from this 4 * 4
--array of scores, sij, reciprocal pairs were selected (if any
--existed). The best pair, corresponding to the minimum value
--of i + j and the maximum sum of scores, was then chosen as
--the ortholog pair.
   DECLARE
      querycursor refcursor;
      searchcursor refcursor;
      search2cursor refcursor;
      searchrecord record;
      blastsearch1 ALIAS for $1;
      blastsearch2 ALIAS for $2;
      depth ALIAS for $3;
      annotateSearch1 ALIAS for $4;
      annotateSearch2 ALIAS for $5;
      currentquery integer;
      lasthit integer;
      hitcount integer;
      querycount integer;

      forwardmspids integer[];
      forwardmspscores float[];
      forwardmspevalues float[];
      forwardmspids_l integer;

      reversemspids integer[];
      reversemspscores float[];
      reversemspevalues float[];
      reversemspids_l integer;

      minfindex integer[];
      minfindex_l integer;
      minrindex integer[];

      reciprocalindex integer;

      i integer;
      j integer;
      ijmin integer;
      scoremax float;
      reciprocalcount integer;

      
     
 
   BEGIN   
      -- master query to loop through all seqs to be considered
      open querycursor for
    	select distinct
       	   querysequence
        from 
           databasesearchobservation 
        where
           databasesearchstudy = blastsearch1;

      fetch querycursor into currentquery;

      querycount := 0;
      reciprocalcount := 0;
      while found  LOOP
         hitcount := 0;
         lasthit := 0;
         forwardmspids_l := 0;
         reversemspids_l := 0;
         querycount := querycount + 1;
    
      
         -- get the top "depth" hits of this query
         open searchcursor for 
    	 select
       	    dso.hitsequence,
            dso.hitevalue,
            saf.score
         from 
            databasesearchobservation dso left outer join sequencealignmentfact saf on
            saf.databasesearchobservation = dso.obid
         where           
            dso.databasesearchstudy = blastsearch1 and 
            dso.querysequence = currentquery 
         order by
            dso.hitevalue asc,
            saf.score desc;

         fetch searchcursor into searchrecord;

         while found and hitcount < depth loop

            if lasthit != searchrecord.hitsequence then
               hitcount := hitcount + 1;
               forwardmspids[hitcount] := searchrecord.hitsequence;
               forwardmspscores[hitcount] := searchrecord.score;
               forwardmspevalues[hitcount] := searchrecord.hitevalue;
               forwardmspids_l := forwardmspids_l + 1;
               lasthit := searchrecord.hitsequence;
            end if;

            fetch searchcursor into searchrecord;

         end loop;

         close searchcursor;
         --perform mylog(1,''forward=''||to_char(hitcount,''99999''));


         -- get the top "depth" seqs that hit this query 
         hitcount := 0;
         lasthit := 0;

         open searchcursor for
         select
            dso.querysequence,
            dso.hitevalue,
            saf.score
         from
            databasesearchobservation dso left outer join sequencealignmentfact saf on
            saf.databasesearchobservation = dso.obid
         where
            dso.databasesearchstudy = blastsearch2 and
            dso.hitsequence = currentquery
         order by
            dso.hitevalue asc,
            saf.score desc;

         fetch searchcursor into searchrecord;

         while found and hitcount < depth loop

            if lasthit != searchrecord.querysequence then
               hitcount := hitcount + 1;
               reversemspids[hitcount] := searchrecord.querysequence;
               reversemspscores[hitcount] := searchrecord.score;
               reversemspevalues[hitcount] := searchrecord.hitevalue;
               reversemspids_l := reversemspids_l + 1;
               lasthit := searchrecord.querysequence;
            end if;

            fetch searchcursor into searchrecord;

         end loop;

         close searchcursor;
         --perform mylog(1,''reverse=''||to_char(hitcount,''99999''));

         -- attempt to find the best reciprocal hit. Best is that with minimum
         -- of (i+j) , and then for same i+j, maximum of sum of scores 
         -- first create an array containing all candidates that have the same
         -- minimum i+j - we store the index of each candidate in the forward array

         ijmin := 1 + forwardmspids_l + reversemspids_l;
         minfindex_l := 0;
         for i in 1..forwardmspids_l loop
            for j in 1..reversemspids_l loop
               if (i + j < ijmin) and forwardmspids[i] = reversemspids[j] then
                  minfindex_l := minfindex_l + 1;
                  minfindex[minfindex_l] := i;
                  minrindex[minfindex_l] := j;
                  ijmin := i + j;
               end if;
            end loop;
         end loop;
         --perform mylog(2,''minfindex_l=''||to_char(minfindex_l,''99999''));


         -- find the candidate with the maximum sum of score
         reciprocalindex := 0;
         scoremax := 0;
         for i in 1..minfindex_l loop
            --perform mylog(1,''comparing ''||to_char(forwardmspscores[minfindex[i]],''99999'') || '' '' || to_char(reversemspscores[minfindex[i]],''99999''));
            if (forwardmspscores[minfindex[i]] + reversemspscores[minrindex[i]]) > scoremax then
               reciprocalindex := i;
               scoremax := forwardmspscores[minfindex[i]] + reversemspscores[minrindex[i]];
            end if;
         end loop;

         -- annotate if we have one
         if reciprocalindex != 0 then

            if annotateSearch1 then
               update databasesearchobservation
               set userflags = coalesce(userflags || '',Best Reciprocal Hit'', ''Best Reciprocal Hit''),
               lastupdateddate = now()
               where databasesearchstudy = blastsearch1 and 
               querysequence = currentquery and
               hitsequence = forwardmspids[minfindex[reciprocalindex]];
            end if;

            if annotateSearch2 then
               update databasesearchobservation
               set userflags = coalesce(userflags || '',Best Reciprocal Hit'', ''Best Reciprocal Hit''),
               lastupdateddate = now()
               where databasesearchstudy = blastsearch2 and
               hitsequence = currentquery  and
               querysequence = forwardmspids[minfindex[reciprocalindex]];
            end if;

            reciprocalcount := reciprocalcount + 1;
         end if;

         fetch querycursor into currentquery;
   
      end LOOP;

      close querycursor;

      return reciprocalcount;

    END;
'
LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION annotateOrthologs(int4, int4, boolean, boolean, boolean) RETURNS int4 AS
'
-- this uses the results of annotateReciprocalTophits, to annotate orthologs.
-- Orthologs can be annotated provided that the orthology relationship
-- between the databases is (at least) injective
-- The injective searh would be from a database consisting of, and only of, orthoseqs,
-- , to a database consisting of orthoseqs plus possibly additional seqs.
-- This algorithm (almost) enforces the injective ortholog relationship betwen the
-- databases. Note that in fact you could (I think) still get a many to one relationship 
-- from this where more than one orthoseq matched a given target seq. This would
-- be unusual as the best reciprocal blast filter should have prevented this 
--
   DECLARE
      querycursor refcursor;
      queryrecord record;
      lastquery integer;

      Injectionblastsearch ALIAS for $1;
      Surjectionblastsearch ALIAS for $2;
      annotateInjectionSearch ALIAS for $3;
      annotateSurjectionSearch ALIAS for $4;
      usegenetable ALIAS for $5;

      orthologcount integer;
   BEGIN   
      -- master query to loop through all seqs to be considered. The algorithm is simply to 
      -- annotate the first pair encountered for each query as ortholog pair.

      orthologcount := 0;
      lastquery := -1;

      if not usegenetable then
        open querycursor for
    	select 
       	   i.querysequence,
           i.hitsequence,
           i.hitevalue + s.hitevalue as rpevalue,
           iaf.score + saf.score as rpscore
        from 
           ((databasesearchobservation i join
           databasesearchobservation s on
           i.querysequence = s.hitsequence and
           i.hitsequence = s.querysequence) join
           sequencealignmentfact iaf on iaf.databasesearchobservation = i.obid) join
           sequencealignmentfact saf on saf.databasesearchobservation = s.obid
        where
           i.databasesearchstudy = Injectionblastsearch and
           s.databasesearchstudy = Surjectionblastsearch and
           i.userflags like ''%Best Reciprocal Hit%''
        order by
           i.querysequence,
           i.hitevalue + s.hitevalue asc,
           iaf.score + saf.score desc;
      else
        open querycursor for
    	select 
           gpl.geneticob as gene,
       	   i.querysequence,
           i.hitsequence,
           i.hitevalue + s.hitevalue as rpevalue,
           iaf.score + saf.score as rpscore
        from 
           (((databasesearchobservation i join
           databasesearchobservation s on
           i.querysequence = s.hitsequence and
           i.hitsequence = s.querysequence) join
           sequencealignmentfact iaf on iaf.databasesearchobservation = i.obid) join
           sequencealignmentfact saf on saf.databasesearchobservation = s.obid) join
           geneproductlink gpl on gpl.biosequenceob = i.querysequence
        where
           i.databasesearchstudy = Injectionblastsearch and
           s.databasesearchstudy = Surjectionblastsearch and
           i.userflags like ''%Best Reciprocal Hit%'' 
        order by
           gpl.geneticob,
           i.hitevalue + s.hitevalue asc,
           iaf.score + saf.score desc;
      end if;

      fetch querycursor into queryrecord;

      while found  LOOP
         if not usegenetable then
            if lastquery != queryrecord.querysequence then
               if annotateInjectionSearch then
                  update databasesearchobservation
                  set userflags = coalesce(userflags || '',Ortholog'', ''Ortholog''),
                  lastupdateddate = now()
                  where databasesearchstudy = Injectionblastsearch and 
                  querysequence = queryrecord.querysequence and
                  hitsequence = queryrecord.hitsequence;
               end if;

               if annotateSurjectionSearch then
                  update databasesearchobservation
                  set userflags = coalesce(userflags || '',Ortholog'', ''Ortholog''),
                  lastupdateddate = now()
                  where databasesearchstudy = Surjectionblastsearch and
                  hitsequence = queryrecord.querysequence  and
                  querysequence = queryrecord.hitsequence;
               end if;
               orthologcount := orthologcount + 1;
            end if;
            lastquery := queryrecord.querysequence;
         else
            if lastquery != queryrecord.gene then
               if annotateInjectionSearch then
                  update databasesearchobservation
                  set userflags = coalesce(userflags || '',Ortholog'', ''Ortholog''),
                  lastupdateddate = now()
                  where databasesearchstudy = Injectionblastsearch and 
                  querysequence = queryrecord.querysequence and
                  hitsequence = queryrecord.hitsequence;
               end if;

               if annotateSurjectionSearch then
                  update databasesearchobservation
                  set userflags = coalesce(userflags || '',Ortholog'', ''Ortholog''),
                  lastupdateddate = now()
                  where databasesearchstudy = Surjectionblastsearch and
                  hitsequence = queryrecord.querysequence  and
                  querysequence = queryrecord.hitsequence;
               end if;
               orthologcount := orthologcount + 1;
            end if;   
            lastquery := queryrecord.gene;
      
         end if;

         fetch querycursor into queryrecord;
   
      end LOOP;

      close querycursor;

      return orthologcount;

    END;
'
LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION getSequenceOrthologSequence(int4, int4) RETURNS int4 AS
'
   DECLARE
      queryCursor refcursor;
      myOrth integer;
      querySequence ALIAS for $1;
      injectionBlastSearch ALIAS for $2;
   BEGIN   
      myOrth := null;

      open queryCursor for 
      select
         dbo.hitsequence
      from    
         databasesearchobservation dbo where
         dbo.databasesearchstudy = injectionBlastSearch and
         dbo.querysequence = querySequence and
         dbo.userflags like  ''%Ortholog%'';

      fetch queryCursor into myOrth;
     
      if not found then
         close queryCursor;
         open queryCursor for 
         select
            dbo.querysequence
         from    
            databasesearchobservation dbo where
            dbo.databasesearchstudy = injectionBlastSearch and
            dbo.hitsequence = querySequence and
            dbo.userflags like  ''%Ortholog%'';

         fetch queryCursor into myOrth;

      end if;

      close queryCursor;

      return myOrth;
   END;
'
LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION getGeneOrthologSequence(int4, int4) RETURNS int4 AS
'
   DECLARE
      queryCursor refcursor;
      myOrth integer;
      queryGene ALIAS for $1;
      injectionBlastSearch ALIAS for $2;
   BEGIN   
      myOrth := null;

      open queryCursor for 
      select
         dbo.hitsequence
      from
         ((geneticob g join geneproductlink gpl on
         gpl.geneticob = g.obid)  join
         databasesearchobservation dbo on
         dbo.databasesearchstudy = injectionBlastSearch and
         dbo.querysequence = gpl.biosequenceob and
         dbo.userflags like  ''%Ortholog%'') 
      where
         g.obid = queryGene;

      fetch queryCursor into myOrth;

      if not found then
         close queryCursor;

         open queryCursor for 
         select
            dbo.querysequence
         from
            ((geneticob g join geneproductlink gpl on
            gpl.geneticob = g.obid)  join
            databasesearchobservation dbo on
            dbo.databasesearchstudy = injectionBlastSearch and
            dbo.hitsequence = gpl.biosequenceob and
            dbo.userflags like  ''%Ortholog%'') 
         where
            g.obid = queryGene;

         fetch queryCursor into myOrth;

      end if;


      close queryCursor;

      return myOrth;

   END;
'
LANGUAGE plpgsql;



/*

to undo : 

update databasesearchobservation set userflags = replace(userflags,',Ortholog','') where userflags like '%Ortholog%';
           i.databasesearchstudy = 62991737 and
           s.databasesearchstudy = 62626632 and


select annotateOrthologs(62991737, 62626632, true, true, true);
*/


/*
example : 

 35451633 | DatabaseSearch.Btau4.GLEAN CDS.Protocol.blastn.Bovine ESTs against Btau4 GLEAN CDS  <---- Database.Protocol : 122949 Queries
 37524635 | DatabaseSearch.AgResearch.Bovine EST.Protocol.blastn.Bovine ESTs against Btau4 GLEAN CDS <---- Database.Protocol : 16,076 Queries


select annotateReciprocalTophits2(35451633, 37524635);

select getTopSearchHit(36101312, 35451633);

*/

/*
35451762 | DatabaseSearch.Btau4.GLEAN CDS.Protocol.blastn.Bovine CS34 Contigs against Btau4 GLEAN CDS
 37717014 | DatabaseSearch.AgResearch.CS34.Protocol.blastn.Bovine CS34 Contigs against Btau4 GLEAN CDS


select annotateReciprocalTophits(35451762, 37717014,5,True,True);
select annotateReciprocalTophits(35451633, 37524635,5,True,True);
select annotateReciprocalTophits(62626632, 62991737,5,True,True);


Platypus examples :

obid 64717138 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.Orthodb.Proteins.Protocol.paralign.Platypus proteins against Orthodb proteins 


obid 65334394 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.Ornithorhynchus_anatinus.Proteins.Protocol.paralign.Orthodb proteins against Platypus proteins 



select annotateReciprocalTophits(64717138 , 65334394,5,True,True);
 annotatereciprocaltophits
---------------------------
                     20199
(1 row)


select annotateOrthologs(65334394, 64717138, true, true, true);
 annotateorthologs
-------------------
              8036


Human example : 

obid 69634234 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.Orthodb.Proteins.Protocol.blastx.Human placental ESTs against Human Orthodb proteins 

obid 69647804 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.Homo_sapiens.Placental ESTs.Protocol.tblastn.Human Orthodb proteins against placental ESTs 


select annotateReciprocalTophits(69634234  , 69647804 ,5,True,True);

agrbrdf=> select annotateReciprocalTophits(69634234  , 69647804 ,5,True,True);
 annotatereciprocaltophits
---------------------------
                      3354


select annotateOrthologs(69647804   , 69634234, true, true, true);


Bovine EST Example : 

obid 69694034 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.Orthodb.Proteins.Protocol.blastx.AgResearch Bovine ESTs against Human Orthodb proteins 

obid 69693935 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.AgResearch.Bovine EST.Protocol.tblastn.Human Orthodb proteins against agResearch bovine ESTs 


select annotateReciprocalTophits(69694034  , 69693935 ,5,True,True);

select annotateOrthologs(69693935   , 69694034, true, true, true);


ArrayExpress and Zebra Example

lastupdateddate 2009-12-11 00:00:00.00 
obid 69739750 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.Zebrafinch.Protocol.paralign.Array Express Proteins against Zebrafinch proteins 


obid 69773914 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.ArrayExpress.Placenta.Protocol.paralign.Zebrafinch proteins against Array Express proteins 

select annotateReciprocalTophits(69739750  , 69773914  ,5,True,True);

select annotateOrthologs(69739750, 69773914 , true, true, false);




obid 69990059 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.Ornithorhynchus_anatinus.Proteins.Protocol.paralign.Array Express Proteins against Platypus 

obid 70020311 
obkeywords None 
obtypeid 320 
statuscode 1 
xreflsid DatabaseSearch.ENSEMBL.ArrayExpress.Placenta.Protocol.paralign.Platypus proteins against Array Express proteins 

select annotateReciprocalTophits(69990059  , 70020311 ,5,True,True);
select annotateOrthologs(69990059, 70020311  , true, true, false);

*/



/***********************************************************************
*
* Functional Assay tables
***********************************************************************
* 
*
* The functionalAssayStudy is a relation between
*
* 
- a bioSampleList 
- a labResourceList 
- a protocolOb
*
* functionalAssayStudy includes HTP cell based assays of pro/antiinflammatory activity etc
*
*
* A functionalAssayObservation table is a link  between a functionalAssayStudy and a 
* a functionalAssayfact table and contains the observations 
*
*/
/*
* Set up the functional assay entries in the ontology of lab resources
*/
\echo updating labResource table for functional assay
insert into ontologyTermFact(ontologyOb,xreflsid,termName) select obid,'LABRESOURCE_TYPES.Functional Assay','Functional Assay' from ontologyOb where ontologyName = 'LABRESOURCE_TYPES';
commit;


/*
* functionalAssayFact table attached to the labResourceOb table
*/


insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('FUNCTIONALASSAYTYPE_ONTOLOGY','This ontology provides standard terms for the types of functional assays','ontology.FUNCTIONALASSAYTYPE_ONTOLOGY');
\echo initialising database search study type ontology 
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'FUNCTIONALASSAYTYPE_ONTOLOGY.Prebiotic Activity','Prebiotic Activity','This assay measures ability of a substance to promote or inhibit growth of probiotic and pathogenic bacteria' from ontologyOb where ontologyName = 'FUNCTIONALASSAYTYPE_ONTOLOGY';
insert into ontologyTermFact(ontologyOb,xreflsid,termName,termdescription) select obid,'FUNCTIONALASSAYTYPE_ONTOLOGY.ImmunoAssay','ImmunoAssay','This assay measures ability of a substance to promote or inhibit inflammatory response' from ontologyOb where ontologyName = 'FUNCTIONALASSAYTYPE_ONTOLOGY';


\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(435,'Functional Assay','functionalAssayFact',TRUE,'Functional Assay',TRUE,'functionalassay.jpg');
\echo creating functionalAssayFact
create table functionalAssayFact (
   labResourceOb integer not null references labResourceOb(obid),
   assayName varchar(256),
   assayDescription text,
   assayType varchar(128),
   check(obtypeid = 435), 
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 435,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON functionalAssayFact
    FOR EACH ROW EXECUTE PROCEDURE setObType(435);
\echo attaching ontology check. 
CREATE FUNCTION checkFunctionalAssayTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        select into terms  * from ontologytermfact where termname = NEW.assayType and 
                       ontologyob = (select obid from ontologyOb where ontologyName = ''FUNCTIONALASSAYTYPE_ONTOLOGY'');
        if not FOUND then
           RAISE EXCEPTION ''% is not a valid assaytype '', NEW.assayType;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkFunctionalAssayTypeOntology BEFORE INSERT OR UPDATE ON functionalAssayFact
    FOR EACH ROW EXECUTE PROCEDURE checkFunctionalAssayTypeOntology();
commit;


/*
* 
a functional assay study relates :

- a bioSampleList (core schema)
- a labResourceList (core schema)

   the assay is a labResource

- an bioProtocolOb (core schema), recording aspects of the assay method

*/
\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,displayurl)
values(440, 'Functional Assay Study','functionalAssayStudy',TRUE,'Functional Assay Study',TRUE,'functionalassay.jpg');
\echo creating functionalAssayStudy
create table functionalAssayStudy (
   bioSampleOb integer not null references bioSampleOb(obid),  
   bioSampleList integer references bioSampleList(obid),
   labResourceList integer references labResourceList(obid),
   labResourceOb integer references labResourceOb(obid),
   bioProtocolOb integer references bioProtocolOb(obid),
   studydescription text,
   check(obtypeid = 440),
   unique(obid) )
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 440,   obtypeid,   'biosampleob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 440,   obtypeid,   'biosamplelist' from obtype where  upper(tablename) = 'BIOSAMPLELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 440,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 440,   obtypeid,   'labResourceOb' from obtype where  upper(tablename) = 'LABRESOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 440,   obtypeid,   'bioProtocolOb' from obtype where  upper(tablename) = 'BIOPROTOCOLOB';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON functionalAssayStudy
    FOR EACH ROW EXECUTE PROCEDURE setObType(440);



/*
* functionalassaystudyFact table attached to the functional assay study table 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(445,'Functional Assay Study Fact','functionalAssayStudyFact',FALSE,'Functional Assay Study Fact',TRUE,'functionalassay.jpg');
\echo creating functionalAssayStudyFact
create table functionalAssayStudyFact (
   functionalAssayStudy integer not null references functionalAssayStudy(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 445,   obtypeid,   'functionalAssayStudy' from obtype where  upper(tablename) = 'FUNCTIONALASSAYSTUDY';



CREATE OR REPLACE FUNCTION getfunctionalassaystudycharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        studyobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from functionalAssayStudyFact 
      where functionalAssayStudy = studyobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



/*
* Observation table attached to the functionalassaystudy table. This contains both raw and normalised
* observation data
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop,displayurl)
values(450,'Functional Assay Observation','functionalAssayObservation',TRUE,'Functional Assay Observation',TRUE,'functionalassay.jpg');
\echo creating functionalAssayObservation
create table functionalAssayObservation (
   functionalAssayStudy integer not null references functionalAssayStudy(obid),
   functionalAssayFact integer references functionalAssayFact(obid),
   plateid varchar(64),
   plateX varchar(8),
   plateY varchar(8),   
   rawDataRecord text,
   observationcomment varchar(1024),
   observationdate date,
   labbookreference varchar(16),
   codedresult varchar(64),
   check(obtypeid = 450) ,
   unique(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 450,   obtypeid,   'functionalAssayStudy' from obtype where  upper(tablename) = 'FUNCTIONALASSAYSTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 450,   obtypeid,   'functionalAssayFact' from obtype where  upper(tablename) = 'FUNCTIONALASSAYFACT';
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON functionalAssayObservation
    FOR EACH ROW EXECUTE PROCEDURE setObType(450);



/*
* functionalAssayObservationFact table attached to functionalAssayObservation. This can be used to 
* store the various reporter gene etc names , which in general will be a fairly
* disparate set 
*/
\echo setting up ontology for functionalAssayDataPoints
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('FUNCTIONALASSAY_DATAPOINTS','This ontology provides standard terms , and descriptiona , for the various datapoints stored in the functionalAssayObservationFact table (e.g. SEAP etc)','ontology.FUNCTIONALASSAY_DATAPOINTS');
\echo initialising workflow ontology with term names
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'FUNCTIONALASSAY_DATAPOINTS.SEAP','SEAP','Secreted Alkaline Phosphatase Reporter Gene Chemiluminescence Reporter Gene data point' from ontologyOb where ontologyName = 'FUNCTIONALASSAY_DATAPOINTS';
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'FUNCTIONALASSAY_DATAPOINTS.WST-1','WST-1','Data point in the HTP Screen assays related to SEAP' from ontologyOb where ontologyName = 'FUNCTIONALASSAY_DATAPOINTS';
commit;


\echo initialising optype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription,isop)
values(455,'Functional Assay Observation Fact','functionalAssayObservationFact',FALSE,'Functional Assay Observation Fact',TRUE);
\echo creating functionalAssayObservationFact
create table functionalAssayObservationFact (
   functionalAssayObservation integer not null references functionalAssayObservation(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 455,   obtypeid,   'functionalAssayObservation' from obtype where  upper(tablename) = 'FUNCTIONALASSAYOBSERVATION';


CREATE OR REPLACE FUNCTION getfunctionalassayobservationcharfact(int4, "varchar", "varchar")
  RETURNS "varchar" AS
'
    DECLARE
        factcursor refcursor;
        observationobid ALIAS for $1;
        myfactnamespace ALIAS for $2;
        myattributename ALIAS for $3;
        myattributevalue varchar;
    BEGIN
      open factcursor for
      select trim(attributevalue) from functionalAssayObservationFact 
      where functionalAssayObservation = observationobid and   
      factnamespace = myfactnamespace and 
      attributename = myattributename;

      fetch factcursor into myattributevalue;
      close factcursor;
      return myattributevalue;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



/***********************************************************************
*
* the core search engine of the database
* 
* The engine is given a search string, username, maximum result size, and which object type to 
* search for.
*
* It returns the id of either a new or existing list.
*
* Existing lists are checked - if there is an existing list with the same signature as the 
* query , and a created date < useOldLimit days ago, then the id of the existing list is returned.
*
* (Note that to implement search strategies where a user wishes to search for more than 
* one type of object, this method would be called once for each type of object. A list of 
* lists would then be created)
*
*************************************************************************/



/*
* function to archive search result lists - this means that the search engine will
* redo the search rather than use the cached search results in the search result list. 
* This is called in an after-insert-or-update-or-delete 
* trigger on various tables -  you can disable it by setting a value in the 
* brdffact table - for example if doing a large number of updates. 
*
* Note that Archiving is implemented by adding the prefix "Archive" to the list definition - this
* ensures that the list definition does not match  a search pattern so the list
* will not be used.
* List definitions have a pattern like 
* "Search of Data Files Submitted for %T100%IL% (limited to first 1000 hits)"
* 
* The search engine aliases are defined in an ontology called
* BRDFTableSearchAliases - the term name is the alias known to the search engine.
* The ontologytermfact2 table stores the names of tables that are associated with the search term - 
* this function can therefore look up the search engine alias(es) associated with the tablename
* it is given, and update all of the lists whose definition matches the alias.
*
* (aliases that are given to the search engine usually correspond roughly to tables - e.g.
* if the search engine is asked to search for "BioSubjects" then it will search the 
* biosubjectob table. However in many cases , it will also search additional tables
* - e.g. if it is asked to search for sequences, it will first search the biosequenceob
* table to look for sequence-name matches. However it will also go on to keyword-search the blast-results
* table if it does not get a match on name. )
*
*/

\echo setting up ontology for brdftablesearchaliases
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BRDF_TABLESEARCH_ALIASES','This ontology lists aliases used by the search engine','ontology.BRDF_TABLESEARCH_ALIASES');
\echo initialising search aliases ontology with term names

/*
* biosubject searches - only the biosubjectob table is searched
*/
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'BRDF_TABLESEARCH_ALIASES.BIOSUBJECTS','BIOSUBJECTS','The search engine will search the biosubjectob table when asked to search for biosubjects' from ontologyOb where ontologyName = 'BRDF_TABLESEARCH_ALIASES';
insert into ontologytermfact2(ontologytermid, factnamespace, attributename, attributevalue)
   select 
      otf.obid,
      'TABLES SEARCHED',
      'TABLENAME',
      'biosubjectob'
   from 
      ontologyob o join ontologytermfact otf on
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.ontologyob = o.obid
   where
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.termname = 'BIOSUBJECTS';

/*
* etc....more terms to be added for other search aliases 
*/
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'BRDF_TABLESEARCH_ALIASES.ALL LAB RESOURCES','ALL LAB RESOURCES','The search engine will search the labresourceob table when asked to search for all lab resources' from ontologyOb where ontologyName = 'BRDF_TABLESEARCH_ALIASES';
insert into ontologytermfact2(ontologytermid, factnamespace, attributename, attributevalue)
   select 
      otf.obid,
      'TABLES SEARCHED',
      'TABLENAME',
      'labresourceob'
   from 
      ontologyob o join ontologytermfact otf on
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.ontologyob = o.obid
   where
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.xreflsid = 'BRDF_TABLESEARCH_ALIASES.ALL LAB RESOURCES';


insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'BRDF_TABLESEARCH_ALIASES.GENETIC TESTS','GENETIC TESTS','The search engine will search the labresourceob , genetictestfact tables when asked to search for genetic tests' from ontologyOb where ontologyName = 'BRDF_TABLESEARCH_ALIASES';
insert into ontologytermfact2(ontologytermid, factnamespace, attributename, attributevalue)
   select 
      otf.obid,
      'TABLES SEARCHED',
      'TABLENAME',
      'labresourceob'
   from 
      ontologyob o join ontologytermfact otf on
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.ontologyob = o.obid
   where
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.xreflsid = 'BRDF_TABLESEARCH_ALIASES.GENETIC TESTS';
insert into ontologytermfact2(ontologytermid, factnamespace, attributename, attributevalue)
   select 
      otf.obid,
      'TABLES SEARCHED',
      'TABLENAME',
      'genetictestfact'
   from 
      ontologyob o join ontologytermfact otf on
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.ontologyob = o.obid
   where
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.xreflsid = 'BRDF_TABLESEARCH_ALIASES.GENETIC TESTS';

insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'BRDF_TABLESEARCH_ALIASES.GENETIC TEST ASSAYS','GENETIC TEST ASSAYS','The search engine will search the labresourceob ,genotypestudy, genotypeobservation, genetictestfact tables when asked to search for genetic test assays' from ontologyOb where ontologyName = 'BRDF_TABLESEARCH_ALIASES';
insert into ontologytermfact2(ontologytermid, factnamespace, attributename, attributevalue)
   select 
      otf.obid,
      'TABLES SEARCHED',
      'TABLENAME',
      'genotypestudy'
   from 
      ontologyob o join ontologytermfact otf on
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.ontologyob = o.obid
   where
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.xreflsid = 'BRDF_TABLESEARCH_ALIASES.GENETIC TEST ASSAYS';
insert into ontologytermfact2(ontologytermid, factnamespace, attributename, attributevalue)
   select 
      otf.obid,
      'TABLES SEARCHED',
      'TABLENAME',
      'genotypeobservation'
   from 
      ontologyob o join ontologytermfact otf on
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.ontologyob = o.obid
   where
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.xreflsid = 'BRDF_TABLESEARCH_ALIASES.GENETIC TEST ASSAYS';


insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) select obid,'BRDF_TABLESEARCH_ALIASES.GENOTYPE EXPERIMENTS','GENOTYPE EXPERIMENTS','The search engine will search genotypestudy, genotypeobservation tables when asked to search for genotype experiments' from ontologyOb where ontologyName = 'BRDF_TABLESEARCH_ALIASES';
insert into ontologytermfact2(ontologytermid, factnamespace, attributename, attributevalue)
   select 
      otf.obid,
      'TABLES SEARCHED',
      'TABLENAME',
      'genotypestudy'
   from 
      ontologyob o join ontologytermfact otf on
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.ontologyob = o.obid
   where
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.xreflsid = 'BRDF_TABLESEARCH_ALIASES.GENOTYPE EXPERIMENTS';
insert into ontologytermfact2(ontologytermid, factnamespace, attributename, attributevalue)
   select 
      otf.obid,
      'TABLES SEARCHED',
      'TABLENAME',
      'genotypeobservation'
   from 
      ontologyob o join ontologytermfact otf on
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.ontologyob = o.obid
   where
      o.ontologyname = 'BRDF_TABLESEARCH_ALIASES' and
      otf.xreflsid = 'BRDF_TABLESEARCH_ALIASES.GENOTYPE EXPERIMENTS';


/*
* stored function used in a trigger to clear cached searches on update of tables
*/
CREATE or REPLACE FUNCTION archiveSearchResultList() RETURNS trigger VOLATILE AS '
   DECLARE
      tableCursor refcursor;
      searchalias varchar(256);
      message varchar(1024);
      triggerconfig varchar(256);
      
   BEGIN
      triggerconfig := ''DISABLED'';

      /* 
      * check if triggers enabled - e.g. may want to disable for batch 
      * updates 
      */
      select 
         upper(attributevalue) into triggerconfig
      from
         brdffact
      where
         factnamespace = ''SEARCH CACHE'' and
         attributename = ''TRIGGERS'';

      if triggerconfig != ''ENABLED'' then
         return null;
      end if;
     

      /*
      * get all of the search aliases in the 
      * that relate to this table 
      */
      open tableCursor for 
      select
         otf.termname
      from 
         (ontologyob o join ontologytermfact otf on
         o.ontologyname = ''BRDF_TABLESEARCH_ALIASES'' and
         otf.ontologyob = o.obid) join ontologytermfact2 otf2 on 
         otf2.ontologytermid  = otf.obid
      where
         o.ontologyname = ''BRDF_TABLESEARCH_ALIASES'' and
         otf2.factnamespace  = ''TABLES SEARCHED'' and
         otf2.attributename = ''TABLENAME'' and
         upper(otf2.attributevalue) = upper(TG_RELNAME);


      /* 
      * for each search alias, archive the searches that 
      * relate to this alias
      */
      fetch tableCursor into searchalias;

      while FOUND loop
         update oblist set listdefinition = ''Archived : '' || listdefinition
         where listtype = ''SEARCH_RESULT'' and
         upper(listdefinition) like ''SEARCH OF '' || upper(searchalias) || ''%'';

         message := ''SEARCH OF '' || upper(searchalias) || ''%'';

         --raise NOTICE ''%'', message;

         fetch tableCursor into searchalias;
      end loop;

      close tableCursor;

      return null;     
   END;
' LANGUAGE plpgsql;

CREATE TRIGGER biosubject_search_archive
AFTER INSERT OR UPDATE OR DELETE ON biosubjectob
    FOR EACH ROW EXECUTE PROCEDURE archiveSearchResultList();

CREATE TRIGGER genotypeobservation_search_archive
AFTER INSERT OR UPDATE OR DELETE ON genotypeobservation
    FOR EACH ROW EXECUTE PROCEDURE archiveSearchResultList();

CREATE TRIGGER genotypestudy_search_archive
AFTER INSERT OR UPDATE OR DELETE ON genotypestudy
    FOR EACH ROW EXECUTE PROCEDURE archiveSearchResultList();

CREATE TRIGGER labresourceob_search_archive
AFTER INSERT OR UPDATE OR DELETE ON labresourceob
    FOR EACH ROW EXECUTE PROCEDURE archiveSearchResultList();

CREATE TRIGGER genetictestfact_search_archive
AFTER INSERT OR UPDATE OR DELETE ON genetictestfact
    FOR EACH ROW EXECUTE PROCEDURE archiveSearchResultList();





/* 
manual archiving is done like this : 
update oblist set
listdefinition = 'Archived : ' || listdefinition
where listtype = 'SEARCH_RESULT' and
listdefinition not like 'Archived%'
*/


CREATE or replace FUNCTION getSearchResultList(text, varchar, integer, varchar, integer, integer, varchar) RETURNS integer VOLATILE AS '
    DECLARE
       obCursor refcursor;
       obCursor2 refcursor;
       obCursor3 refcursor;


       searchTextArg ALIAS FOR $1;
       userName ALIAS FOR $2;
       maxListSize ALIAS FOR $3;
       obTypeName ALIAS FOR $4;
       useOldLimit ALIAS FOR $5;
       argListID ALIAS FOR $6;
       argListName ALIAS FOR $7;

       elementCount integer;
       tempCount integer;
       listid integer;
       listitem integer;
       listitem2 integer;
       listitem3 integer;
       obvar1 integer;
       textvar1 varchar;
       listxreflsid varchar;
       listxreflsid2 varchar;
       listxreflsid3 varchar;
       listcomment varchar;
       listcomment2 varchar;
       listcomment3 varchar;
       signature text;
       wildCardChar varchar;
       dollarChar varchar;
       searchText varchar;
       --existingListID varchar; new version of postgres strict
       existingListID integer;
       sensitivity integer;
    BEGIN
       -- ********** hard-coded PARAMETERS ************ ---
       sensitivity := 1;  -- use 2 or 3 for SG **** set this via arg list at some point ****

       -- locals 
       elementCount := 0;
       wildCardChar := ''%'';
       /* dollarChar := ''$''; */

       searchText := searchTextArg;

       -- if the user has provided a wildcard , do not insert one ourselves - also , support * wildcard
       if position(''*'' in searchText) > 0 then
          searchText := translate(searchText,''*'',wildCardChar);
       end if;
       if position(wildCardChar in searchText) > 0  then
          wildCardChar := '''';
       end if;

       existingListID := argListID;
       if existingListID is null then
          existingListID  := 0;
       end if;



       -- check if there is an existing list with the same signature, if useOldLimit >= 0, and if we have not been given an existing list to update
       /* signature := searchText || dollarChar || maxListSize || dollarChar || obTypeName; */
       -- signature = ''Search of '' || obTypeName || '' for '' || searchText || '' (limited to first '' || maxListSize || '' hits)'';
       signature = ''Search of '' || obTypeName || '' for '' || searchText || '' (limited to first '' || to_char(maxListSize,''FM9999999999'') || '' hits)'';


       if upper(obTypeName) != ''PAST SEARCHES'' and upper(obTypeName) != ''COMMENTS'' and upper(obTypeName) != ''EXTERNAL LINKS'' 
                      and upper(obTypeName) != ''DATA FILES SUBMITTED'' and useOldLimit >= 0 and existingListID = 0 then
          select obid into listid from oblist where listdefinition = signature and statuscode > 0;
       end if;

       if (not FOUND ) or  not (upper(obTypeName) != ''PAST SEARCHES'' and upper(obTypeName) != ''COMMENTS'' and upper(obTypeName) != ''EXTERNAL LINKS'' 
                      and upper(obTypeName) != ''DATA FILES SUBMITTED'' and useOldLimit >= 0 and existingListID = 0 ) then
          if existingListID = 0 then
              -- create the list 
             open obCursor for select nextval(''ob_obidseq'');
             fetch obCursor into listid;
             close obCursor; 

             if argListName is not null then 
                signature := argListName;
             end if;
             

             insert into obList(obid,listName,listType,listDefinition,xreflsid,maxMembership,createdBy,displayurl)
             /* values(listid,''Search hits : '' || obTypeName ,''SEARCH_RESULT'', searchText || dollarChar || maxListSize || dollarChar || obTypeName,searchText || dollarChar || maxListSize || dollarChar || obTypeName, maxListSize, userName); */
             values(listid,''Search hits : '' || obTypeName ,''SEARCH_RESULT'', signature,signature, maxListSize, userName,''search.gif'');

          else
             listid = existingListID;
          end if;
       
    
          -- populate the list. For each type there is an ordering to ensure that 
          -- the most relevant objects occur first in the list. Each type may involve searches of 
          -- several different database fields


          --*************************************************************************
          --* search for genes                   
          --*
          --*************************************************************************
          --- searching for Genetic Objects
          -- note the changes to the "lsid" that is stored as part of the hit - this is cosmetic due
          -- to user request , they do not like the "geneticob." prefix
          if upper(obTypeName) = ''GENETIC TABLES'' then

             -- if the search string does not contain a wildcard then first try to find an exact match on name 
             -- -  if we succeed then go no further
             -- first , name in gene table....
             if position(wildCardChar in searchText) = 0  then
                open obCursor for select obid , replace(xreflsid,''geneticob.'','''') , 
                coalesce(geneticobsymbols || '' ''|| geneticobdescription ,
                         geneticobsymbols,
                         replace(xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
                from geneticob where lower(geneticobname) = lower(searchText);
                fetch obCursor into listitem, listxreflsid, listcomment;
                if FOUND then
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                end if;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;

                -- now try exact match on aliases
                if elementCount = 0 then               -- OK it must be 0 anyway but leave this in
                   open obCursor for select ontologyob from ontologytermfact where lower(termname) =
                   lower(searchText) and xreflsid like ''ontology.HOMOLOGENE_ALIASES%'';
                   fetch obCursor into obvar1;
                   if elementCount < maxListSize and FOUND then
                      open obCursor2 for select g.obid, replace(g.xreflsid,''geneticob.'',''''), 
                         coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
                      from predicatelink pl join geneticob g on 
                      pl.subjectob = g.obid and pl.objectob = obvar1;
                      fetch obCursor2 into listitem,listxreflsid, listcomment;
                      close obCursor2;
                      if listitem is not null then
    	                 insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                         elementCount := elementCount + 1;
                      end if;
                   end if;
                   close obCursor;
                end if;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;

                -- now try exact match on sequences
                if elementCount = 0 then               -- OK it must be 0 anyway but leave this in
                   open obCursor for select obid from biosequenceob where sequencename  = searchText;
                   fetch obCursor into obvar1;
                   while elementCount < maxListSize and FOUND LOOP
                      open obCursor2 for select g.obid, replace(g.xreflsid,''geneticob.'',''''),                         
			 coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
                      from geneproductlink gpl join geneticob g on 
                      gpl.geneticob = g.obid and gpl.biosequenceob = obvar1;
                      fetch obCursor2 into listitem,listxreflsid, listcomment;
                      close obCursor2;
                      if listitem is not null then
    	                 insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                         elementCount := elementCount + 1;
                      end if;
                      fetch obCursor into obvar1;
                   end loop;
                   close obCursor;
                end if;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;

             end if; -- no wildcards used - try exact match on names and return immediately if found


             -- add items whose name matches the query
             open obCursor for select obid , replace(xreflsid,''geneticob.'','''') , 
                         coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
             from geneticob as g where lower(geneticobname) like lower(wildCardChar||searchText||wildCardChar)
                        or lower(geneticObSymbols) like lower(wildCardChar||searchText||wildCardChar) ; 
             fetch obCursor into listitem, listxreflsid, listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid, listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


             -- from here we only keep searching if there are not "enough" hits already.
             -- search the aliases ontology. Currently this code is somewhat too specific to 
             -- SGP but we may built gene indexes in general
             if elementCount < 5 then
                open obCursor for select ontologyob from ontologytermfact where lower(termname) like
                lower(wildCardChar||searchText||wildCardChar) and xreflsid like ''ontology.HOMOLOGENE_ALIASES%'';
                fetch obCursor into obvar1;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor2 for select g.obid, replace(g.xreflsid,''geneticob.'',''''),
			 coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
                   from predicatelink pl join geneticob g on 
                   pl.subjectob = g.obid and pl.objectob = obvar1;
                   fetch obCursor2 into listitem,listxreflsid, listcomment;
                   close obCursor2;
                   if listitem is not null then
	              insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                   end if;
                   fetch obCursor into obvar1;
                end loop;
                close obCursor;
             end if;



             -- search the titles ontology. Currently this code is somewhat too specific to 
             -- SGP but we may built gene indexes in general
             if elementCount < 15 then
                open obCursor for select ontologyob from ontologytermfact where lower(termname) like
                lower(wildCardChar||searchText||wildCardChar) and xreflsid like ''ontology.HOMOLOGENE_TITLES%'';
                fetch obCursor into obvar1;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor2 for select g.obid, replace(g.xreflsid,''geneticob.'',''''),
                         coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
                   from predicatelink pl join geneticob g on 
                   pl.subjectob = g.obid and pl.objectob = obvar1;
                   fetch obCursor2 into listitem,listxreflsid, listcomment;
                   close obCursor2;
                   if listitem is not null then
	              insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                   end if;
                   fetch obCursor into obvar1;
                end loop;
                close obCursor;
             end if;




             -- search the unigenes ontology. Currently this code is somewhat too specific to 
             -- SGP but we may built gene indexes in general
             if elementCount < 30 then
                open obCursor for select ontologyob from ontologytermfact where lower(termname) like
                lower(wildCardChar||searchText||wildCardChar) and xreflsid like ''ontology.HOMOLOGENE_UNIGENES%'';
                fetch obCursor into obvar1;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor2 for select g.obid, replace(g.xreflsid,''geneticob.'',''''),
                         coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
                   from predicatelink pl join geneticob g on 
                   pl.subjectob = g.obid and pl.objectob = obvar1;
                   fetch obCursor2 into listitem,listxreflsid, listcomment;
                   close obCursor2;
                   if listitem is not null then
	              insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                   end if;
                   fetch obCursor into obvar1;
                end loop;
                close obCursor;
             end if;



             -- search sequences. 
             if elementCount < 30 then
                open obCursor for select obid from biosequenceob where lower(sequencename) like
                lower(wildCardChar||searchText||wildCardChar) ;
                fetch obCursor into obvar1;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor2 for select g.obid, replace(g.xreflsid,''geneticob.'',''''),
                         coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
                   from geneproductlink gpl join geneticob g on 
                   gpl.biosequenceob  = obvar1 and gpl.biosequenceob = obvar1;
                   fetch obCursor2 into listitem,listxreflsid, listcomment;
                   close obCursor2;
                   if listitem is not null then
	              insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                   end if;
                   fetch obCursor into obvar1;
                end loop;
                close obCursor;
             end if;



             -- next add items whose description matches the query. We now *do* insert wildcard, even if the user has submitted one
             wildCardChar := ''%'';
             if elementCount < maxListSize then
                open obCursor for select obid,replace(xreflsid,''geneticob.'',''''), 
                         coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'') 
			 from geneticob as g where lower(geneticobdescription) like lower(wildCardChar||searchText||wildCardChar) or
                           lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar);
                fetch obCursor into listitem,listxreflsid,listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   fetch obCursor into listitem,listxreflsid, listcomment;
                   elementCount := elementCount + 1;
                end loop;
                close obCursor;
             end if; -- list not yet full


             -- next add items whose function description matches the query
             if elementCount < maxListSize then
                open obCursor for select distinct geneticob , replace(xreflsid,''geneticob.'','''') from geneticfunctionfact where lower(functioncomment) like lower(wildCardChar||searchText||wildCardChar);
                fetch obCursor into listitem,listxreflsid;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor2 for select  
                         coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
                         g.geneticobsymbols,
                         replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'') from geneticob as g where obid = listitem;
                   fetch obCursor2 into listcomment;
                   close obCursor2;
                   insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   fetch obCursor into listitem,listxreflsid,listcomment;
                   elementCount := elementCount + 1;
                end loop;
                close obCursor;
             end if; -- list not yet full

          --*************************************************************************
          --* search past searches                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''PAST SEARCHES'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from oblist where listtype = ''SEARCH_RESULT'' and lower(listdefinition) like lower(wildCardChar||searchText||wildCardChar); 
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;
         --*************************************************************************
          --* search gene lists                  
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''GENE LISTS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from geneticoblist where listtype = ''USER_PROJECT_LIST'' and 
             (lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;
         --*************************************************************************
          --* search project lists                  
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''PROJECT LISTS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from oblist where listtype = ''USER_PROJECT_LIST'' and 
             (lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


         --*************************************************************************
          --* search data source lists
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''DATASOURCE LISTS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid,listname from datasourcelist where
             (lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(listcomment) like lower(wildCardChar||searchText||wildCardChar) or 
             lower(listname) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


         --*************************************************************************
          --* search data source lists
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''DATA FORMS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid,listname from datasourcelist where
             listtype = ''Data Form'' and
             (lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(listcomment) like lower(wildCardChar||searchText||wildCardChar) or 
             lower(listname) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


         --*************************************************************************
          --* search subject cohorts
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''SUBJECT LISTS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from oblist where listtype = ''BIOSUBJECT_LIST'' and 
             (lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;



         --*************************************************************************
          --* search microarray series 
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''MICROARRAY SERIES'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from oblist where listtype = ''MICROARRAY_SERIES_LIST'' and 
             (lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


         --*************************************************************************
          --* search protocols                  
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''PROTOCOLS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from bioprotocolob where
             lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(protocolname) like lower(wildCardChar||searchText||wildCardChar) or
             lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar) or
             lower(protocoltype ) like lower(wildCardChar||searchText||wildCardChar) or
             lower(protocoldescription ) like lower(wildCardChar||searchText||wildCardChar) or
             lower(protocoltext ) like lower(wildCardChar||searchText||wildCardChar);
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


         --*************************************************************************
          --* search analysis procedures                  
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''ANALYSIS PROCEDURES'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from analysisprocedureob where
             lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(procedurename) like lower(wildCardChar||searchText||wildCardChar) or
             lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar) or
             lower(proceduretype ) like lower(wildCardChar||searchText||wildCardChar) or
             lower(proceduredescription ) like lower(wildCardChar||searchText||wildCardChar) or
             lower(sourcecode ) like lower(wildCardChar||searchText||wildCardChar);
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


         --*************************************************************************
          --* search import procedures                  
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''IMPORT PROCEDURES'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from importprocedureob where
             lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
             lower(procedurename) like lower(wildCardChar||searchText||wildCardChar) or
             lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar) or
             lower(procedurecomment ) like lower(wildCardChar||searchText||wildCardChar) or
             lower(sourcecode ) like lower(wildCardChar||searchText||wildCardChar);
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for data files submitted                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''COMPLETED REPORTS'' then
             -- add items whose name matches the query
             open obCursor for 
                select
                   dr.obid, dr.xreflsid, c.commentstring
                from
                    (((oblist o join listmembershiplink l on
                    o.xreflsid = ''Queue.simpleReportQueue_Completed'' and
                    l.oblist = o.obid) join
                    datasourceob dr on dr.obid = l.ob) left outer join commentlink cl on 
                    cl.ob = dr.obid) left outer join commentob c on c.obid= cl.commentob
		where ( lower(physicalsourceuri) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(dr.xreflsid) like lower(wildCardChar||searchText||wildCardChar) 
                      or (lower(c.commentstring) like lower(wildCardChar||searchText||wildCardChar))  );
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment,voptypeid) values (listid,listitem,listxreflsid,listcomment,29);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;



          --*************************************************************************
          --* search for data files submitted                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''DATA FILES SUBMITTED'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid,coalesce(
                          datasourcetype || ''('' || datasupplier || '' , '' || datasourcecomment|| '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || datasupplier || '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || to_char(createddate,''dd-mm-yyyy'') || '')'')
                      from datasourceob where ( lower(physicalsourceuri) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(datasourcetype) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(datasourcename) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or (lower(createdby) like lower(wildCardChar||searchText||wildCardChar)) 
                      or (lower(datasupplier) like lower(wildCardChar||searchText||wildCardChar))  );
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment,voptypeid) values (listid,listitem,listxreflsid,listcomment,29);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for data files imported                  
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''DATA FILES IMPORTED'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid,coalesce(
                          datasourcetype || ''('' || datasupplier || '' , '' || datasourcecomment|| '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || datasupplier || '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || to_char(createddate,''dd-mm-yyyy'') || '')'')
                      from datasourceob where ( lower(physicalsourceuri) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(datasourcetype) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(datasourcename) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or (lower(createdby) like lower(wildCardChar||searchText||wildCardChar)) 
                      or (lower(datasupplier) like lower(wildCardChar||searchText||wildCardChar)) ) and exists
                      (select obid from importfunction where datasourceob = datasourceob.obid);
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment,voptypeid) values (listid,listitem,listxreflsid,listcomment,29);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for contributed data tables                 
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''CONTRIBUTED DATA TABLES'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid,coalesce(
                          datasourcetype || ''('' || datasupplier || '' , '' || datasourcecomment|| '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || datasupplier || '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || to_char(createddate,''dd-mm-yyyy'') || '')'')
                      from datasourceob where datasourcetype = ''Contributed Database Table'' and  ( 
                         lower(physicalsourceuri) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasupplier) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasourcename) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasourcecomment) like lower(wildCardChar||searchText||wildCardChar) 
                      );
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for data sources that are SQL queries                 
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''SQL QUERIES'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid,coalesce(
                          datasourcetype || ''('' || datasupplier || '' , '' || datasourcecomment|| '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || datasupplier || '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || to_char(createddate,''dd-mm-yyyy'') || '')'')
                      from datasourceob where datasourcetype = ''SQL'' and  ( 
                         lower(physicalsourceuri) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasupplier) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasourcecomment) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasourcename) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasourcecontent) like lower(wildCardChar||searchText||wildCardChar) 
                      );
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;



          --*************************************************************************
          --* search for data sources that are form elements
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''FORM ELEMENTS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid,coalesce(
                          datasourcetype || ''('' || datasupplier || '' , '' || datasourcecomment|| '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || datasupplier || '' , '' || to_char(createddate,''dd-mm-yyyy'') || '')'',
                          datasourcetype || ''('' || to_char(createddate,''dd-mm-yyyy'') || '')'')
                      from datasourceob where datasourcetype = ''Form Element'' and  ( 
                         lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasupplier) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasourcecomment) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasourcename) like lower(wildCardChar||searchText||wildCardChar) or
                         lower(datasourcecontent) like lower(wildCardChar||searchText||wildCardChar) 
                      );
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for workflows                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''WORK FLOWS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from workflowob where ( lower(workflowdescription) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;
          --*************************************************************************
          --* search for workflowstages                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''WORK FLOW STAGES'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from workflowstageob where ( lower(workflowstagedescription) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;
          --*************************************************************************
          --* search for microarray experiments                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''MICROARRAY EXPERIMENTS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from geneexpressionstudy where
                   lower(studytype) like ''%microarray%'' and (
                   ( lower(xreflsid) like  lower(wildCardChar||searchText||wildCardChar))
                or ( lower(obkeywords) like lower(wildCardChar || searchText || wildCardChar))
                or ( lower(studydescription) like lower(wildCardChar || searchText || wildCardChar)));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


         --*************************************************************************
          --* search for genotype experiments                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''GENOTYPE EXPERIMENTS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from genotypestudy where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(studytype) like lower(wildCardChar||searchText||wildCardChar)) 
		      or ( lower(obkeywords) like lower(wildCardChar || searchText || wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;

         --*************************************************************************
          --* search for phenotype studies                    
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''PHENOTYPE STUDIES'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from phenotypestudy where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
		      or ( lower(obkeywords) like lower(wildCardChar || searchText || wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


         --*************************************************************************
          --* search for genetic tests                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''GENETIC TESTS'' then

             if position(wildCardChar in searchText) = 0  then
                open obCursor for select obid , xreflsid, 
                coalesce(xreflsid  || '' ''|| testdescription ,xreflsid)
                from genetictestfact where accession = searchText;
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;

                -- no hit - try wildcard 
                open obCursor for select obid,xreflsid,
                coalesce(xreflsid  || '' ''|| testdescription ,xreflsid) 
                from genetictestfact where lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar);
                fetch obCursor into listitem,listxreflsid;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
             else
                open obCursor for select obid,xreflsid from genetictestfact where lower(xreflsid) like lower(searchText);
                fetch obCursor into listitem,listxreflsid;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
             end if;
             close obCursor;

         --*************************************************************************
          --* search for genetic test runs                   
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''GENETIC TEST RUNS'' then
             -- add items whose name matches the query
             open obCursor for select obid,xreflsid from genotypeobservation where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(genotypeobserved) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(genotypeobserveddescription) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(finalgenotype) like lower(wildCardChar||searchText||wildCardChar)) 
		      or ( lower(finalgenotypedescription) like lower(wildCardChar || searchText || wildCardChar))
		      or ( lower(observationcomment) like lower(wildCardChar || searchText || wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;

          --*************************************************************************
          --* search for biosubjects                  
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''BIOSUBJECTS'' then
             -- add items whose name matches the query exactly
             tempCount := 0;
             open obCursor for select obid,xreflsid from biosubjectob where ( lower(xreflsid) = lower(searchText)) ;
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
                tempCount := tempCount + 1;
             end loop;
             close obCursor;

             -- if we got any exact matches , stop there, else search other fields
             if tempCount = 0 then
                open obCursor for select obid,xreflsid from biosubjectob where ( lower(xreflsid) like  lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(subjectspeciesname) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(subjectdescription) like lower(wildCardChar||searchText||wildCardChar));
                fetch obCursor into listitem,listxreflsid;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                   fetch obCursor into listitem,listxreflsid;
                   elementCount := elementCount + 1;
                end loop;
                close obCursor;
             end if;

          --*************************************************************************
          --* search for biosamples                 
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''BIOSAMPLES'' then
             open obCursor for select obid,xreflsid from biosampleob where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(samplename) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(sampledescription) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(samplestorage) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for batches
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''BATCHES'' then
             open obCursor for select obid,xreflsid from batchob where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(batchname) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(batchdescription) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(batchtype) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;



          --*************************************************************************
          --* search for biolibraries
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''LIBRARIES'' then
             open obCursor for select obid,xreflsid from biolibraryob where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(libraryname) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(librarydescription) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(librarystorage) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;

          --*************************************************************************
          --* search for library sequencing
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''LIBRARY SEQUENCING'' then
             open obCursor for select obid,xreflsid from librarysequencingfunction where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(runby) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(functioncomment) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;

          --*************************************************************************
          --* search for biosampling                 
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''BIOSAMPLING'' then
             open obCursor for select obid,xreflsid from biosamplingfunction where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(samplingcomment) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;

          --*************************************************************************
          --* search for ontologies                
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''ONTOLOGIES'' then
             open obCursor for select obid,xreflsid from ontologyob where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(ontologydescription) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for ontology terms
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''ONTOLOGY TERMS'' then
             -- if no wildcards try an exact match on the term
             if position(wildCardChar in searchText) = 0  then
                open obCursor for select obid , xreflsid , 
                coalesce(termname || '' ''|| termdescription ,termname)
                from ontologytermfact where termname = searchText;
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   fetch obCursor into listitem,listxreflsid, listcomment;
                   elementCount := elementCount + 1;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;
             end if;
             

             -- now try wildcard search (i.e. either they used wildcards or no hits yet)
             open obCursor for select obid,xreflsid,
                    coalesce(termname || '' ''|| termdescription ,termname)
                    from ontologytermfact where lower(termname) like lower(wildCardChar||searchText||wildCardChar);

             fetch obCursor into listitem,listxreflsid,listcomment;

             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;

             close obCursor;
             if elementCount > 0 then
                update oblist set currentmembership = elementCount where obid = listid;
                return listid;
             end if;

             -- still no hit - try description and unitname
             open obCursor for select obid,xreflsid,
                    coalesce(termname || '' ''|| termdescription ,termname)
                    from ontologytermfact where ( lower(termdescription) like lower(wildCardChar||searchText||wildCardChar))
                   or ( lower(unitname) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;

             close obCursor;

          --*************************************************************************
          --* search for databases
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''DATABASES'' then
             open obCursor for select obid,xreflsid from biodatabaseob where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(databasename) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(databasedescription) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for database search runs
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''DATABASE SEARCHES'' then
             open obCursor for select obid, xreflsid, coalesce(xreflsid  || '' : ''|| studydescription ,xreflsid)  from databasesearchstudy 
             where lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar) ;
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for lab resources
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''ALL LAB RESOURCES'' then
             open obCursor for select obid,xreflsid from labresourceob where ( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(resourcename) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(resourcedescription) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(resourcetype) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(supplier) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for microarrays
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''MICROARRAYS'' then
             open obCursor for select obid,xreflsid from labresourceob where resourcetype = ''microarray'' and (( lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(obkeywords) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(resourcename) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(resourcedescription) like lower(wildCardChar||searchText||wildCardChar))
                      or ( lower(supplier) like lower(wildCardChar||searchText||wildCardChar)));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;

          --*************************************************************************
          --* search for comments
          --*
          --*************************************************************************
          elsif upper(obTypeName) = ''COMMENTS'' then
             open obCursor for select obid,xreflsid from commentob where ( lower(createdby) like lower(searchText)) 
                      or ( lower(commentstring) like lower(wildCardChar||searchText||wildCardChar)) ;
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;

          --*************************************************************************
          --* search for uri
          --*
          --*************************************************************************
          elsif upper(obTypeName) = ''EXTERNAL LINKS'' then
             open obCursor for select obid,xreflsid from uriob where ( lower(createdby) like lower(searchText)) 
                      or ( lower(uristring) like lower(wildCardChar||searchText||wildCardChar)) 
                      or ( lower(uricomment) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


          --*************************************************************************
          --* search for biosequences              
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''BIOSEQUENCES'' then



             -- if the search string does not contain a wildcard then first try to find an exact match on name 
             -- -  if we succeed then go no further
             -- first , name in sequence table....
             if position(wildCardChar in searchText) = 0  then
                open obCursor for select obid , xreflsid, 
                coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid)
                from biosequenceob where sequencename = searchText;
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;

               -- try lsid
                open obCursor for select obid , xreflsid, 
                coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid)
                from biosequenceob where xreflsid = searchText;
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;


               -- try sequencename with .ab1 suffix
                open obCursor for select obid , xreflsid, 
                coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid)
                from biosequenceob where sequencename = searchText||''.ab1'';
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;


                -- try splitting the sequecename name using an underscore character and using the second
                -- token as the sequence name (this is an adhoc rule used in some sequence databases , where there
                -- is a species or breed prefix. It probably should be shifted to a site-specific 
                -- search engine function
                if split_part(searchText,''_'',2) is not null then
                   open obCursor for select obid , xreflsid, 
                   coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid)
                   from biosequenceob where sequencename = split_part(searchText,''_'',2);
                   fetch obCursor into listitem, listxreflsid, listcomment;
                   if FOUND then
                      insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                   end if;
                   close obCursor;

                   if elementCount > 0 then
                      update oblist set currentmembership = elementCount where obid = listid;
                      return listid;
                   end if;
                end if;

                -- if the search string is <= 5 characters this looks like a list name - try searching 
                -- for a sequence list 



             end if; -- no wildcards used - try exact match on names and return immediately if found


       


             --- from here , attempt wildcard matches on description and other fields -------




             -- add seqs that had blast hits to matching descriptions. 
             open obCursor for select obid,xreflsid , 
                '' ( hit to : '' || coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid) || '')''
                      from biosequenceob where ( lower(sequencedescription) like lower(wildCardChar||searchText||wildCardChar));
             fetch obCursor into listitem,listxreflsid, listcomment;
             while elementCount < maxListSize and FOUND LOOP
                open obCursor2 for select  
                querysequence from databasesearchobservation where hitsequence = listitem;
                fetch obCursor2 into listitem2;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor3 for select obid , xreflsid, 
                   coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid)
                   from biosequenceob where obid = listitem2 and not exists
                   (select ob from listmembershiplink where oblist = listid and
                   ob = listitem2);
                   fetch obCursor3 into listitem3,listxreflsid3, listcomment3;
                   while elementCount < maxListSize and FOUND LOOP
                      insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem3,listxreflsid3,listcomment);
                      fetch obCursor3 into listitem3,listxreflsid3, listcomment3;
                      elementCount := elementCount + 1;
                   end loop;
                   close obCursor3;
                   fetch obCursor2 into listitem2;
                end loop;
                close obCursor2;
                fetch obCursor into listitem,listxreflsid,listcomment;
             end loop;
             close obCursor;


             -- next add the seqs that had matching descriptions
	     if elementCount < maxListSize then
                open obCursor for select obid,xreflsid , 
                   coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid) 
                         from biosequenceob where ( lower(sequencedescription) like lower(wildCardChar||searchText||wildCardChar)) and
                         not exists 
                         (select ob from listmembershiplink where oblist = listid and
                         ob = biosequenceob.obid);             
                fetch obCursor into listitem,listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   fetch obCursor into listitem,listxreflsid,listcomment;
                   elementCount := elementCount + 1;
                end loop;
                close obCursor;
             end if;


             -- try wildcard on lsid
             open obCursor for select obid , xreflsid, 
             coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid)
             from biosequenceob where lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar);
             fetch obCursor into listitem, listxreflsid, listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                elementCount := elementCount + 1;
                fetch obCursor into listitem,listxreflsid, listcomment;
             end loop;
             close obCursor;


	     -- next add items from the seqfeaturefact table
             if sensitivity >= 3 then
	        if elementCount < maxListSize then
                   open obCursor for select distinct biosequenceob ,xreflsid  from biosequencefeaturefact f where 
                   f.featuretype = lower(searchText);
                   fetch obCursor into listitem,listxreflsid;
                   while elementCount < maxListSize and FOUND LOOP
                      open obCursor2 for select  
                      coalesce(xreflsid  || '' ''|| sequencedescription ,xreflsid) from biosequenceob where obid = listitem;
                      fetch obCursor2 into listcomment;
                      close obCursor2;
                      insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      fetch obCursor into listitem,listxreflsid,listcomment;
                      elementCount := elementCount + 1;
                   end loop;
                   close obCursor;
                end if;
             end if;


             -- search gene ontology links
             --if elementCount < 30 then
             --   open obCursor for select ontologyob from ontologytermfact where lower(termname) like
             --   lower(wildCardChar||searchText||wildCardChar) and xreflsid like ''ontology.GO%'';
             --   fetch obCursor into obvar1;
             --   while elementCount < maxListSize and FOUND LOOP
             --      open obCursor2 for select g.obid, replace(g.xreflsid,''geneticob.'',''''),
             --            coalesce(g.geneticobsymbols || '' ''|| g.geneticobdescription ,
             --            g.geneticobsymbols,
             --            replace(g.xreflsid,''geneticob.'','''') || '' (symbol unknown)'')
             --      from predicatelink pl join geneticob g on 
             --      pl.subjectob = g.obid and pl.objectob = obvar1;
             --      fetch obCursor2 into listitem,listxreflsid, listcomment;
             --      close obCursor2;
             --      if listitem is not null then
	     --         insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
             --         elementCount := elementCount + 1;
             --      end if;
             --      fetch obCursor into obvar1;
             --   end loop;
             --   close obCursor;
             --end if;



	     -- add sequences that are the gene products of genes that match the query - would
             -- be nice to do this recursively by a call to this method but this doesnt work
             -- (of course). The following code basically takes the above code for locating genes, 
             -- and joins to the geneproduct table

             -- **************** this was OK in SG which had a gene index but probably just slows down other 
             -- **************** instances. Perhaps we need to pass specific sensitivity and specificity hints to 
             -- **************** this method so we can control this. In the meantime I have stuck an internal 
             -- **************** sensitivity variable at the top
           
             if sensitivity >= 2 then

                -- first add items whose gene name matches the query
   	        if elementCount < maxListSize then
                   open obCursor for select gpl.biosequenceob , gpl.xreflsid from geneproductlink gpl, geneticob go where 
                   (lower(go.geneticobname) like lower(wildCardChar||searchText||wildCardChar)
                   or lower(go.geneticObSymbols) like lower(wildCardChar||searchText||wildCardChar)) and
                   gpl.geneticob = go.obid ; 
                   fetch obCursor into listitem,listxreflsid;
                   while elementCount < maxListSize and FOUND LOOP
                      insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                      fetch obCursor into listitem,listxreflsid;
                      elementCount := elementCount + 1;
                   end loop;
                   close obCursor;
                end if;


                -- next add items whose description matches the query
                if elementCount < maxListSize then
                   open obCursor for select gpl.biosequenceob , gpl.xreflsid from geneproductlink gpl, geneticob go where 
                   (lower(go.geneticobdescription) like lower(wildCardChar||searchText||wildCardChar) or
                              lower(go.obkeywords) like lower(wildCardChar||searchText||wildCardChar)) and
                    gpl.geneticob = go.obid ;  
                   fetch obCursor into listitem,listxreflsid;
                   while elementCount < maxListSize and FOUND LOOP
                      insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                      fetch obCursor into listitem,listxreflsid;
                      elementCount := elementCount + 1;
                   end loop;
                   close obCursor;
                end if; -- list not yet full


                -- add items whose function description matches the query
                if elementCount < maxListSize then
                   open obCursor for select distinct gpl.biosequenceob , gpl.xreflsid from geneproductlink gpl, geneticfunctionfact gff 
                   where lower(gff.functioncomment) like  lower(wildCardChar||searchText||wildCardChar) and
                   gpl.geneticob = gff.geneticob ;
                   fetch obCursor into listitem,listxreflsid;
                   while elementCount < maxListSize and FOUND LOOP
                      insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                      fetch obCursor into listitem,listxreflsid;
                      elementCount := elementCount + 1;
                   end loop;
                   close obCursor;
                end if; -- list not yet full
             end if; -- sensitivity >= 2




          --*************************************************************************
          --* search for microarray spots                    
          --*
          --*************************************************************************

          elsif upper(obTypeName) = ''MICROARRAY SPOTS'' then

             -- the strategy is currently as follows
             -- Exact matches (1) : 
             -- 1. Accession 
             -- 3. Gal_id
             -- 4. gal_name
             -- 5. xreflsid

             -- exact matches (2) :
             -- GO ontology on termname then link via GO association and sequence association


             -- exact matches (3) :
             -- biosequence on sequencename then link via sequence-spot link


             -- exact matches (4) , retrieve all records
             -- biosequence  on sequencename then link via blast hit

             -- wild cards or not hit yet :

       
             -- xreflsid
             -- accession
             -- spot description
             -- GO term description then link via GO association and sequence association
             -- sequence description then link via blast hits 



             -- if the search string does not contain a wildcard then first try to find an exact match on accession and 
             -- xreflsid before going any further
             if position(wildCardChar in searchText) = 0  then
                -- accession
                open obCursor for select obid , xreflsid, 
                coalesce(xreflsid  || '' ''|| gal_description ,xreflsid)
                from microarrayspotfact where accession = searchText;
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;

                -- gal_id
                open obCursor for select obid , xreflsid, 
                coalesce(xreflsid  || '' ''|| gal_description ,xreflsid)
                from microarrayspotfact where gal_id = searchText;
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;

                -- gal_name
                open obCursor for select obid , xreflsid, 
                coalesce(xreflsid  || '' ''|| gal_description ,xreflsid)
                from microarrayspotfact where gal_name = searchText;
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;

                -- xreflsid
                open obCursor for select obid , xreflsid, 
                coalesce(xreflsid  || '' ''|| gal_description ,xreflsid)
                from microarrayspotfact where xreflsid = searchText;
                fetch obCursor into listitem, listxreflsid, listcomment;
                while elementCount < maxListSize and FOUND LOOP
                   insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                   elementCount := elementCount + 1;
                   fetch obCursor into listitem, listxreflsid, listcomment;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;


                -- exact match on a sequencename (e.g. NCBI) , then via database hit and sequence association
                open obCursor for select obid, sequencedescription 
                from biosequenceob where sequencename = searchText;
                fetch obCursor into obvar1, textvar1;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor2 for select msf.obid, msf.xreflsid, coalesce(msf.accession || '' '' || msf.gal_description || '' '' || textvar1,
                         msf.accession || '' '' || textvar1)  
                      from (databasesearchobservation dso join predicatelink plsa on 
                      dso.hitsequence = obvar1 and 
                      plsa.objectob = dso.querysequence and plsa.predicate = ''ARRAYSPOT-SEQUENCE'') join
                      microarrayspotfact msf on msf.obid = plsa.subjectob ;
                   fetch obCursor2 into listitem,listxreflsid, listcomment;

                   while elementCount < maxListSize and FOUND LOOP
                      insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                      fetch obCursor2 into listitem, listxreflsid, listcomment;
                   end loop;
                   close obCursor2;

                   fetch obCursor into obvar1, textvar1;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;                





                -- exact match on go term via go association and sequence association
                open obCursor for select obid 
                from ontologytermfact where termname = searchText;
                fetch obCursor into obvar1;
                if elementCount < maxListSize and FOUND then
                   open obCursor2 for select msf.obid, msf.xreflsid, coalesce(msf.accession || '' '' || msf.gal_description,
                         msf.accession)  
                      from (predicatelink plgo join predicatelink plsa on 
                      plgo.objectob = obvar1 and plgo.predicate = ''GO_ASSOCIATION'' and 
                      plsa.objectob = plgo.subjectob and plsa.predicate = ''ARRAYSPOT-SEQUENCE'') join
                      microarrayspotfact msf on msf.obid = plsa.subjectob ;
                   fetch obCursor2 into listitem,listxreflsid, listcomment;

                   while elementCount < maxListSize and FOUND LOOP
                      insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                      fetch obCursor2 into listitem, listxreflsid, listcomment;
                   end loop;
                   close obCursor2;
                end if;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;
             end if;

             ---------------------------------------------------------
             ---- either no exact matches or wildcards were specified
             ---------------------------------------------------------


             -- first try items whose xreflsid can match the query
             open obCursor for select obid,xreflsid,coalesce(xreflsid  || '' ''|| gal_description ,xreflsid)
                  from microarrayspotfact where lower(xreflsid) like lower(wildCardChar||searchText||wildCardChar); 
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;

             -- if some hits on xreflsid were found, they are not searching using
             -- keywords, we can exit
             if elementCount > 0 then
                update oblist set currentmembership = elementCount where obid = listid;
                return listid;
             end if;


             -- next try items whose accession can match the query
             open obCursor for select obid,xreflsid,coalesce(xreflsid  || '' ''|| gal_description ,xreflsid)
                  from microarrayspotfact where lower(accession) like lower(wildCardChar||searchText||wildCardChar); 
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


             -- next try items whose description can match the query
             open obCursor for select obid,xreflsid,coalesce(xreflsid  || '' ''|| gal_description ,xreflsid)
                  from microarrayspotfact where lower(gal_description) like lower(wildCardChar||searchText||wildCardChar); 
             fetch obCursor into listitem,listxreflsid,listcomment;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid,membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                fetch obCursor into listitem,listxreflsid,listcomment;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;


             -- match go term via description and link via go association and sequence association
             if elementCount < maxListSize then
                open obCursor for select obid , termname || '' '' || termdescription
                from ontologytermfact where lower(termdescription) like lower(wildCardChar||searchText||wildCardChar);
                fetch obCursor into obvar1,textvar1;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor2 for select msf.obid, msf.xreflsid, coalesce(msf.accession || '' '' || msf.gal_description || '' '' || textvar1,
                         msf.accession || '' '' || textvar1)  
                      from (predicatelink plgo join predicatelink plsa on 
                      plgo.objectob = obvar1 and plgo.predicate = ''GO_ASSOCIATION'' and 
                      plsa.objectob = plgo.subjectob and plsa.predicate = ''ARRAYSPOT-SEQUENCE'') join
                      microarrayspotfact msf on msf.obid = plsa.subjectob ;
                   fetch obCursor2 into listitem,listxreflsid, listcomment;

                   while elementCount < maxListSize and FOUND LOOP
                      insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                      fetch obCursor2 into listitem, listxreflsid, listcomment;
                   end loop;
                   close obCursor2;

                   fetch obCursor into obvar1,textvar1;
                end loop;
                close obCursor;

                -- if we got some hits using GO that will do
                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;
             end if;



             -- match sequence description , then via database hit and sequence association
             if elementCount < maxListSize then
                open obCursor for select obid, sequencedescription 
                from biosequenceob where lower(sequencedescription) like lower(wildCardChar||searchText||wildCardChar);
                fetch obCursor into obvar1, textvar1;
                while elementCount < maxListSize and FOUND LOOP
                   open obCursor2 for select msf.obid, msf.xreflsid, coalesce(msf.accession || '' '' || msf.gal_description || '' '' || textvar1,
                         msf.accession || '' '' || textvar1)  
                      from (databasesearchobservation dso join predicatelink plsa on 
                      dso.hitsequence = obvar1 and 
                      plsa.objectob = dso.querysequence and plsa.predicate = ''ARRAYSPOT-SEQUENCE'') join
                      microarrayspotfact msf on msf.obid = plsa.subjectob ;
                   fetch obCursor2 into listitem,listxreflsid, listcomment;

                   while elementCount < maxListSize and FOUND LOOP
                      insert into listmembershiplink(oblist,ob, obxreflsid, membershipcomment) values (listid,listitem,listxreflsid,listcomment);
                      elementCount := elementCount + 1;
                      fetch obCursor2 into listitem, listxreflsid, listcomment;
                   end loop;
                   close obCursor2;

                   fetch obCursor into obvar1, textvar1;
                end loop;
                close obCursor;

                if elementCount > 0 then
                   update oblist set currentmembership = elementCount where obid = listid;
                   return listid;
                end if;                
             end if;


          --*************************************************************************
          --* else do a basic search                   
          --*
          --*************************************************************************

          else 
             open obCursor for select obid,xreflsid from ob where obkeywords like lower(wildCardChar||searchText||wildCardChar);
             fetch obCursor into listitem,listxreflsid;
             while elementCount < maxListSize and FOUND LOOP
                insert into listmembershiplink(oblist,ob, obxreflsid) values (listid,listitem,listxreflsid);
                fetch obCursor into listitem,listxreflsid;
                elementCount := elementCount + 1;
             end loop;
             close obCursor;
          end if;


          -- finally , update the membership count of the list
          update oblist set currentmembership = currentmembership + elementCount where obid = listid;
       end if; -- no existing list could be re-used

       return listid;

    END;
' LANGUAGE plpgsql;



/*
* This stub is for searches where an existing listid is not supplied - i.e. 
* the search is not appending to an existing list. Call the main search engine 
* with existingListID of 0 which will then create a new list
*/
CREATE or replace FUNCTION getSearchResultList(text, varchar, integer, varchar, integer) RETURNS integer VOLATILE AS '
   BEGIN
      return getSearchResultList($1, $2, $3, $4, $5,0,null);
   END;
' LANGUAGE plpgsql;


CREATE  or replace FUNCTION getSearchResultList(text, varchar, integer, varchar, integer, integer) RETURNS integer VOLATILE AS '
   BEGIN
      return getSearchResultList($1, $2, $3, $4, $5, $6,null);
   END;
' LANGUAGE plpgsql;



/***********************************************************************
*
* section for setting up virtual and dynamic ops
************************************************************************/
/*

Note on virtual ops : 


General purpose ops such as predicate links are economical as far as database
object count goes, but suffer from the problem that it is diffciult for the the brdf API 
to discover and present informative database maps from these tables.

For example , one might want the API to be able to discover that there is an
"is-a" relation between microarray spots and genes - and to present a greyed-out
icon if there was no instance of such a relation for a particular object.

Although it is possible to discover an is-a relation from the predicate table,
it is not possible to discover the absence of such a relation, or to present the 
relation in a very informative way.

One solution would be to create a specific is-a link table between
Genetic obs and microarray spot obs, however this would involve an unmaintainable
increase in the number of database objects , and render ineffective the whole
idea of having general purpose predicate links.

Since the obtype of a predicate that is inserted into the predicatelink table
is set by a database trigger, it is diffcult to introduce subtypes of the 
predicate-type - another possible solution that one might consider.

To solve this problem in a practical manner, we introduce the idea of a virtual
op. This is one that does not have its own table as do most ops - virtual predicate
ops are stored in the predicatelink table. The predicate link table has a voptype
column , which will indicate the virtual type of an object that is inserted into the table.
It is the responsibility of the client code to ensure the correct virtual type is entered,
although there is an on-insert trigger that checks any virtual type code entered.

The obtype column has a boolean indicating whether an object is virtual or not.

Note on dynamic ops

Dynamic ops are declared in the database but are only instantiated at runtime.


*
*/

/*
*************************************************************
set up (virtual) predicate link between spots and sequences
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(265, 'Microarray Spot - Sequence','predicatelink',TRUE,'Microarray Spot - Sequence Association',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 265,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'MICROARRAYSPOTFACT';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 265,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';


/* change 7/2011 to support links between sequences and spots on a gel */

insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(266, 'Protein Gel Spot - Sequence','predicatelink',TRUE,'Protein Gel Spot - Sequence Association',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 266,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'PROTEINGELSPOTFACT';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 266,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';









/*
*************************************************************
set up (virtual) predicate link between spots and genes
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(375, 'Microarray Spot - Gene','predicatelink',TRUE,'Microarray Spot - Gene Association',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 375,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'MICROARRAYSPOTFACT';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 375,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'GENETICOB';

/*
*************************************************************
set up (virtual) predicate link between sequences, and subsequences that are affy targets
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(376, 'Sequence - Affy Target','predicatelink',TRUE,'Sequence - Affy target subsequence association',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 376,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 376,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';


/*
*************************************************************
set up (virtual) predicate link between affy targets and the probes designed on those targets
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(377, 'Affy Target - Affy Probe','predicatelink',TRUE,'Affy target - Affy probe association',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 377,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 377,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';


/*
*************************************************************
set up (virtual) predicate link between a sequence (e.g. reference sequence) , and the the probes designed from this.
Note that this is a direct link from a sequence to a probe, skipping the target that is selected from 
the original sequence
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(374, 'Ref Sequence - Affy Probe','predicatelink',TRUE,'Ref sequence - Affy probe association',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 374,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 374,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';




/*
*************************************************************
set up (virtual) predicate link between an affy probset (= modelled as per microarray spot),  and the probes that are in a probeset
(This relation can be used to define custom probesets)
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(378, 'Affy Probeset - Affy Probe Oligo','predicatelink',TRUE,'Affy Probeset - Affy Probe oligo',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 378,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'MICROARRAYSPOTFACT';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 378,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';


/*
*************************************************************
set up (virtual) predicate link between an affy probset (= modelled as per microarray spot),  and the target sequence
that the probes in the probeset were tiled from 
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(382, 'Affy Probeset - Affy Target Oligo Sequence','predicatelink',TRUE,'Affy Probeset - Affy Target Probe oligo',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 382,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'MICROARRAYSPOTFACT';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 382,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';



/*
*************************************************************
set up (virtual) predicate link between an oligo,  and the reference sequence
that the oligo was designed from 
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(386, 'Oligo Sequence-Reference Sequence','predicatelink',TRUE,'Link from an oligo sequence to a reference sequence from which the oligo was designed',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 386,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 386,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';


/*
*************************************************************
set up (virtual) predicate link between genetic objects and ontologies
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(355, 'Genetic Nomenclature','predicatelink',TRUE,'Genetic Nomenclature',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 355,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'GENETICOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 355,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'ONTOLOGYOB';


/*
***********************************************************************************
set up (virtual) predicate link between genetic objects and gene ontology (GO) terms
************************************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(365, 'Gene Ontology (GO)','predicatelink',TRUE,'Gene Ontology (GO)',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 365,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'GENETICOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 365,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'ONTOLOGYTERMFACT';


/*
*************************************************************
set up (virtual) predicate link between forward and reverse pairs of read-pair
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(379, 'Forward - Reverse Read Pair','predicatelink',TRUE,'Forward - Reverse Read Pair',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 379,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 379,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';



/*
*************************************************************
set up (virtual) predicate link between genomic sequence and transcript sequence 
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(381, 'Genomic <---> Transcript Sequence','predicatelink',TRUE,'Genomic <---> Transcript Sequence',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 381,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 381,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';


/*
*************************************************************
set up (virtual) predicate link between current version of an analysis procedure, and previous version
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(383, 'Version <---> Previous Version','predicatelink',TRUE,'Version <---> Previous Version',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 383,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'ANALYSISPROCEDUREOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 383,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'ANALYSISPROCEDUREOB';



/*
*************************************************************
set up (virtual) comment link between a comment and a genotype observation 
Note that this link sits on top of an ob table rather than an op table
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(384, 'Comment','commentOb',TRUE,'Comment Link for Comments that are attached to only a single object',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 384,   obtypeid,   'obid' from obtype where  upper(tablename) = 'COMMENTOB' and obtypeid != 384;
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 384,   obtypeid,   'commentedob' from obtype where  upper(tablename) = 'GENOTYPEOBSERVATION';



/*
*************************************************************
set up (virtual) foreign-key predicate link between a bound datasourcenamedlistmembershiplinkfact and another
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(387, 'References','predicatelink',TRUE,'References',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 387,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'DATASOURCENAMEDLISTMEMBERSHIPLINK';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 387,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'DATASOURCENAMEDLISTMEMBERSHIPLINK';




/*
*************************************************************
set up (virtual) predicate link between a queued report datasourceob and the report output datasourceob
*************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(388, 'Report Yields Output','predicatelink',TRUE,'Report Yields Output',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 388,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 388,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'DATASOURCEOB';






/*
*************************************************************
set up dynamic location link between genes
*************************************************************
*/
/*
* !!!! 25/4/2006 - not included as currently unimplemented !!!
*/
/*
insert into obtype (obtypeid , displayname, namedinstances, obtypedescription,isop,isdynamic)
values(280, 'Genetic Locale',FALSE,'Links genetic objects that are near',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 280,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'GENETICOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 280,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'GENETICOB';
*/
/*
*************************************************************
set up virtual sequencingfunction relation that only includes the 
labresourcelist arm
*************************************************************
*/

insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(285, 'Sequencing Details','sequencingFunction',TRUE,'Sequencing Details (more than one lab resource)',TRUE, TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 285,   obtypeid,   'bioSampleob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 285,   obtypeid,   'biosequenceob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 285,   obtypeid,   'labResourceList' from obtype where  upper(tablename) = 'LABRESOURCELIST';
\echo creating trigger to validate voptypeid
create trigger checksfvoptypeid before insert or update on sequencingfunction
for each row execute procedure checkvoptypeid();



/*
*************************************************************
set up virtual displayfunction relation that 
*************************************************************
*/

insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(146, 'Genepix display function','displayFunction',TRUE,'Display function for Genepix spots',TRUE, TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 146,   obtypeid,   'ob' from obtype where  upper(tablename) = 'OB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 146,   obtypeid,   'dataSourceOb' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 146,   obtypeid,   'displayProcedureOb' from obtype where  upper(tablename) = 'DISPLAYPROCEDUREOB';
\echo creating trigger to validate voptypeid
create trigger checkdfvoptypeid before insert or update on displayfunction
for each row execute procedure checkvoptypeid();


/*
***********************************************************************************
set up (virtual) predicate link between sequence objects and gene ontology (GO) terms
************************************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(395, 'Gene Ontology (GO)','predicatelink',TRUE,'Gene Ontology (GO)',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 395,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 395,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'ONTOLOGYTERMFACT';




/*
update on 19/1/2007 (and 31/1/2007)
update by : AMcC (and JSM)
***********************************************************************************
set up (virtual) microarray contrast link between geneexpression study objects
************************************************************************************
Note that there are a number of different types of contrast - e.g dye reversal ; high-low
intensity scan. Each type will have a specific predicatetype ( all types are listed in the 
PREDICATE_TYPE ontology) - however all of these are covered by a single voptype.
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(415, 'Microarray Contrast','predicatelink',TRUE,'Contrast between Microarray Experiments',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 415,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'GENEEXPRESSIONSTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 415,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'GENEEXPRESSIONSTUDY';


/*
*******************************************************************
a virtual function that sits on top of the importfunction table, making 
the relation between a sequence and the fasta file it was imported from 
visible
*******************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(127, 'Sequence - Sequencing run FASTA file','importfunction',TRUE,'Sequence - Sequencing run FASTA file',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 127,   obtypeid,   'ob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 127,   obtypeid,   'datasourceob' from obtype where  upper(tablename) = 'DATASOURCEOB';


/*
*******************************************************************
a virtual link that sits on top of the predicatelink table, making 
the relation between an SFF file and a FASTA file derived from it , visible
*******************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(128, 'SFF File - FASTA file','predicatelink',TRUE,'SFF File - FASTA file',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 128,   obtypeid,   'subjectob' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 128,   obtypeid,   'objectob' from obtype where  upper(tablename) = 'DATASOURCEOB';


/*
*******************************************************************
virtual links that sit on top of the listmembership table, to create
typed lists that cause the linking code to use the descendent table
in the join , rather than the base ob table
*******************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(26, 'Sequence list','listmembershiplink',FALSE,'Sequence list',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 26,   obtypeid,   'ob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 26,   obtypeid,   'oblist' from obtype where  upper(tablename) = 'OBLIST';


insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(27, 'Subject list','listmembershiplink',FALSE,'Subject list',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 27,   obtypeid,   'ob' from obtype where  upper(tablename) = 'BIOSUBJECTOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 27,   obtypeid,   'oblist' from obtype where  upper(tablename) = 'OBLIST';


insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(28, 'Microarray Slide Series','listmembershiplink',FALSE,'Microarray Slide Series',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 28,   obtypeid,   'ob' from obtype where  upper(tablename) = 'GENEEXPRESSIONSTUDY';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 28,   obtypeid,   'oblist' from obtype where  upper(tablename) = 'OBLIST';


insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(29, 'Data Source List','listmembershiplink',FALSE,'Data Source List',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 29,   obtypeid,   'ob' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 29,   obtypeid,   'oblist' from obtype where  upper(tablename) = 'OBLIST';




/*
*******************************************************************
virtual links that sit on top of the analysisfunction table, making 
the relation between a datasource and an analysisProcedure visible 
*******************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(546, 'Datasource Analysis','analysisfunction',FALSE,'Datasource Analysis',TRUE,TRUE);
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 546,   obtypeid,   'ob' from obtype where  upper(tablename) = 'DATASOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 546,   obtypeid,   'dataSourceList' from obtype where  upper(tablename) = 'DATASOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 546,   obtypeid,   'analysisProcedureOb' from obtype where  upper(tablename) = 'ANALYSISPROCEDUREOB';


/*
*******************************************************************
virtual links that sit on top of the analysisfunction table, making 
the relation between a lab resource ob  and an analysisProcedure visible 
*******************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(547, 'Analysis','analysisfunction',FALSE,'Analysis',TRUE,TRUE);
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 547,   obtypeid,   'ob' from obtype where  upper(tablename) = 'LABRESOURCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 547,   obtypeid,   'dataSourceList' from obtype where  upper(tablename) = 'DATASOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 547,   obtypeid,   'analysisProcedureOb' from obtype where  upper(tablename) = 'ANALYSISPROCEDUREOB';


/*
*******************************************************************
virtual links that sit on top of the analysisfunction table, making 
the relation between a sequence and an analysisProcedure visible 
*******************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(548, 'Analysis','analysisfunction',FALSE,'Analysis',TRUE,TRUE);
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 548,   obtypeid,   'ob' from obtype where  upper(tablename) = 'BIOSEQUENCEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 548,   obtypeid,   'dataSourceList' from obtype where  upper(tablename) = 'DATASOURCELIST';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 548,   obtypeid,   'analysisProcedureOb' from obtype where  upper(tablename) = 'ANALYSISPROCEDUREOB';


/*
*******************************************************************
virtual links that sit on top of the namedbatchmembershiplink table, making 
the relation between a batch and a biosample visible 
*******************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(611, 'Sample Fraction Batch','batchnamedmembershiplink',FALSE,'Sample Fraction Batch',TRUE,TRUE);
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 611,   obtypeid,   'memberob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 611,   obtypeid,   'batchob' from obtype where  upper(tablename) = 'BATCHOB';


/*
*******************************************************************
virtual links that sit on top of the biosamplingfunction table, making 
the relation between a sample and its subsample  visible 
*******************************************************************
*/
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(104, 'Sample<->Fraction','biosamplingfunction',FALSE,'Sample<->Fraction',TRUE,TRUE);
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 104,   obtypeid,   'biosampleob' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 104,   obtypeid,   'parentsample' from obtype where  upper(tablename) = 'BIOSAMPLEOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 104,   obtypeid,   'bioprotocolob' from obtype where  upper(tablename) = 'BIOPROTOCOLOB';
/*
* we could add the other arms of the relation if 
* we wished - e.g. the labresourceob and labresourcelist
* obs
*/








/***********************************************************************
*
* Misc updates to the intialised data - e.g. initialise lsids for some of the 
* objects that were not assigned lsids
*
*************************************************************************/


update ontologyob set xreflsid = ontologyname where xreflsid is null;
update ontologytermfact set xreflsid = termname where xreflsid is null;

/*
***********************************************************************
*
* create indexes
*
***********************************************************************
*/
create index i_obxreflsid1 on ob(xreflsid);
create index imicroarrayobservation_ms on microarrayobservation(microarraystudy);
create index i_microarrayspotfactloc1 on microarrayspotfact(labresourceob,gal_block,gal_column,gal_row);
create index i_microarrayspotfactgalid on microarrayspotfact(gal_id);

create index iimportfunction_ob on importfunction(ob);
create index iimportfunction_ds on importfunction(datasourceob);
create index i_importfunctionlsid on importfunction(xreflsid);

create index imicroarrayobservation_msf on microarrayobservation(microarrayspotfact);


create index i_microarrayobslsid on microarrayobservation(xreflsid);
create index i_microarrayobservationfactobs on microarrayobservationfact(microarrayobservation);
create index i_microarrayspotfactlsid on microarrayspotfact(xreflsid);
create index i_microarrayspotfactgene on microarrayspotfact(gal_genename);

create index imicroarrayobservation_msfs on microarrayobservation(microarraystudy, microarrayspotfact);



create index i_urilsid on uriob(xreflsid);
create index i_uri_temp on uriob(uristring);
create index i_urilinkuriob on urilink(uriob);
create index i_urilinkob on urilink(ob);
create index i_urilinkoburiob on urilink(uriob,ob);

create index i_biosequenceoblsid on biosequenceob(xreflsid);
create index i_geneproductlinkgene on geneproductlink(geneticob);
create index i_geneproductlinkprod on geneproductlink(biosequenceob);
create index i_ontologytermfactterm on ontologytermfact(termname);
create index i_ontologytermfacto on ontologytermfact(ontologyob);

create index i_microarrayspotfactaccession on microarrayspotfact(accession);
create index i_microarrayspotfact_lrgal on microarrayspotfact(labresourceob, gal_name);
create index i_geneticlocationfactgeneid on geneticlocationfact(entrezgeneid);
create index i_geneticlocationfactseqid on geneticlocationfact(biosequenceob);
create index i_geneticlocationfactmulti1 on geneticlocationfact(entrezgeneid, evidence, geneticob);
create index i_geneticlocationfactgeneticob on geneticlocationfact(geneticob);
create index i_geneticobsymbols on geneticob(geneticobsymbols);
create index i_geneticlocationfactmapobid on geneticlocationfact(mapobid);


create index i_geneticlocationfactmulti2 on geneticlocationfact(mapname,chromosomename,locationstart);
create index i_geneticlocationfactmulti3 on geneticlocationfact(biosequenceob, mapname,chromosomename);
create index i_geneticlocationfactmulti4 on geneticlocationfact(biosequenceob, mapname);
create index i_geneticlocationfactmulti5 on geneticlocationfact(mapname,chromosomename,locationstop);


create index i_ontologyobxreflsid on ontologyob(xreflsid);
create index i_ontologyobname on ontologyob(ontologyname);
create index i_ontologytermfact2av on ontologytermfact2(attributevalue);
create index i_ontologytermfact2all on ontologytermfact2(factnamespace, attributename,attributevalue);
create index i_ontologytermfact2tav on ontologytermfact2(ontologytermid, factnamespace, attributevalue);

create index i_biosubjectfact1 on biosubjectfact(biosubjectob);
create index i_biosubjectfact2 on biosubjectfact(biosubjectob,factnamespace,attributename);
create index i_biosubjectfact3 on biosubjectfact(biosubjectob,factnamespace,attributename,attributevalue);
create index i_biosubjectfact4 on biosubjectfact(factnamespace, attributename, attributevalue);


create index i_predicatelink1 on predicatelink(objectob,subjectob,predicate);
create index i_predicatelink2 on predicatelink(subjectob,predicate);           
create index i_predicatelink3 on predicatelink(objectob,predicate);            



create index i_commentlink on commentlink(ob,commentob);

create index i_geneticexpress_bioseq on geneticexpressionfact(biosequenceob);
create index i_geneticexpress_gene on geneticexpressionfact(geneticob);
create index i_geneticexpress_bioseqv on geneticexpressionfact(biosequenceob,voptypeid);

create index i_biosamplefact1 on biosamplefact(biosampleob);
create index i_biosamplefact2 on biosamplefact(biosampleob,factnamespace,attributename);

create index i_displayfunctionob on displayfunction(ob);
create index i_displayfunctionds on displayfunction(datasourceob);
create index i_displayfunctionobdp on displayfunction(ob, displayprocedureob);

create index i_genotpyestudysample1 on genotypestudy(biosampleob);
create index i_genotypestudylr on genotypestudy(labresourceob);
create index i_genotpyestudysample1lr on genotypestudy(biosampleob,labresourceob);



create index i_genotypeobservationstudy1 on genotypeobservation(genotypestudy);
create index i_genotypeobservationtest1 on genotypeobservation(genetictestfact);
create index i_genotypeobservationlsid on genotypeobservation(xreflsid);

create index i_genotypeobservationfact1 on genotypeobservationfact(genotypeobservation);

create index i_genotypestudyfact1 on genotypestudyfact(genotypestudy,factnamespace,attributename,attributevalue);
create index i_genotypestudyfact2 on genotypestudyfact(genotypestudy,factnamespace,attributename);



create index i_biosamplingfunctionsubject on biosamplingfunction(biosubjectob);
create index i_biosamplingfunctionsample on biosamplingfunction(biosampleob);
create index i_biosamplingfunctionsubjectsample on biosamplingfunction(biosubjectob,biosampleob);

create index i_genetictestfact2all on genetictestfact2(genetictestfact,factnamespace,attributename);
create index i_genetictestfactlsid on genetictestfact(xreflsid);
create index i_genetictestfactlr on genetictestfact(labresourceob);



create index i_listmembershipob on listmembershiplink(ob);

create index i_biosequenceobkw on biosequenceob(obkeywords);

create index i_biosequenceobsn on biosequenceob(sequencename);

create index i_biosequencefact1 on biosequencefact(biosequenceob,factnamespace,attributename);

create index i_biosequencefeatfact1 on biosequencefeaturefact(biosequenceob);
create index i_biosequencefeatfactacc on biosequencefeaturefact(featureaccession);
create index i_biosequencefeaturefactlsid on biosequencefeaturefact(xreflsid);
create index i_biosequencefeaturefactpos on biosequencefeaturefact(biosequenceob, featurestart,featurestop);
create index i_biosequencefeaturefactseqfeat on biosequencefeaturefact(biosequenceob, featuretype);



create index i_dbsearchobservation_studyquery on databasesearchobservation(databasesearchstudy,querysequence);
create index i_dbsearchobservation_studyhit on databasesearchobservation(databasesearchstudy,hitsequence);
create index i_dbsearchobservation_studyqueryhit on databasesearchobservation(databasesearchstudy,querysequence,hitsequence);
create index i_dbsearchobservation_queryhit on databasesearchobservation(querysequence,hitsequence);
create index i_dbsearchobservation_query on databasesearchobservation(querysequence);
create index i_dbsearchobservation_hit on databasesearchobservation(hitsequence);
create index i_dbsearchobservation_lsid on databasesearchobservation(xreflsid);

create index i_sequencealignmentfact_ob on sequencealignmentfact(databasesearchobservation);
create index i_sequencealignmentfact_lsid on sequencealignmentfact(xreflsid);


create index i_datasourcefact on datasourcefact(datasourceob,factnamespace,attributename);
create index i_datasourceoblsid on datasourceob(xreflsid);

create index i_stafflistmembershiplistob on stafflistmembershiplink(stafflist, staffob);
create index i_stafflistmembershipob on stafflistmembershiplink(staffob);
create index i_securityfunction_type on securityFunction(applytotype);
create index i_securityfunction_ob on securityFunction(ob);

create index i_functionalassayobservationfact on functionalassayobservationfact(functionalassayobservation);

create index i_sequencingfunctionlsid on sequencingfunction(xreflsid);
create index i_sequencingfunctionseq on sequencingfunction(biosequenceob);
create index i_sequencingfunctionsample on sequencingfunction(biosampleob);
create index i_sequencingfunctionsampleop on sequencingfunction(biosampleob, voptypeid);


create index i_libconstructionfunctionlsid on biolibraryconstructionfunction(xreflsid);
create index i_libconstructionfunctionlib on biolibraryconstructionfunction(biolibraryob);
create index i_libconstructionfunctionseq on biolibraryconstructionfunction(biosequenceob);

create index i_surveystudylab on surveystudy(labresourceob);
create index i_surveystudylsid on surveystudy(xreflsid);
create index i_surveyobservationsubject on surveyobservation(biosubjectob);
create index i_surveyobservationstudy on surveyobservation(surveystudy);
create index i_surveyobservationlsid on surveyobservation(xreflsid);

create index i_surveyobservationsubjectstud on surveyobservation(biosubjectob, surveystudy);


create index i_surveyquestionobserv on surveyquestionfact(surveyobservation);
create index i_surveyquestion2 on surveyquestionfact(surveyobservation,question);

create index i_libsequencingfunctionlsid on librarysequencingfunction(xreflsid);


create index i_labresourcefact1 on labresourcefact(labresourceob);
create index i_labresourcefact2 on labresourcefact(labresourceob,factnamespace,attributename);
create index i_labresourcefact3 on labresourcefact(labresourceob,factnamespace,attributename,attributevalue);
create index i_labresourcefact4 on labresourcefact(factnamespace, attributename, attributevalue);

create index i_listmembershipfact1 on listmembershipfact(memberid);
create index i_listmembershipfact2 on listmembershipfact(oblist,memberid);

create index i_analysisfunction1 on analysisfunction(ob, voptypeid) ;

create index inml_oblist on namedlistmembershiplink(oblist);
create index inml_ob on namedlistmembershiplink(ob);










/*
* refs on lsid
*/
create index i_bioprotocoloblsid on bioprotocolob(xreflsid);
create index i_biosamplealiquotfactlsid on biosamplealiquotfact(xreflsid);
create index i_biosamplelistlsid on biosamplelist(xreflsid);
create index i_biosamplingfunctionlsid on biosamplingfunction(xreflsid);

create index i_commentoblsid on commentob(xreflsid);
create index i_displayfunctionlsid on displayfunction(xreflsid);
create index i_displayprocedureoblsid on displayprocedureob(xreflsid);
create index i_functionalassayfactlsid on functionalassayfact(xreflsid);
create index i_functionalassayobservationlsid on functionalassayobservation(xreflsid);
create index i_functionalassaystudylsid on functionalassaystudy(xreflsid);
create index i_geneexpressionstudylsid on geneexpressionstudy(xreflsid);
create index i_geneexpressionstudyname on geneexpressionstudy(studyname);
create index i_geneproductlinklsid on geneproductlink(xreflsid);
create index i_generegulationlinklsid on generegulationlink(xreflsid);
create index i_geneticexpressionfactlsid on geneticexpressionfact(xreflsid);
create index i_geneticfactlsid on geneticfact(xreflsid);
create index i_geneticfunctionfactlsid on geneticfunctionfact(xreflsid);
create index i_geneticlocationfactlsid on geneticlocationfact(xreflsid);
create index i_geneticlocationlistlsid on geneticlocationlist(xreflsid);
create index i_geneticoblistlsid on geneticoblist(xreflsid);
create index i_geneticoblsid on geneticob(xreflsid);

create index i_genotypestudylsid on genotypestudy(xreflsid);
create index i_importprocedureoblsid on importprocedureob(xreflsid);
create index i_labresourcelistlsid on labresourcelist(xreflsid);
create index i_labresourceoblsid on labresourceob(xreflsid);
create index i_literaturereferenceoblsid on literaturereferenceob(xreflsid);
create index i_microarrayfactlsid on microarrayfact(xreflsid);
create index i_oblistlsid on oblist(xreflsid);
create index i_oblistlisttype on oblist(listtype);
create index i_oblistlistdefinition on oblist(listdefinition);


create index i_ontologytermfactlsid on ontologytermfact(xreflsid);
create index i_oplsid on op(xreflsid);
create index i_phenotypeobservationlsid on phenotypeobservation(xreflsid);
create index i_phenotypestudylsid on phenotypestudy(xreflsid);
create index i_predicatelinklsid on predicatelink(xreflsid);
create index i_staffoblsid on staffob(xreflsid);
create index i_workflowmembershiplinklsid on workflowmembershiplink(xreflsid);
create index i_workflowoblsid on workflowob(xreflsid);
create index i_workflowstageoblsid on workflowstageob(xreflsid);
create index i_workstagevisitfactlsid on workstagevisitfact(xreflsid);


create index i_listmembershiplink_list on listmembershiplink(oblist);

create index i_biolibraryoblsid on biolibraryob(xreflsid);

create index i_biolibrarycontructionlsid on biolibraryconstructionfunction(xreflsid);
create index i_biolibrarycontructionsample on biolibraryconstructionfunction(biosampleob);
create index i_biolibrarycontructionlib on biolibraryconstructionfunction(biolibraryob);

create index i_datasourcename on datasourceob(datasourcename);


create index i_genotypesnapshotbiosubject on genotypesnapshotfunction(  biosubjectob );
create index i_genotypesnapshotwvf on genotypesnapshotfunction(  workstagevisitfact );
create index i_genotypesnapshotsnplsid on genotypesnapshotfunction(  snplsid );
create index i_genotypesnapshotsnpobid on genotypesnapshotfunction(  labresourceob );
create index i_genotypesnapshotgenotype1 on genotypesnapshotfunction(  biosubjectob , snplsid, workstagevisitfact, genotype);
create index i_genotypesnapshotgenotypebsw on genotypesnapshotfunction(  biosubjectob , snplsid, workstagevisitfact);

create index i_genotypesnapshotgenotype2 on genotypesnapshotfunction(  biosubjectob , labresourceob, workstagevisitfact, genotype);
create index i_genotypesnapshotgenotypeblw on genotypesnapshotfunction(  biosubjectob , labresourceob, workstagevisitfact);









/*
*
* set up the standard display procedures
*
*/
insert into displayprocedureob(xreflsid,procedurename,procedurecomment)
values('displayProcedures.getSampleFactDisplay','getSampleFactDisplay','Procedure to graph sample facts');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment)
values('displayProcedures.getGenepixThumbnailDisplay','getGenepixThumbnailDisplay','Procedure to extract and present thumbnails for Genepix microarray experiments');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment)
values('displayProcedures.getGenepixThumbnailDisplayTable','getGenepixThumbnailDisplayTable','Procedure to extract and present thumbnails for Genepix microarray experiments, for multiple experiments in one page');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment)
values('displayProcedures.getSpotExpressionDisplay','getSpotExpressionDisplay','Procedure to graph microarray spot expression across all experiments that use the spot');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment)
values('displayProcedures.getExpressionMapDisplay','getExpressionMapDisplay','Procedure to graph an expression map');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment,proceduredescription)
values('displayProcedures.getSequenceAnnotationBundle','getSequenceAnnotationBundle','Procedure to display an annotation bundle for an object','Annotation');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment, proceduredescription)
values('displayProcedures.getInlineURL','getInlineURL','Procedure to display a URL inline','In-line Links');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment, proceduredescription)
values('displayProcedures.getSequenceTraceViewPanel','getSequenceTraceViewPanel','Procedure to display a sequence trace inline','In-line Trace Viewer');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment, proceduredescription)
values('displayProcedures.getGraphicFeaturePanel','getGraphicFeaturePanel','Procedure to display database hits and features in-line','In-line Blast and Feature Viewer');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment, proceduredescription)
values('displayProcedures.getAlleleFrequencyDisplay','getAlleleFrequencyDisplay','Procedure to display allele frequencies for a genetic test','Allele Frequency Viewer');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment, proceduredescription)
values('displayProcedures.getAffyProbeGraphs','getAffyProbeGraphs','Procedure to display Affy probe graphs for a spot','Affy Probe Graph Display');
insert into displayprocedureob(xreflsid,procedurename,procedurecomment, proceduredescription)
values('displayProcedures.getInlineTable','getInlineTable','Procedure to display inline table data','Inline table display');

insert into displayprocedureob(xreflsid,procedurename,procedurecomment, proceduredescription)
values('displayProcedures.getContigAlignmentViewPanel','getContigAlignmentViewPanel','Procedure to display inline ace assembly info','Inline ace assembly display');




/*
*
* set up standard security procedures
*
*/
insert into securityprocedureob(xreflsid,procedurename)
values('getLSIDRuleBasedPermission','getLSIDRuleBasedPermission');


/*
***************************************************
Misc general utility functions : sequence functions
***************************************************
*/
create or replace function getCutPositionLeft("varchar", "varchar", int4)
   returns integer AS
'
DECLARE
   cutpos int;
BEGIN
   cutpos := getOrientedCutPositionLeft($1,$2,$3);

   if cutpos = 0 then
      -- try reverse complementing the recognition sequence
      cutpos := getOrientedCutPositionLeft(reverseComplement($1),$2,$3);
      if cutpos > 0 then
         cutpos = 1 + length($1) - cutpos - 1; -- -1 as we want the position to the left of the cut point, but in reverse we will have pos to right
      end if;
   end if;

   return cutpos;
END;
'
LANGUAGE 'plpgsql' VOLATILE;






CREATE OR REPLACE FUNCTION getOrientedCutPositionLeft("varchar", "varchar", int4)
  RETURNS integer AS
'
DECLARE
   argsequence alias for $1;
   argrecognitionseq alias for $2;
   argstartpos alias for $3;
   targetseq varchar;
   recognitionseq varchar;
   subcutpos int;
   cutpos int;
BEGIN
   -- recognition seq is expressed as (e.g.) TTT^AAA which indicates that
   -- the sequence is cut at the carat. This function would return the 
   -- (1 based) postion of the sequence base immediately to the left
   -- of any cut point that exists past position argstartpos in the sequence - i.e.
   -- this function is used to walk through the sequence finding all cut points
   -- enzyme examples : 
   -- http://rebase.neb.com/rebase/enz/HaeIII.html
   -- http://rebase.neb.com/rebase/enz/DraI.htmlv
   --
   -- note that this function does not test the reverse complement - hence the oriented
   -- part of the name. It is assumed that the caller of this function will try the 
   -- reverse complement if this was appropriate

   recognitionseq := upper(argrecognitionseq);

   -- where the cut is in the recognition seq
   subcutpos := position(''^'' in argrecognitionseq);

   -- get rid of the cut carat symbol for the search
   recognitionseq := replace(argrecognitionseq,''^'','''');

   -- start seach from startpos
   targetseq := upper(substr(argsequence,argstartpos));

   -- get recognition match position
   cutpos := position(recognitionseq in targetseq);   

   if cutpos > 0 then

      -- calculate cut postion left, using position of target within main sequence and
      -- position of cut within the recognition sequence
      -- e.g. 
      --    ACGTTTAAA
      --       ^ initial match
      --         ^ cut position left
      --      4 + 4 - 2 = 6  

      cutpos := (cutpos + subcutpos - 2) + argstartpos - 1;

   end if;


   return cutpos;
END;
'
LANGUAGE 'plpgsql' VOLATILE;


create or replace function reverseComplement(varchar) returns varchar as '
declare
   _temp varchar;
   _count int;
   base char;
   rbase char;
begin
   -- 6/2010 exclude various allele codes such as INS, DEL. Also handle the + symbol in a similar way to the 
   -- - symbol
   if upper(trim($1)) in (''INS'',''DEL'') then 
      return upper($1);
   end if;

   _temp := '''';
   for _count in reverse length($1)..1 loop
      base := substring($1 from _count for 1);
      rbase := CASE
         when base = ''C'' then ''G''
         when base = ''G'' then ''C''
         when base = ''A'' then ''T''
         when base = ''T'' then ''A''
         when base = ''c'' then ''g''
         when base = ''g'' then ''c''
         when base = ''a'' then ''t''
         when base = ''t'' then ''a''
         when base = ''^'' then ''^''
         when base = ''N'' then ''N''
         when base = ''n'' then ''n''
         when base = ''X'' then ''X''
         when base = ''x'' then ''x''
         when base = ''/'' then ''/''
         when base = ''?'' then ''?''
         when base = ''-'' then ''-''
         when base = ''+'' then ''+''
         when base = '' '' then '' ''
         else ''?''
         END;
      if rbase = ''?'' then
         RAISE EXCEPTION ''unhandled DNA symbol  % '', base;
      end if;

      _temp := _temp || rbase;
      end loop;
   return _temp;
end;
' language plpgsql immutable;



-- function to look up a given feature for a sequence, and return a string
-- being the sequence with the feature marked
create or replace function markFeature(integer, varchar, varchar) returns varchar as '
declare
   argobid alias for $1;
   argfeaturetype alias for $2;
   markmethod alias for $3;
   markedseqstring varchar;
   featstart integer;
   featstop integer;
   featstrand integer;
   featCursor refcursor;
begin

   if markmethod != ''lowercase'' and markmethod != ''X'' then
      raise exception ''only lower case or X masking is currently supported'';
   end if;

  
   -- examples : 7612140, 7466140
   select seqstring into markedseqstring from 
   biosequenceob where obid = argobid;

   

   open featCursor for 
   select featurestart,featurestop,featurestrand
   from biosequencefeaturefact where
   biosequenceob = argobid and featuretype = argfeaturetype;

   fetch featCursor into featstart,featstop,featstrand;

   while FOUND loop
      if featstrand <= 0  then
         raise exception ''only features on + strand are currently supported'';
      end if;
 
      markedseqstring := overlay(markedseqstring placing lower(substr(markedseqstring,featstart,1+featstop-featstart)) from featstart for 1+ featstop-featstart );    

      fetch featCursor into featstart,featstop,featstrand;
   end loop;

   close featCursor;

   if markmethod = ''X'' then
      markedseqstring := replace(replace(replace(replace(markedseqstring,''a'',''X''),''c'',''X''),''g'',''X''),''t'',''X'');
   end if;
  
   return markedseqstring;
end;
' language plpgsql immutable;





/*
* this will be overridden in specific database instances
*/
CREATE OR REPLACE FUNCTION getAffyProbeNormalisationFactor(int4, int4)
  RETURNS "varchar" AS
'
    BEGIN
       return null;
    END;
'
  LANGUAGE 'plpgsql' VOLATILE;



CREATE OR REPLACE FUNCTION getCharCount(varchar, varchar, boolean) RETURNS int4 AS
'
declare
   argchar alias for $1;
   countchar alias for $2;
   casesensitive alias for $3;
BEGIN
   if casesensitive then
       return length(argchar) - length(replace(argchar,countchar,''''));
   else
       return length(argchar) - length(replace(lower(argchar),lower(countchar),''''));   
   end if;
END;
'
LANGUAGE 'plpgsql' VOLATILE;



CREATE OR REPLACE FUNCTION getBaseComposition(varchar, varchar, varchar) RETURNS varchar AS
'
declare
   argchar alias for $1;
   format alias for $2;
   charcase alias for $3;
   composition varchar;
BEGIN

   if upper(format) != ''CSV'' then
      raise exception ''only CSV format base composition is currently supported'';
   end if;

   if upper(charcase) != ''UPPER'' and upper(charcase) != ''LOWER'' and upper(charcase) != ''ANY'' then
      raise exception ''case must be UPPER ,  LOWER or ANY '';
   end if;


   if upper(charcase) = ''UPPER'' then
      composition := ''A,C,G,T : ''|| 
                    getCharCount(argchar, ''A'', true) || '','' ||
                    getCharCount(argchar, ''C'', true) || '','' ||
                    getCharCount(argchar, ''G'', true) || '','' ||
                    getCharCount(argchar, ''T'', true) ;
   elsif upper(charcase) = ''LOWER'' then
      composition := ''a,c,g,t : ''|| 
                    getCharCount(argchar, ''a'', true) || '','' ||
                    getCharCount(argchar, ''c'', true) || '','' ||
                    getCharCount(argchar, ''g'', true) || '','' ||
                    getCharCount(argchar, ''t'', true) ;
   else
      composition := ''Aa,Cc,Gg,Tt : ''|| 
                    getCharCount(argchar, ''A'', false) || '','' ||
                    getCharCount(argchar, ''C'', false) || '','' ||
                    getCharCount(argchar, ''G'', false) || '','' ||
                    getCharCount(argchar, ''T'', false) ;
   end if;

   return composition;


END;
'
LANGUAGE 'plpgsql' VOLATILE;

 

   



/*
* return a count of the location on a given map - if no chromosome is specified, then 
* just indicate location count on the map.
* Optionally just return a boolean count of 0 or 1 - present or absent - or
* return a count of all instances on the map
*/
CREATE OR REPLACE FUNCTION getGenomicMapSequenceLocation(varchar, varchar, int4, boolean) RETURNS int4 AS
'
declare
   locationquery refcursor;
   argmapname alias for $1;
   argchromosome alias for $2;
   argsequence alias for $3;
   countall alias for $4;
   locationcount int4;
   locationflag int4;
BEGIN

   if argchromosome is not null then
      open locationquery for 
      select 1 from geneticlocationfact where
      biosequenceob = argsequence and
      mapname = argmapname and 
      chromosomename = argchromosome;
   else
      open locationquery for 
      select 1 from geneticlocationfact where
      biosequenceob = argsequence and
      mapname = argmapname ;
   end if;
      
   fetch locationquery into locationcount;
   if not FOUND then
      locationcount := 0;
   end if;

   if countall then
      fetch locationquery into locationflag;
      while FOUND loop
         fetch locationquery into locationflag;
         locationcount := locationcount + 1;
      end loop;
   end if;

   close locationquery;

   return locationcount;

END;
'
LANGUAGE 'plpgsql' VOLATILE;


CREATE OR REPLACE FUNCTION getSequenceSubject(int4,varchar) RETURNS varchar AS
'
declare
   argsequence alias for $1;
   argidtype alias for $2;
   subjectquery refcursor;
   resultsubject varchar;
   shortid varchar;
   resultobid int4;
BEGIN
   if upper(argidtype) != ''FULL'' and upper(argidtype) != ''SHORT'' then
      raise exception ''only FULL or SHORT id types may be submitted'';
   end if;


   open subjectquery for
   select
      s.obid, 
      s.xreflsid 
   from 
      ((((importfunction if join predicatelink p on 
      if.ob = argsequence and 
      if.datasourceob = p.objectob and 
      p.predicate = ''PRODUCES'') join
      librarysequencingfunction lsf on 
      lsf.datasourceob = p.subjectob)  join
      biolibraryconstructionfunction blf on 
      blf.biolibraryob = lsf.biolibraryob ) join
      biosamplingfunction sf on 
      sf.biosampleob = blf.biosampleob ) join
      biosubjectob s on s.obid = sf.biosubjectob;

    resultsubject := null;
    fetch subjectquery into resultobid, resultsubject;
 
    if resultsubject is null then
       resultsubject := '''';
    end if;

    close subjectquery;

   
    if upper(argidtype) = ''SHORT'' then
       -- try to get short name
       open subjectquery for
       select attributevalue from 
       biosubjectfact
       where factnamespace = ''Basic Details'' and
       attributename = ''Short Name'' and
       biosubjectob = resultobid;
       
       shortid := null;
       fetch subjectquery into shortid ;

       if shortid is not null then
           resultsubject := shortid;
       end if;

       close subjectquery;
    end if;   


    return resultsubject;
END;
'
LANGUAGE 'plpgsql' VOLATILE;




/*
* function to get a genbank 
* record
*/
CREATE OR REPLACE FUNCTION getagresearchgenbankrecord(character varying)
  RETURNS character varying AS
$BODY$  

DECLARE
   cursr refcursor;
   speciesVal varchar;
   taxidVal varchar;
   source varchar;
   
   seqname varchar;
   seqtypeholder varchar;
   seqlen integer;
   seqstr varchar;
   seqtype varchar;
   seqtop varchar;
   seqdate date;

   feattype varchar;
   featstart integer;
   featstop integer;
   featxref varchar;
   featcom varchar;
   featevid varchar;

   --biosequenceobid ALIAS for $1;
   biosequenceobid integer;
   seqbuff varchar;
   strbuff varchar;

   comments varchar;
   position integer;
   basesize integer;
   lastfeature varchar;
   lastseqstart integer;
   lastseqstop integer;

BEGIN
   --Test if obid is an obid or is an xreflsid
   select into biosequenceobid obid from biosequenceob where xreflsid = $1;
   if not FOUND then
      biosequenceobid := $1;
   end if;
   
   strbuff := '';

   open cursr for
    select
       sequencename,    --name                                 seqname
       seqlength,       --number of bp's or aa's               seqlen
       seqstring,       --dna/aa sequence                      seqstr
       sequencetype,    --type of sequence, eg "genomic DNA"   seqtype
       sequencetopology,--type of sequence, eg "genomic DNA"   seqtop
       createddate      --date record was created              seqdate
    from
       biosequenceob
    where
       obid = biosequenceobid;
    
   fetch cursr into seqname, seqlen, seqstr, seqtype, seqtop, seqdate;

   close cursr;
   
   if (strpos(seqtype,'RNA') > 0) then
      seqtypeholder = ' bp    RNA';
   elsif (strpos(seqtype,'DNA') > 0) then
      seqtypeholder = ' bp    DNA';
   elsif (strpos(seqtype,'PROTEIN') > 0) then
      seqtypeholder = ' aa       ';
   else
      seqtypeholder = '          ';
   end if;

   -- LOCUS       <externalname>
   if (length(seqname)<25) then
      seqbuff := 'LOCUS       '||rpad(seqname, 25, ' ');
   else 
      seqbuff := 'LOCUS       '||seqname||' ';
   end if;
   strbuff := strbuff||seqbuff;
   
   seqbuff := seqlen||
        seqtypeholder||'     '||
        seqtop||'   '||
        '    '|| --MAM, INV, etc (the genus? e.g. Mammal, Invertebrate - is this recorded?)
        to_char(seqdate, 'DD-MON-YYYY')||chr(10);
   strbuff := strbuff||seqbuff;

   -- ACCESSION   <externalname>
   seqbuff := 'ACCESSION   '||seqname||chr(10);
   strbuff := strbuff||seqbuff;

    -- SOURCE      AgResearch
   select into source su.subjectspeciesname 
   from biosubjectob su, biosamplingfunction f, biosampleob sa, sequencingfunction se
   where su.obid = f.biosubjectob
   and f.biosampleob = sa.obid
   and sa.obid = se.biosampleob
   and se.biosequenceob = biosequenceobid;
   
   if FOUND then 
      seqbuff := 'SOURCE      '||source||chr(10);
      strbuff := strbuff||seqbuff;
   end if;
    
   open cursr for
    select
       speciesname, --speciesVal
       speciestaxid --taxidVal
    from
       geneticlocationfact 
    where
       biosequenceob = biosequenceobid
       and speciestaxid is not null;

   fetch cursr into speciesVal, taxidVal;

   close cursr;
   
   if NOT FOUND then --is this right? Will it do what I want???
      speciesVal := '';
      taxidVal := '';
   end if;

   -- TAXON (Source Organism)
   if speciesVal != '' then
      seqbuff := '  ORGANISM  '||speciesVal||chr(10);
      strbuff := strbuff||seqbuff;
   end if;

   open cursr for
     select
        featuretype,    --feature title  feattype
        featurestart,   --start pos      featstart
        featurestop,    --stop pos       featstop
        xreflsid,       --/db_xref=      featxref
        featurecomment, --/note=         featcom
        evidence        --/evidence=     featevid
     from
        biosequencefeaturefact
     where
        biosequenceob = biosequenceobid
     order by
        featurestart,
        featurestop,
        featuretype;
   
   fetch cursr into feattype, featstart, featstop, featxref, featcom, featevid;
   
   -- FEATURES
   if (speciesVal != '') or FOUND then
      seqbuff := 'FEATURES              Location/Qualifiers'||chr(10);
      strbuff := strbuff||seqbuff;
   end if;

   -- TAXON (Feature)
   if (speciesVal != '') then
      seqbuff := '     source           1..'||seqlen||chr(10);
      strbuff := strbuff||seqbuff;
      seqbuff := '                     /organism="'||speciesVal||'"'||chr(10);
      strbuff := strbuff||seqbuff;
      if (taxidVal != '') then
          seqbuff := '                     /db_xref="taxon:'||taxidVal||'"'||chr(10);
          strbuff := strbuff||seqbuff;
      end if;
   end if;

   -- CDS and GENES
   lastfeature := 'blurb';
   lastseqstart := -1;
   lastseqstop := -1;
   while FOUND loop
      if (feattype <> lastfeature or featstart <> lastseqstart or featstop <> lastseqstop) then
         if featstop >= featstart then
            seqbuff := '     '||rpad(feattype,16,' ')||featstart||'..'||featstop||chr(10);
         else
            seqbuff := '     '||rpad(feattype,16,' ')||'complement('||featstop||'..'||featstart||')'||chr(10);
         end if;
         strbuff := strbuff||seqbuff;
         lastfeature := feattype;
         lastseqstart := featstart;
         lastseqstop := featstop;
      end if;
      if (featxref != '') then
         seqbuff := '                     /db_xref="'||featxref||'"'||chr(10);
         strbuff := strbuff||seqbuff;
      end if;
      if (featevid != '') then
         seqbuff := '                     /evidence="'||featevid||'"'||chr(10);
         strbuff := strbuff||seqbuff;
      end if;
      if (featcom != '') then
         seqbuff := '                     /comment="'||featcom||'"'||chr(10);
         strbuff := strbuff||seqbuff;
      end if;
      fetch cursr into feattype, featstart, featstop, featxref, featcom, featevid;
   end loop;

   close cursr;
   
/*   -- COMMENTS formatted into lines of 68 chars plus 'COMMENT     '
   comments := getAgResearchGenbankComments(seqname,dbname);
   if (length(comments) > 0) then
      seqbuff := rpad('COMMENT',12,' ');
      strbuff := strbuff||seqbuff;
      position := 1;
      basesize := 68;
      while (position <= length(comments)) loop
         seqbuff := substr(comments,position,basesize);
         seqbuff := seqbuff || chr(10);
         strbuff := strbuff||seqbuff;
         position := position + 68;
         if (position < length(comments)) then
            seqbuff := lpad(' ',12,' ');
            strbuff := strbuff||seqbuff;
         end if;
      end loop;
   end if;*/

   -- ORIGIN
   seqbuff := 'ORIGIN';
   strbuff := strbuff||seqbuff;

   -- <7-9 spaces base number> <6 groups of 10 bases>
   position := 1;
   basesize := 10;
   while (position <= seqlen) loop
      if (mod(position,60) = 1) then
         seqbuff := chr(10)||lpad(to_char(position,'FM99999'),9,' ')||' ';
         strbuff := strbuff||seqbuff;
      end if;
      seqbuff := substr(seqstr,position,basesize);
      seqbuff := seqbuff || ' ';
      strbuff := strbuff||seqbuff;
      position := position + 10;
   end loop;

   -- //
   seqbuff := chr(10)||'//'||chr(10);
   strbuff := strbuff||seqbuff;

   return strbuff;
END
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;






CREATE OR REPLACE FUNCTION getagresearchfastarecord(character varying)
  RETURNS text  AS
$BODY$  

DECLARE
   cursr refcursor;

   biosequenceobid integer;
   seqname varchar;
   seqbuff text;
   strbuff text;

BEGIN
   --Test if obid is an obid or is an xreflsid
   select into biosequenceobid obid from biosequenceob where xreflsid = $1;
   if not FOUND then
      biosequenceobid := $1;
   end if;
   
   strbuff := '';

   open cursr for
    select
       xreflsid ,
       seqstring
    from
       biosequenceob
    where
       obid = biosequenceobid;
    
   fetch cursr into seqname, seqbuff;

   close cursr;
   
   strbuff := '>'||seqname||chr(10)||seqbuff;
   

   return strbuff;
END
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;




/*
* make a fasta format string 
* out of two strings - one the id line, the other the 
* sequence
*/
CREATE OR REPLACE FUNCTION makefasta(character varying, character varying)
  RETURNS text  AS
$BODY$  

DECLARE
   idline alias for $1;
   seqstring alias for $2;
   strbuff text;
   seqpos integer;

BEGIN   
   strbuff := '>' || idline || chr(10);

   seqpos := 1;

   while seqpos <= length(seqstring) loop
      strbuff := strbuff || substr(seqstring,seqpos,60) || chr(10);
      seqpos := seqpos + 60;
   end loop;

   return strbuff;
END
$BODY$
  LANGUAGE 'plpgsql' VOLATILE;












    


CREATE OR REPLACE FUNCTION getSequenceSourceFile(varchar) RETURNS varchar AS
'
declare
   argsequence alias for $1;
   sourcefile varchar;
   sourcequery refcursor;
BEGIN
   open sourcequery for
      select
         ds.physicalsourceuri as sfffilename
      from
         ((biosequenceob sq join importfunction if on
         if.ob = sq.obid ) join predicatelink p on
         if.datasourceob = p.objectob and p.predicate = ''PRODUCES'' ) join
         datasourceob ds on ds.obid  = p.subjectob
      where
         sq.sequencename = argsequence;

    fetch sourcequery into sourcefile;
    close sourcequery;
    return sourcefile;
END;
'
LANGUAGE 'plpgsql' VOLATILE;


/*
* this script will install a contributed table in the 
brdf schema.

It assumes that the table has already been imported and
the following mods done : 

alter table gene_info add
   datasourceob integer;
   voptypeid integer;

- it then does updates like this : 

update gene_info set 
    datasourceob = 43283968, -- should be the obid of the data source you created above
    voptypeid = 10000;

insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(10000, 'NCBI Entrez Gene : Gene info table','gene_info',FALSE,'NCBI Entrez Gene Gene info',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 10000,   obtypeid,   'datasourceob' from obtype where  upper(tablename) = 'DATASOURCEOB';

*/

CREATE OR REPLACE FUNCTION installContributedTable(varchar, varchar, varchar) RETURNS integer AS
'
declare
   contribtablename alias for $1;
   displaytext alias for $2;
   descriptiontext alias for $3;

   sqlcode varchar;
   typeid integer;
   maxtypeid integer;
   mintypeid integer;
   junk integer;
   rec record;
   mycount integer;
   msg varchar;
   installquery refcursor;
   newobid integer;
BEGIN
   mintypeid = 10000;
   maxtypeid = 100000;


   -- try selecting datasourceob and voptypeid from the 
   -- table to check its been done properly - if not add these columns
   sqlcode := ''select datasourceob , voptypeid from '' || contribtablename;

   begin
      for rec in EXECUTE sqlcode LOOP 
         exit;
      end loop;
   exception
      when others then
      sqlcode = ''alter table '' || contribtablename || '' add datasourceob integer'';
      EXECUTE sqlcode;
      sqlcode = ''alter table '' || contribtablename || '' add voptypeid integer'';
      EXECUTE sqlcode;

      -- used to just fail it
      --raise exception ''Failed executing check query %'' , sqlcode;
   end;

   -- now check that this table has not already been installed. It is not necessarily an error to install 
   -- a table more than once- however it should certainly not have identical display and description names
   select count(*) into mycount from obtype where upper(tablename) = upper(contribtablename)
          and upper(displayname) = upper(displaytext) 
          and upper(obtypedescription) = upper(descriptiontext);

   if mycount > 0 then
      raise exception ''A table with this name and identical description and displayname is already installed'';
   end if;
   
 
   -- obtain the next typeid that we can use for this fact dimension. By convention all the contributed
   -- fact tables have a typeid are > 10000
   typeid := mintypeid;
   while typeid < 100000 loop
      select obtypeid into junk from obtype where obtypeid = typeid;
      exit when not FOUND;
      typeid := typeid + 1;
   end loop;

   if typeid > 100000 then
      raise exception ''Unable to obtain a data dimension typeid within range'';
   end if;


   -- check to see whether there is an existing data source to use - if not set up the data source
   newobid := null;
   select obid into newobid from datasourceob where xreflsid = ''Contributed Table.''||contribtablename;
   if newobid is null then

      -- set up the new data source
      select nextval(''ob_obidseq'') into newobid;

      insert into datasourceob (
         obid,
         xreflsid,
         datasourcename,
         datasourcetype,
         datasourcecomment)
      values (
         newobid,
         ''Contributed Table.''||contribtablename,
         displaytext,
         ''Contributed Database Table'',
         descriptiontext
      );
   end if;



   -- set up the new dimension 
   insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
   values(typeid, displaytext,contribtablename,FALSE,descriptiontext,TRUE,TRUE);

   insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
   select typeid,   obtypeid,   ''datasourceob'' from obtype where  upper(tablename) = ''DATASOURCEOB'';

   sqlcode := ''update '' || contribtablename || 
              '' set datasourceob = '' || to_char(newobid,''999999999'')||
               '',voptypeid = '' || to_char(typeid,''9999999'') ||
               '' where datasourceob is null'';
   EXECUTE sqlcode;


   -- create a required index, replacing any dots in the index name (e.g. if installing a table in another schema)
   sqlcode = ''create index isystem_'' || replace(contribtablename,''.'',''_'') || '' on '' || contribtablename || ''(datasourceob, voptypeid)'';
   EXECUTE sqlcode;

   return typeid;
END;
'
LANGUAGE 'plpgsql' VOLATILE;

--example
--select installContributedTable('running_numbers102012', 'running_numbers102012','running_numbers102012');




-- stored func to create hyperlinks
CREATE OR REPLACE FUNCTION makeHyperlink(varchar, varchar,varchar,varchar) RETURNS varchar AS
'
declare
   argurl alias for $1;
   argdisplay alias for $2;
   argurlbindvalue alias for $3;
   argtarget alias for $4;
   hyperlink varchar(5192);
BEGIN
   hyperlink := argurl;
 
   if argurlbindvalue is not null then
      hyperlink := replace(hyperlink,''$$'',argurlbindvalue);
   end if;

   hyperlink := ''<a href="'' || hyperlink || ''" '';

   if argtarget is not null then 
      hyperlink := hyperlink || '' target='' || argtarget;
   end if;

   hyperlink := hyperlink || ''>'' || argdisplay || ''</a>'';

   return hyperlink;
END;
'
LANGUAGE 'plpgsql' VOLATILE;


-- hex to integer
CREATE FUNCTION from_hex(t text) RETURNS integer AS $$
  DECLARE
    r RECORD;
  BEGIN
    FOR r IN EXECUTE 'SELECT x'''||t||'''::integer AS hex' LOOP
      RETURN r.hex;
    END LOOP;
  END
$$ LANGUAGE plpgsql IMMUTABLE STRICT;


-- format a small floating point number
create or replace function format_evalue(double precision) returns varchar as $$
declare
   evalue alias for $1;
   mantissa double precision;
   exponent integer;
   strevalue varchar;
begin
   strevalue := '';
   if evalue = 0.0 then
      strevalue := '0.0';
   else 
      exponent := round(log(evalue));
      mantissa := evalue/power(10,exponent);
      strevalue := to_char(mantissa,'999.999') || 'e' || rtrim(ltrim(to_char(exponent,'99999')));
   end if;

   return strevalue;
end
$$ LANGUAGE plpgsql IMMUTABLE STRICT;





   
   

/*
* 
example : 
agrbrdf=> select makeHyperlink('http://blah$$','hello','123','none');
                   makehyperlink
---------------------------------------------------
 <href http="http://blah123"  target=none>hello</>
*/






/*
* example

alter table print139annotation add
   datasourceob integer;

alter table print139annotation add
   voptypeid integer;


select installContributedTable('print139annotation', 'Print 139 Gene Annotation', 'Print 139 Gene Annotation');
select installContributedTable('LisaFan_Expt136_lowscan_no_bg_corr', 
'Print 136 Lisa Fan experiment normalisation - low scans with no background correction',
'Print 136 Lisa Fan experiment normalisation - low scans with no background correction');



*/





/****************************
* 
* Some standard contributed tables are accessed as fact tables - set up
* virtual fact relations for them  
*
*****************************/
/* disabled - possibly deprecated, can't remember the use-case for this
insert into obtype (obtypeid , displayname, tablename, namedinstances, obtypedescription,isop,isvirtual)
values(10000, 'NCBI Entrez Gene : Gene info table','gene_info',FALSE,'NCBI Entrez Gene Gene info',TRUE,TRUE);
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 10000,   obtypeid,   'datasourceob' from obtype where  upper(tablename) = 'DATASOURCEOB';
*/


/****************************
*
* Some standard analysis procedures
*
*****************************/
insert into analysisprocedureob ( 
xreflsid, 
procedurename ,    
author ,        
authordate ,
proceduredescription ,
proceduretype    ,
presentationtemplate )
values (
'bioc.microarrayslideanalysis1.r',
'microarrayslideanalysis1.r',
'Zaneta Park Ng',
'2008-05-13',
'Single GPR file standard analysis',
'R procedure',
'
   <!-- begintemplate

   <h2> Results </h2>

   <ul>
      <li> <a href="__textoutput1link__"> Sorted list of genes on the array (Right click and save to file) </a> 
      <li> <a href="__textoutput2link__"> Sorted list of spot coding (Right click and save to file) </a> 
      <li> <a href="#plotsummary1"> Basic Diagnostic Plots </a>
      <li> <a href="#streams"> Script stdout and stderr stream - output and warnings </a>
      <li> <a href="#status"> Script termination status </a>
   </ul>

   
   <p/>
   <a name="plotsummary1"/>
   Basic Diagnostic Plots 
   <p/>
   <h2> Box plot of raw logratios by spot category </h2>
   <img src="__imageoutput1link__"/>


   <p/>
   <a name="streams"/>
   <h2> Output and Warnings </h2>
   <pre>

   __output__     


   </pre>
   <p/>
   <a name="status"/>
   <h2> Status </h2>
   <pre>

   This script returned a status of __status__
     
   (success = 0)


   </pre>
   <p/>
   endtemplate --/>
');




insert into analysisprocedureob ( 
xreflsid, 
procedurename ,    
author ,        
authordate ,
proceduredescription ,
proceduretype    ,
presentationtemplate )
values (
'bioc.microarrayseriesanalysis1.r',
'microarrayseriesanalysis1.r',
'Zaneta Park Ng',
'2008-05-13',
'cDNA series standard analysis',
'python script',
'
   <!-- begintemplate

   <h2> Results </h2>

   <ul>
      <li> <a href="#plotsummary1"> Plots : Raw logratios by slide and spot category </a>
      <li> <a href="#plotsummary2"> Plots : Raw logratios by slide </a>

      <li> <a href="#streams"> Script stdout and stderr stream - output and warnings </a>
      <li> <a href="#status"> Script termination status </a>
   </ul>

   
   <p/>
   <a name="plotsummary1"/>
   Basic Diagnostic Plots 
   <p/>
   <h2> Box plot of raw logratios by slide and spot category </h2>
   <img src="__imageoutput1link__"/>


   <p/>
   <a name="plotsummary2"/>
   Basic Diagnostic Plots 
   <p/>
   <h2> Box plot of Red foreground by slide </h2>
   <img src="__imageoutput2link__"/>

   <p/>
   <h2> Box plot of Red background by slide </h2>
   <img src="__imageoutput3link__"/>

   <p/>
   <h2> Box plot of Green foreground by slide </h2>
   <img src="__imageoutput4link__"/>

   <p/>
   <h2> Box plot of Green background by slide </h2>
   <img src="__imageoutput5link__"/>

   <p/>
   <a name="streams"/>
   <h2> Output and Warnings </h2>
   <pre>

   __output__     


   </pre>
   <p/>
   <a name="status"/>
   <h2> Status </h2>
   <pre>

   This script returned a status of __status__
     
   (success = 0)


   </pre>
   <p/>
   endtemplate --/>
');



/******************************************
*
* standard transactions
*
*******************************************/
/*
* stored procedure for merging subjects in the 
* nutrigenomics database. 
*/

/*
* set up the mergeSubjects workflow. 
*/

/* 
under development 

CREATE OR REPLACE FUNCTION mergeSubjects(varchar, int4, varchar, int4, varchar, varchar, varchar, varchar, varchar) RETURNS int4 AS
'
DECLARE
   from_lsid alias for $1;
   from_obid alias for $2;
   into_lsid alias for $3;
   into_obid alias for $4;
   workflowlsid alias for $5;
   workstagelsid alias for $6;
   transactionname alias for $7;
   transactiondescription alias for $8;
   username alias for $9;

   workflowid integer;
   querycursor refcursor;
BEGIN


   
   --
   --set up the workstage visit record
   --
   insert into workstagevisitfact(xreflsid, workflow, workflowstage,workdoneby,workdonedate,workcomment)
   select 
      workstagelsid|| '':'' || transactionname,
      w.obid,
      ws.obid,
      username,
      now(),
      transactiondescription
   from 
      (workflowob w join workFlowMembershipLink wml on
      wml.workflowob = w.obid) join workflowstage ws on
      ws.obid = wml.workflowstage
   where
      w.xreflsid = workflowlsid and
      ws.xreflsid = workstagelsid ;

      

   if not found then
      raise Exception ''No such workflow or work stage is defined - please set up the required workflow records first ''
   end if;
      
   

   --
   --initial checks
   --
*/



/**************************************************************************************
* Batch Tables
*
* A new set of five tables and some associated controlled  vocabularies will be 
* set up to help support managing batches in NuNZ.  These five tables will model 
* a batch as an annotated (optionally ordered) list of either database or external 
* objects, with a many to many relationship between batches and things (a batch may 
* contain more than one thing; a thing may be a member of more than one batch). 
* A batch may contain any object in the NuNZ database that has been assigned an 
* obid; it may also contain/ refer to  any object external to NuNZ that can be 
* identified uniquely by (for example) a URL. 
***************************************************************************************/



/*
A batch is an annotated (optionally ordered) list of either database or external objects, with 
a many to many relationship between batches and things (a batch may contain more than one thing; 
a thing may be a member of more than one batch). A batch may contain any object in the 
database that has been assigned an obid (including other batches); it may also contain/ refer to  
any object external to  NuNZ that can be identified uniquely by (for example) a URL. 
*/



/*
* 
* create the main batch table. Note that this inherits housekeeping columns such 
* as record created dates etc from the ob table.
*
* Additional details we may wish to record about a batch- such as contact
* details for people associated with the batch ; storage details (freezer ? etc)
* etc etc ....are stored in the batchfact table, which provides key-value storage
* of arbitrary batch attributes. The batchob table itself only stores basic details 
* which are likely to be common to all batches. 
*
* Narrative details over time regarding the batch are stored in the batchNarrativeFact
* table defined below.
*
* 
*/
\echo creating batchOb
create table batchOb (
   batchName varchar(256) not null,
   membershipCount integer,
   batchDescription text ,
   batchKeywords text,    
   batchtype varchar(128),
   batchStatus varchar(128),
   check (obtypeid = 590) ,
   primary key (obid) )
   inherits(ob) 
   without oids;
\echo initialising obtype
insert into obtype(   obtypeid , displayName,   tablename ,   obtypedescription,displayurl) 
values (590,'Batch','batchOb','Batch','batch.jpg');
\echo attaching trigger
CREATE TRIGGER setObType BEFORE INSERT ON batchOb
    FOR EACH ROW EXECUTE PROCEDURE setObType(590);



/*
* create assay result coding ontology. 
*/
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('FOOD FRACTION HTP ASSAY RESULT CODING TERMS(1)','This ontology is one of several providing standard terms for coding food fraction assay results','ontology.FOOD FRACTION HTP ASSAY RESULT CODING TERMS(1)');
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'FOOD FRACTION HTP ASSAY RESULT CODING TERMS(1).Showed Activity',
       'Showed Activity',
       'The shape of the graph of responses with varying dilution was used to judge the this sample did show activity' 
   from ontologyOb 
        where ontologyName = 'FOOD FRACTION HTP ASSAY RESULT CODING TERMS(1)';

insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'FOOD FRACTION HTP ASSAY RESULT CODING TERMS(1).Did Not Show Activity',
       'Did Not Show Activity',
       'The shape of the graph of responses with varying dilution was used to judge the this sample did not show activity' 
   from ontologyOb 
        where ontologyName = 'FOOD FRACTION HTP ASSAY RESULT CODING TERMS(1)';

/*
* ....there may be other codes indicating (e.g.) toxicity or failure of assay
*/











/*
* create batch type ontology. 
*/
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BATCH_TYPES','This ontology provides standard terms for types of batch','ontology.BATCH_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_TYPES',
       'Food Fraction for HTP assay',
       'A batch of food fractions submitted for Assay' 
   from ontologyOb 
        where ontologyName = 'BATCH_TYPES';


insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_TYPES',
       'Mouse Tissue sample for proteomics assay',
       'A batch of mouse tissue samples submitted for proteomics assay' 
   from ontologyOb 
        where ontologyName = 'BATCH_TYPES';


/*
* etc - many different types of 
* batch
*/



/*
* create batch status ontology. 
*/
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BATCH_STATUS','This ontology provides standard terms for describing the status of a batch','ontology.BATCH_STATUS');

/* 
* main batch status flags
*/
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_STATUS',
       'New, In preparation',
       'The batch has been defined but not yet prepared' 
   from ontologyOb 
        where ontologyName = 'BATCH_STATUS';

insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_STATUS',
       'Preparation completed, In Storage',
       'The batch has been prepared and has been stored pending further processing' 
   from ontologyOb 
        where ontologyName = 'BATCH_STATUS';


insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_STATUS',
       'Batch Destroyed',
       'The batch has been destroyed' 
   from ontologyOb 
        where ontologyName = 'BATCH_STATUS';


insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_STATUS.Batch Sent',
       'Batch Sent',
       'The batch has been sent' 
   from ontologyOb 
        where ontologyName = 'BATCH_STATUS';

insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_STATUS.Batch Radiated',
       'Batch Radiated',
       'The batch has been radiated' 
   from ontologyOb 
        where ontologyName = 'BATCH_STATUS';

insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_STATUS.Batch Received for Assaying',
       'Batch Received for Assaying',
       'The batch has been received for assaying' 
   from ontologyOb 
        where ontologyName = 'BATCH_STATUS';

insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_STATUS.Batch Used for Screening',
       'Batch Used for Screening',
       'The batch has been used for screening' 
   from ontologyOb 
        where ontologyName = 'BATCH_STATUS';





/*
* possible additional status flags we might
* need....
*/
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_STATUS',
       'Batch was split',
       'The batch was split into several other batches. (The split-details are recorded in the database via making the child batches members of the original  batch)' 
   from ontologyOb 
        where ontologyName = 'BATCH_STATUS';


\echo attaching ontology check on type 
CREATE or replace FUNCTION checkbatchObTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        if NEW.batchType is not null then 
           select into terms  * from ontologytermfact where termname = NEW.BatchType and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''BATCH_TYPES'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid batch type '', NEW.BatchType;
           else
              return NEW;
           end if;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkbatchObTypeOntology BEFORE INSERT OR UPDATE ON batchOb
    FOR EACH ROW EXECUTE PROCEDURE checkbatchObTypeOntology();


\echo attaching ontology check on status
CREATE or replace FUNCTION checkbatchObStatusOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        if NEW.batchstatus is not null then 
           select into terms  * from ontologytermfact where termname = NEW.batchstatus and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''BATCH_STATUS'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid batch status '', NEW.BatchStatus;
           else
              return NEW;
           end if;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkbatchObStatusOntology BEFORE INSERT OR UPDATE ON batchOb
    FOR EACH ROW EXECUTE PROCEDURE checkbatchObStatusOntology();



/*
* this table provides storage for narrative details relating to a batch
* - each record contains a free text comment, a time stamp, and 
* the batch status flag at the time the comment was made.
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(595,'Batch Narrative Fact','batchNarrativeFact',FALSE,'batchNarrativeFact',TRUE);
\echo creating batchNarrativeFact

create sequence bnf_narrationidseq;
create table batchNarrativeFact (
   narrationid integer  DEFAULT nextval('bnf_narrationidseq') primary key,
   batchOb integer not null references batchOb(obid), 
   narrativeNameSpace varchar(256),
   narrationName varchar(256),
   narration text,
   narrationDate date,
   batchstatus varchar(128))
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 595,   obtypeid,   'batchOb' from obtype where  upper(tablename) = 'BATCHOB';

\ echo attaching ontology check on batch status
CREATE TRIGGER checkNarrativeBatchStatusOntology BEFORE INSERT OR UPDATE ON batchNarrativeFact
    FOR EACH ROW EXECUTE PROCEDURE checkbatchObStatusOntology();


/*
* this table provides storage for general additional attributes
* of a batch, apart from batch narrative details. For example - contact 
* details of people associated with the batch ; storage details (freezer location etc)
* of a batch
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(600,'Batch Fact','batchFact',FALSE,'batchFact',TRUE);
\echo creating batchFact


create sequence bf_factidseq;
create table batchFact (
   factid integer  DEFAULT nextval('bf_factidseq') primary key,   
   batchOb integer not null references batchOb(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 600,   obtypeid,   'batchOb' from obtype where  upper(tablename) = 'BATCHOB';

COMMENT on table batchFact is 'this table provides storage for general additional attributes of a batch, apart from batch narrative details';




/*
* This table defines a many-to-many relationship via which an item may be a member of more than 
* one batch , and a batch may contain more than one item
*
* An associative table to implement the relationship between batches and the objects that each batch contains
* Note that we allow a batch to contain items that are not in the database, via a URL reference.
* For example we may wish to define a batch of (say) spots on a proteomics gel that we do 
* not have as records in the db. 
* 
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(610,'Batch Membership','batchNamedMembershipLink',TRUE, 'batchNamedMembershipLink',TRUE);
\echo creating batchNamedMembershipLink
create table batchNamedMembershipLink (
   batchOb integer not null references batchOb(obid),
   memberOb integer,
   memberxref varchar(2048), /* for references to external batch items */
   membershipType varchar(128),
   inclusionComment varchar(2048),  
   batchorder integer,
   addedDate date DEFAULT now(),
   addedBy varchar(256)
   check(obtypeid = 610) ,
   primary key(obid))
   inherits(op)
   without oids ;
\echo initialising optypesignature
COMMENT on table batchNamedMembershipLink is '* An associative table to implement the relationship between batches and the objects that each batch contains. Note that we allow a batch to contain items that are not in the database, via a URL reference.';




insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 610,   obtypeid,   'batchOb' from obtype where  upper(tablename) = 'BATCHOB';
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 610,   obtypeid,   'memberOb' from obtype where  upper(tablename) = 'OB';
CREATE TRIGGER setObType BEFORE INSERT ON batchNamedMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE setObType(610);

/*
* create batch membership type ontology. 
*/
insert into ontologyob(ontologyName,   ontologyDescription ,xreflsid)
values('BATCH_MEMBERSHIP_TYPES','This ontology provides standard terms for types of membership of a batch','ontology.BATCH_MEMBERSHIP_TYPES');
insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_MEMBERSHIP_TYPES',
       'Batch Item',
       'The batch item is a normal member of the batch' 
   from ontologyOb 
        where ontologyName = 'BATCH_MEMBERSHIP_TYPES';

insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_MEMBERSHIP_TYPES',
       'Batch Contents Data File',
       'The batch item is a data file (e.g. spreadsheet) that specifies the physical items in the batch' 
   from ontologyOb 
        where ontologyName = 'BATCH_MEMBERSHIP_TYPES';


insert into ontologyTermFact(ontologyOb,xreflsid,termName, termDescription) 
   select 
       obid,
       'BATCH_MEMBERSHIP_TYPES',
       'Batch Results Data File',
       'The batch item is a data file (e.g. spreadsheet) that contains experimental results for the physical items in the batch' 
   from ontologyOb 
        where ontologyName = 'BATCH_MEMBERSHIP_TYPES';


\echo attaching ontology check on membership type 
CREATE or replace FUNCTION checkBatchMembershipTypeOntology() RETURNS trigger AS '
    DECLARE
        terms RECORD;
    BEGIN
        if NEW.membershipType is not null then 
           select into terms  * from ontologytermfact where termname = NEW.membershipType and 
                          ontologyob = (select obid from ontologyOb where ontologyName = ''BATCH_MEMBERSHIP_TYPES'');
           if not FOUND then
              RAISE EXCEPTION ''% is not a valid batch membership type '', NEW.membershipType;
           else
              return NEW;
           end if;
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkbatchMembershipTypeOntology BEFORE INSERT OR UPDATE ON batchNamedMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE checkBatchMembershipTypeOntology();


\echo creating checkBatchMembershipKeys (workaround for foreign key restriction on inherited table)
CREATE FUNCTION checkBatchMembershipKeys() RETURNS trigger AS '
    BEGIN
        if new.memberob is not null then
           select obid into new.memberob from ob where obid = new.memberob;
           if not FOUND then
              RAISE EXCEPTION ''key error - member ob not found'';
           end if;
        end if;
        return NEW;
    END;
' LANGUAGE plpgsql;
CREATE TRIGGER checkBatchMembershipKeys BEFORE INSERT OR UPDATE ON batchNamedMembershipLink
    FOR EACH ROW EXECUTE PROCEDURE checkBatchMembershipKeys();



/*
* ( Note that while the use of the OB base table allows batches to 
* contain any type of object, database queries such as joins should 
* use the specific descendant tables (such as biosampleob, biosequence ob etc) 
* as appropriate to the type of batch being constructed )
*/



/*
* Each record in the associative table that defines batch membership may be qualified by details
* if required. For example - suppose we wish to record why (say) a specific item in a batch
* was not processed. This could be recorded as part of the overall batch narrative, but 
* could also be recorded as a detail of the individual membership record for the 
* object concerned
*/
\echo initialising obtype
insert into obtype (obtypeid , displayname, tablename, namedInstances, obtypedescription, isop)
values(620,'Named List Membership Fact','batchNamedMembershipLinkFact',FALSE,'batchNamedMembershipLinkFact',TRUE);
\echo creating batchNamedListMembershipLinkFact


create sequence bnlmf_factidseq;
create table batchNamedMembershipLinkFact (
   factid integer  DEFAULT nextval('bnlmf_factidseq') primary key,   
   batchNamedMembershipLink integer not null references batchNamedMembershipLink(obid),
   factNameSpace varchar(256),
   attributeName varchar(256),
   attributeValue text)
   without oids;
\echo initialising optypesignature
insert into optypesignature (   obtypeid , argobtypeid , optablecolumn )
select 620,   obtypeid,   'batchNamedMembershipLink' from obtype where  upper(tablename) = 'BATCHNAMEDMEMBERSHIPLINK';







/**************************************************************************************
* Fractions
*
* Currently, the biosamplingfunction table only allows a sample record to have a subject record 
* as a parent. This table will be modified so that a sample can have another sample as a parent. 
* This will allow sub-sampling/sub-fractionation, recursing to any depth. This will require : 
* 
* A new column added to the biosamplingfunction table: "parentsample". 
* The biosubjectob column in this table is currently required to be not null. This constraint will be removed
* A modified non-null  constraint will be added to this table, requiring that exactly one, but not both, of 
  the biosubjectob or parentsample columns must be not null and referring to a biosubjectob or biosampleob record.
***************************************************************************************/


/* 

tried dropping  the unique constraint which is now redundant - but
the cascade for some reason also dropped the foreign key constrainy on 
the fact table. Rather than do this , we will leave both the unique and 
primary key constraints in force for the time being
nutrigenomics=>  alter table biosamplingfunction
nutrigenomics-> drop constraint biosamplingfunction_obid_key cascade;
NOTICE:  drop cascades to constraint $1 on table biosamplingfact
ALTER TABLE
*/

\echo attaching check on composite foreign key - sample must have either subject or sample as parent but not both
CREATE or replace FUNCTION checkSamplingKeys() RETURNS trigger AS '
    BEGIN
        if (NEW.parentsample is not null and NEW.biosubjectob is not null) or
           (NEW.parentsample is null and NEW.biosubjectob is null) then 
              RAISE EXCEPTION ''A sampling record must refer to either a parent biosubject or a parent biosample but not both'';
        else
           return NEW;
        end if;
    END;
' LANGUAGE plpgsql;

CREATE TRIGGER checkSamplingKeys BEFORE INSERT OR UPDATE ON biosamplingfunction
    FOR EACH ROW EXECUTE PROCEDURE checkSamplingKeys();


/*
* The various different types of fractionation are modelled as different protocols - so we may need
to add records to the bioprotocolob table
*/


CREATE OR REPLACE FUNCTION mergeSNPAssays(varchar, integer, varchar, integer, varchar, varchar) RETURNS int4 AS
$BODY$
DECLARE
   assay_lsid alias for $1;
   assay_obid alias for $2;
   into_lsid alias for $3;
   into_obid alias for $4;
   new_assay_lsid alias for $5;
   username alias for $6;
   from_lsid varchar;
   from_obid integer;
   querycursor refcursor;
   cursorresult varchar;
   intresult integer;
   updatecount integer;
   into_snp_found boolean;
   intvar integer;
   
BEGIN
/*
* database stored procedure for merging SNP assays 
* 
* The biological SNP itself is modelled as a labresource.
* 
* Then there are one or more genetic tests for assaying the SNP, stored in the genetictestfact 
* table
*
* Thus a given SNP will have a single lab resource record, with one or more
* genetictestfact records.
*
* Almost all SNPs have an rs number - this is stored both as part of the NuNZ LSID for the 
* SNP and in the details table genetictestfact - e.g. 
* 
* Lab Resource Fact related to "genotype.snp.CCR6.2301436" : 
*
* labresourceob factnamespace 	attributename 	attributevalue 
* 12197172 	dbSNP 		rs number 	2301436 
*
*
* This stored procedure takes as arguments 
* 
* 1. the assay test lsid - this is the test that will be reattached elsewhere, and the name patched.
* 2. the assay test obid - this is the test that will be reattached elsewhere, and the name patched.
*    (not stricly necessary as lsid is unique - both identifiers are used as a cross check)
* 3. the "to"  SNP lsid - this will be the new master labresource record for the test
* 4. the "to" SNP obid - as above this is a double check that the correct receiving SNP as been identified
*    (not strictly necessary as lsid is unique)
* 5. The new assay LSID
*
* The receiving SNP should exist - if necessary you can create with createLabResource_SNP(locusname, rsnumber, alleles)
*
* If the receiving SNP is the same as the currently owning SNP, then the procedure will 
* do all of the patching on lsids, but the ownership will not change.
*
* Updates are done from the bottom up - starting with the genotype observations themselves.
* 
* 
*/

   updatecount := 0;


   /*
   * sanity checks - that we have these records
   */
   open querycursor for 
   select xreflsid from genetictestfact where
   obid = assay_obid and xreflsid = assay_lsid;
   fetch querycursor into cursorresult;
   if not found then
      raise exception 'Error - there is no genetic assay "%" to update, with the specified internal obid', from_lsid;
   end if;
   close querycursor;

   -- we might not find the target SNP if its the same as the current owner, and we are just 
   -- doing a rename, so don't yet flag an error if not found - just note 
   into_snp_found := true;
   open querycursor for 
   select xreflsid from labresourceob where
   obid = into_obid and xreflsid = into_lsid;
   fetch querycursor into cursorresult;
   if not found then
      --raise exception 'Error - there is no lab resource SNP  "%" to assign these tests to, with the specified internal obid', into_lsid;
      into_snp_found := false;
   end if;
   close querycursor;
   
   /*
   * we need to patch the semantic  lsids of the observations
   * these are like this : genotypestudy.ControlCanterbury.1778.sample.3.G10.GenotypeProtocol.TaqMan.[genotype.snp.DLG5.2289311].observation.27-06-2006.1
   * - where the bracketed string is the lsid of the master record
   */
   -- first get the lsid of the existing master
   open querycursor for 
   select 
      lr.xreflsid ,
      lr.obid
   from
      labresourceob lr join genetictestfact gtf on
      gtf.labresourceob = lr.obid
   where
      gtf.obid = assay_obid;
   fetch querycursor into from_lsid, from_obid;
   close querycursor;



   /*
   * if the existing owner is not the same as the
   * new owner, and we did not find the new oner, flag an error
   */
   if from_obid != into_obid and not into_snp_found then
      raise exception 'Error - there is no lab resource SNP  "%" to assign these tests to, with the specified internal obid', into_lsid;
   end if;



   /*
   * patch the genotypeobservations
   */
   update genotypeobservation set 
      xreflsid = replace(xreflsid , from_lsid, into_lsid), 
      observationcomment = 
      case
         when observationcomment is null then 'parent SNP updated from ' || from_lsid || ' to ' || into_lsid
         else observationcomment|| '; parent SNP updated from ' || from_lsid || ' to ' || into_lsid
      end ,
      lastupdateddate = now(),
      lastupdatedby = username
   where
      genetictestfact = assay_obid;

   GET DIAGNOSTICS updatecount = ROW_COUNT;


   /* 
   * attach comments to study records
   */
   open querycursor for 
   select 
      obid
   from 
      genotypestudy
   where
      labresourceob = from_obid;
   fetch querycursor into intresult;
   while found loop
   	perform addComment(intresult,  'parent SNP updated from ' || from_lsid || ' to ' || into_lsid, username) ;
        fetch querycursor into intresult;
   end loop;
   close querycursor;

   /*
   * patch the master genotypestudy records, including transferring these to the new master SNP
   * genotypestudy.ControlCanterbury.1097.sample.P3.D10.GenotypeProtocol.Sequenom.[genotype.snp.DEFA6.11784359]
   */
   update genotypestudy set 
      xreflsid = replace(xreflsid , from_lsid, into_lsid),
      labresourceob = into_obid,
      lastupdateddate = now(),
      lastupdatedby = username
   where
      labresourceob = from_obid;



   /* 
   * update the assay record to point to the (possibly) new SNP, and patch its name
   */
   update 
      genetictestfact 
   set 
      xreflsid = new_assay_lsid,
      labresourceob = into_obid,
      testdescription = 
      case 
         when testdescription is null then 'parent SNP updated from ' || from_lsid || ' to ' || into_lsid || ' ; assay lsid updated from ' || xreflsid || ' to ' || new_assay_lsid
         else testdescription || '; parent SNP updated from ' || from_lsid || ' to ' || into_lsid || ' ; assay lsid updated from ' || xreflsid || ' to ' || new_assay_lsid
      end,
      lastupdateddate  = now(),
      lastupdatedby = username
   where
      obid = assay_obid;


   /* 
   * This is how to deprecate the SNP - but we do not do it in this method
   */
/*
   update labresourceob 
   set
      xreflsid = 'DEPRECATED SNP NAME : ' || xreflsid,
      resourcename = 'DEPRECATED RESOURCE NAME : ' || resourcename,
      statuscode = 0,
      lastupdateddate = now(),
      resourcedescription = 
      case 
         when resourcedescription is null then 'This SNP transferred to ' || into_lsid
         else resourcedescription || ' ; This SNP transferred to ' || into_lsid
      end,
      lastupdatedby = username
   where
      obid = from_obid;
*/


   -- (these will only add the comment if not already attached)
   if from_obid = into_obid and from_lsid != into_lsid then
      update labresourceob set 
         xreflsid = into_lsid,
         lastupdateddate = now(),
         lastupdatedby = username
      where
         obid = from_obid and 
         xreflsid = from_lsid;


      perform addComment(from_obid,  'This SNP was renamed from ' || from_lsid || ' to ' || into_lsid,username) ;
   else
      perform addComment(from_obid,  'This SNP transferred to ' || into_lsid,username) ;
   end if;

   return updatecount;

END;

$BODY$ LANGUAGE plpgsql;


-- OLD example : select mergeSNPAssays('genetic test.JAK3.10758669.upstream A/C',12188444, 'genotype.snp.JAK2.10758669',12186805,'AMcCulloch');
-- example : select mergeSNPAssays('genetic test.JAK3.10758669.upstream A/C',12188444, 'genotype.snp.JAK2.10758669', 12186805, 'genetic test.JAK2.10758669.upstream A/C','AMcCulloch');
   
      
   
/*
* this method is used to update a survey answer, including annotation of the change.
* 3/2011 
* 
*/
CREATE OR REPLACE FUNCTION changeSurveyAnswer(varchar, varchar, varchar, varchar, varchar, varchar, varchar) RETURNS int4 AS
$BODY$
DECLARE
   querycursor refcursor;
   survey_lsid alias for $1;
   subject_lsid alias for $2;
   survey_question alias for $3;
   current_survey_response alias for $4;
   updated_survey_response alias for $5;
   comment_text alias for $6;   
   userid alias for $7;   
   labresourceobid integer;
   biosubjectobid integer;
   observationobid integer;
   updates integer;
   checkquestion varchar;
   checkanswer varchar;
BEGIN
/*
*
*
* This stored procedure takes as arguments 
* 
* 1. the survey lsid 
* 2. the subject lsid
* 3. the survey question 
* 4. the current survey response
* 5. the updated survey response 
* 6. The comment text 
* 7. The user doing the update
* 
* 
*/


   /*
   * sanity checks - that we have the survey
   */
   open querycursor for 
   select obid from  labresourceob where
   xreflsid  = survey_lsid  and resourcetype = 'Survey Form' ;
   fetch querycursor into labresourceobid;
   if not found then
      raise exception 'Error - there is no survey  "%" to update', survey_lsid;
   end if;
   close querycursor;


   /* 
   * that we have the subject 
   */
   open querycursor for 
   select obid from  biosubjectob where
   xreflsid  = subject_lsid ;
   fetch querycursor into biosubjectobid;
   if not found then
      raise exception 'Error - there is no subject "%" to update', subject_lsid;
   end if;
   close querycursor;


   /* 
   * that we have the question (and only one instance)
   */
   open querycursor for 
   select 
      so.obid, 
      sqf.question, 
      sqf.answer 
   from
      (surveystudy ss join surveyobservation so on 
      so.surveystudy = ss.obid ) join surveyquestionfact sqf on 
      sqf.surveyobservation = so.obid
   where
      ss.labresourceob = labresourceobid and
      so.biosubjectob = biosubjectobid and 
      sqf.question = survey_question and
      sqf.answer = current_survey_response;
   fetch querycursor into observationobid, checkquestion, checkanswer;
   if not found then
      raise exception 'Error - there is no question "%" to update, that has the specified current answer', survey_question;
   end if;
   fetch querycursor into checkquestion, checkanswer;
   if found then
      raise exception 'Error - question "%" is ambiguous - there is more than survey response that would be updated', survey_question;
   end if;
   close querycursor;


   /* 
   * add comment to subject
   */
   perform addComment(biosubjectobid,  'Survey update details: Survey=' || survey_lsid || ',Question='|| survey_question || ',From=' || current_survey_response ||',To=' || updated_survey_response || ',Reason=' || comment_text, userid) ;

   /* 
   * add comments to surveyobservation
   */
   perform addComment(observationobid,  '(The raw data record string contains the orginal survey answers - see the survey record from question names)', userid);


   /* do the update */
   update 
      surveyquestionfact
   set
      answer = updated_survey_response
   where
      surveyobservation = observationobid and
      answer = current_survey_response and
      question = survey_question;

   GET DIAGNOSTICS updates = ROW_COUNT;

   if updates != 1 then
      raise exception 'Error -  "%" rows were updated whereas expected 1', updates;
   end if;


   return updates;

END;

$BODY$ LANGUAGE plpgsql;



/*
************** support for batch reporting - report queue list 
*/
insert into obList(listName,listType,listDefinition,xreflsid)
values('simpleReportQueue_ToRun','REPORT_QUEUE_LIST','reports to run', 'Queue.simpleReportQueue_ToRun');
insert into obList(listName,listType,listDefinition,xreflsid)
values('simpleReportQueue_Running','REPORT_QUEUE_LIST','reports running', 'Queue.simpleReportQueue_Running');
insert into obList(listName,listType,listDefinition,xreflsid)
values('simpleReportQueue_Completed','REPORT_QUEUE_LIST','reports completed', 'Queue.simpleReportQueue_Completed');






-- example : 
-- select changeSurveyAnswer('surveyform.Crohns Disease Clinical Data Form v6 as at 26-11-08', 'IBDAukNunz.5179', 'ibddiagnosis', 'Crohn''s', 'UC', 'As advised by NuNZ staff', 'mccullocha') ;


